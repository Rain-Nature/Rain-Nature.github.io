<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue笔记的代码补充01-子传父props方式</title>
      <link href="/2025/02/10/Vue%E7%AC%94%E8%AE%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%8501-%E5%AD%90%E4%BC%A0%E7%88%B6props%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/02/10/Vue%E7%AC%94%E8%AE%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%8501-%E5%AD%90%E4%BC%A0%E7%88%B6props%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="组件数据直接传递方式-子传父props方式"><a href="#组件数据直接传递方式-子传父props方式" class="headerlink" title="组件数据直接传递方式-子传父props方式"></a>组件数据直接传递方式-子传父props方式</h3><p>​    以下代码，通过传递父组件的addTodoObj()方法，用子组件接收并调用该方法，通过该方法将子组件的数据传给父组件实现todos的增加</p><h4 id="1-父组件App-vue"><a href="#1-父组件App-vue" class="headerlink" title="(1)父组件App.vue"></a>(1)父组件App.vue</h4><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;  &lt;div id&#x3D;&quot;root&quot;&gt;    &lt;div&gt;      &lt;div&gt;      &lt;!-- 把方法传递给MyHeader组件 --&gt;        &lt;MyHeader :addTodoObj&#x3D;&quot;addTodoObj&quot;&#x2F;&gt;      &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F;导入组件import MyHeader from &#39;.&#x2F;components&#x2F;MyHeader.vue&#39;;export default &#123;  name: &#39;App&#39;,  components: &#123;    MyHeader,  &#125;,  data()&#123;      return&#123;          todos:[          &#123;&#39;001&#39;,&#39;看书&#39;,false&#125;,          &#123;&#39;002&#39;,&#39;学习&#39;,true&#125;,          &#123;&#39;003&#39;,&#39;跳绳&#39;,true&#125;,          ]      &#125;  &#125;,  methods:&#123;    addTodoObj(todoObj)&#123;      this.todos.unshift(todoObj)    &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-子组件MyHeader-vue"><a href="#2-子组件MyHeader-vue" class="headerlink" title="(2)子组件MyHeader.vue"></a>(2)子组件MyHeader.vue</h4><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;  &lt;div&gt;    &lt;div&gt;        &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入你的任务名称，按回车键确认&quot; @keydown.enter&#x3D;&quot;add&quot;&#x2F;&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; nanoid &#125; from &#39;nanoid&#39;;    export default &#123;        name:&#39;MyHeader&#39;,        methods:&#123;            add(e)&#123;                &#x2F;&#x2F;校验数据不能为空                if(!e.target.value) return alert(&quot;输入不能为空&quot;)                &#x2F;&#x2F;封装对象                                const todoObj &#x3D; &#123;                &#x2F;&#x2F;nanoid是一个轻量化自动生成id的工具                    id:nanoid(),                    title:e.target.value.trim(),                    done:false                &#125;                this.addTodoObj(todoObj)                &#x2F;&#x2F;清空输入栏                e.target.value &#x3D; &#39;&#39;            &#125;        &#125;,        &#x2F;&#x2F;使用props接受父组件提供的方法        props:[&#39;addTodoObj&#39;]    &#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS高级03-模块化</title>
      <link href="/2025/01/12/JS%E9%AB%98%E7%BA%A703-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2025/01/12/JS%E9%AB%98%E7%BA%A703-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1. 模块化"></a>1. 模块化</h3><p>​    将程序文件依据一定规则拆分为多个文件，每一个文件为一个模块，模块中的数据是私有的，模块之间相互隔离，但可以把模块内的指定数据交出去，供其他模块使用</p><h4 id="1-模块化会遇到的问题"><a href="#1-模块化会遇到的问题" class="headerlink" title="(1)模块化会遇到的问题"></a>(1)模块化会遇到的问题</h4><ul><li><p>全局污染(命名冲突)问题：</p><p>引入js 模块时，若有声明同名的方法，后面的会把前面的给覆盖掉</p></li><li><p>依赖混乱问题：</p><p>引入js模块时，有些要先执行，如果引入顺序错误会使得代码无法正常运行</p></li><li><p>数据安全问题：</p><p>数据没有进行封装，仅暴露接口函数，但实际上获得对象时，所有数据都已经获得</p></li></ul><p>​    使用模块化规范会解决上述的所有问题，全局污染问题详细阅读整个blog；依赖混乱问题，通过模块化使得模块之间呈树状结构所以不会混乱；数据安全问题，因为模块化规范是暴露的方式获得数据，所以不存在数据安全问题</p><h4 id="2-JS的模块化规范有哪些"><a href="#2-JS的模块化规范有哪些" class="headerlink" title="(2)JS的模块化规范有哪些"></a>(2)JS的模块化规范有哪些</h4><ul><li>CommonJS(ServerJS) ——-服务端应用广泛</li><li>ES6模块化 ——–浏览器端应用广泛</li></ul><h4 id="3-导入与导出"><a href="#3-导入与导出" class="headerlink" title="(3)导入与导出"></a>(3)导入与导出</h4><p>​    模块之间是隔离的，通过导入和导出进行数据和功能的共享</p><ul><li>导出**(暴露)**：模块公开其内部的一部分（如变量、函数等），使这些内容可以被其他模块使用</li><li>导入(引入)：模块引入和使用其他模块导出的内容，以重用代码和功能</li></ul><h5 id=""><a href="#" class="headerlink" title=""></a><a href="https://imgse.com/i/pEPPlsP"><img src="https://s21.ax1x.com/2025/01/10/pEPPlsP.png" alt="导入和导出"></a></h5><h3 id="2-CommonJS的模块化规范"><a href="#2-CommonJS的模块化规范" class="headerlink" title="2. CommonJS的模块化规范"></a>2. CommonJS的模块化规范</h3><p>​    双端都可以使用，但是一般使用在Node.js编写服务器</p><p>​    <code>注意不是在浏览器，this不指向window，它指向模块的exports对象</code></p><p>​    <strong>面试题：</strong><code>注意：CommonJS的模块化规范导入的数据/方法是原先的复制品，与原先的js文件的内容没有半毛钱关系</code></p><p>​    <a href="https://imgse.com/i/pEPDJ7n"><img src="https://s21.ax1x.com/2025/01/12/pEPDJ7n.png" alt="面试题"></a></p><p>​    输出：</p><pre class="line-numbers language-none"><code class="language-none">11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-CommonJS模块化语法"><a href="#1-CommonJS模块化语法" class="headerlink" title="(1)CommonJS模块化语法"></a>(1)CommonJS模块化语法</h4><h5 id="导入语法："><a href="#导入语法：" class="headerlink" title="导入语法："></a>导入语法：</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;在index.js中导入test.js模块const obj &#x3D; require(&#39;.&#x2F;test.js&#39;)console.log(obj)&#x2F;&#x2F;当然可以在赋值后马上解构：const &#123;name,getTel&#125; &#x3D; require(&#39;.&#x2F;test.js&#39;)&#x2F;&#x2F;注意：函数解构时不需要括号，调用时再加括号&#x2F;&#x2F;console.log(getTel())&#x2F;&#x2F;注意：如果解构的命名有冲突，则需要es6的加重命名&#x2F;&#x2F;const &#123;name:schoolName,age&#125; &#x3D; require(&#39;.&#x2F;school.js&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：如果test.js文件不主动暴露那么接受到的是一个空对象</strong></p><hr><h5 id="导出-暴露-语法：（第一种方式）"><a href="#导出-暴露-语法：（第一种方式）" class="headerlink" title="导出(暴露)语法：（第一种方式）"></a>导出(暴露)语法：（第一种方式）</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;test.jsconst name &#x3D; &#39;刘大业&#39;function getTel()&#123;return &#39;18899998888&#39;&#125;&#x2F;&#x2F;私有不暴露function getJob()&#123;return &#39;京东&#39;&#125;&#x2F;&#x2F;暴露语法：module.exports &#x3D; &#123;name:name  &#x2F;&#x2F;es6新语法直接写namegetTel  &#x2F;&#x2F;es6新语法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="导出-暴露-语法：（第二种方式）"><a href="#导出-暴露-语法：（第二种方式）" class="headerlink" title="导出(暴露)语法：（第二种方式）"></a>导出(暴露)语法：（第二种方式）</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;test.jsconst name &#x3D; &#39;刘大业&#39;function getTel()&#123;return &#39;18899998888&#39;&#125;&#x2F;&#x2F;私有不暴露function getJob()&#123;return &#39;京东&#39;&#125;&#x2F;&#x2F;暴露语法：exports.name &#x3D; name &#x2F;&#x2F;这里是把name赋值给exports.name，在CommonJS模块化中this.name完全等价于exports.nameexports.getTel &#x3D; getTel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-核心注意点"><a href="#2-核心注意点" class="headerlink" title="(2)核心注意点"></a>(2)核心注意点</h4><h5 id="注意点1"><a href="#注意点1" class="headerlink" title="注意点1"></a>注意点1</h5><p>​    在CommonJS模块化中，会为每一个JS文件准备一个空对象。每个模块(JS文件)的内部的：this、exports、modules.exports在初始化时都指向这个空对象，该空对象就是当前模块导出的数据</p><p>​    <a href="https://imgse.com/i/pEPiSw8"><img src="https://s21.ax1x.com/2025/01/10/pEPiSw8.png" alt="指向空对象"></a></p><h5 id="注意点2"><a href="#注意点2" class="headerlink" title="注意点2"></a>注意点2</h5><p>​    无论如何修改导出对象，最终导出的都是module.exports指向的值，即如果你没有对 <code>module.exports</code> 重新赋值，使用 <code>exports</code> 或 <code>module.exports</code> 添加的属性都能成功导出，如果修改了就按module.exports指向的值导出</p><p>​    <strong>范例1：面试题</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;test.js的内容exports &#x3D; &#123;a:1&#125;exports.b &#x3D; 2module.exports.c &#x3D; 3module.exports &#x3D; &#123;d:4&#125;&#x2F;&#x2F;main.js导入test.js并输出对象的结果const a &#x3D; require(&#39;.&#x2F;test.js&#39;)console.log(a)&#x2F;&#x2F;运行结果&#x2F;&#x2F;&#123; d:4 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    图示：黄色框为默认的空对象，第一步把exports指向{a:1}，第二步将b=2添加到exports所指向的对象，第三步把c=3放入空对象，第四步将module.exports指向一个新对象{d:4}</p><p><a href="https://imgse.com/i/pEPimwT"><img src="https://s21.ax1x.com/2025/01/10/pEPimwT.png" alt="注意点2"></a></p><p>​    范例2：</p><p>​    <strong>在没有修改 <code>module.exports</code> 的引用时</strong>，<code>exports</code> 和 <code>module.exports</code> 是同一个对象，因此通过 <code>exports</code> 和 <code>module.exports</code> 都可以向同一个对象添加属性。最终导出的是 <code>module.exports</code> 对象的内容</p><pre class="line-numbers language-none"><code class="language-none">exports.name &#x3D; &#39;John&#39;;module.exports.age &#x3D; 18;&#x2F;&#x2F;导出的是&#123;name:&#39;John&#39;,age:18&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="注意点3"><a href="#注意点3" class="headerlink" title="注意点3"></a>注意点3</h5><p>​    exports是对module.exports的<u>初始引用</u>(指向同一空对象)，仅为了方便给导出对象添加属性，所以不能使用exports = value 的形式导出数据，如果这样写会改变exports的指向（细节见上图）</p><h4 id="3-扩展理解：为什么模块之间是隔离的"><a href="#3-扩展理解：为什么模块之间是隔离的" class="headerlink" title="(3)扩展理解：为什么模块之间是隔离的"></a>(3)扩展理解：为什么模块之间是隔离的</h4><p>​    在CommonJS中，每一个写的JS文件的所有内容，在执行时已经被一个内置函数包起来了，所有写的代码都成为了这个函数的函数体，<strong>即形成了一个作用域</strong></p><p>​    内置函数如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;在test.js编写...console.log(arguments.callee.toString())&#x2F;&#x2F;在main.js引入test.js，并运行&#x2F;&#x2F;运行结果function(exports,require,module,__filename,__dirname)&#123;&#x2F;*test.js文件所有的内容*&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-Commonjs在浏览器运行"><a href="#4-Commonjs在浏览器运行" class="headerlink" title="(4)Commonjs在浏览器运行"></a>(4)Commonjs在浏览器运行</h4><p>​    Node.js支持CommonJS但是浏览器不支持，直接导入到html页面运行会缺少参数<code>require</code>(见上面那个内置函数)，需要下载一个翻译官–browserify</p><h5 id="安装browserify"><a href="#安装browserify" class="headerlink" title="安装browserify"></a>安装browserify</h5><ul><li><p>第一步：全局安装browserify：<code>npm i browserify -g</code></p></li><li><p>第二步：编译：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;备注：main.js是源文件，build.js是输出的目标文件browserify main.js -o build.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>第三步：index.html页面中引入使用这个js</p><pre class="line-numbers language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;build.js&quot;&gt;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="3-ES6的模块化规范-官方标准"><a href="#3-ES6的模块化规范-官方标准" class="headerlink" title="3. ES6的模块化规范(官方标准)"></a>3. ES6的模块化规范(官方标准)</h3><p>​    几乎所有的前端项目，只要用了脚手架就是在使用ES6的模式在写，它是目前最流行的模块化规范，同时<strong>ES6也是支持浏览器端和服务端，但其默认不支持服务器</strong></p><p>​    <strong>面试题：</strong><code>注意：ES6的模块化规范导入的数据/方法是原先的公用一块内存，只读不可改，这个是和CommonJS不一样的地方</code></p><p>​    <a href="https://imgse.com/i/pEPDG0s"><img src="https://s21.ax1x.com/2025/01/12/pEPDG0s.png" alt="面试题"></a></p><p>​    输出：</p><pre class="line-numbers language-none"><code class="language-none">13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-ES6模块化语法"><a href="#1-ES6模块化语法" class="headerlink" title="(1)ES6模块化语法"></a>(1)ES6模块化语法</h4><p>​    <strong>注意：三种导出方式可以同时使用</strong></p><h5 id="导出语法：分别导出（第一种方式）"><a href="#导出语法：分别导出（第一种方式）" class="headerlink" title="导出语法：分别导出（第一种方式）"></a>导出语法：分别导出（第一种方式）</h5><p>​    谁要导出就在谁前面加export</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;test.js&#x2F;&#x2F;导出属性export const name &#x3D; &#39;刘大业&#39;&#x2F;&#x2F;导出方法export function getTel()&#123;return &#39;18899998888&#39;&#125;&#x2F;&#x2F;私有不暴露function getJob()&#123;return &#39;京东&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="导出语法：统一导出（第二种方式）"><a href="#导出语法：统一导出（第二种方式）" class="headerlink" title="导出语法：统一导出（第二种方式）"></a>导出语法：统一导出（第二种方式）</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;test.jsconst name &#x3D; &#39;刘大业&#39;function getTel()&#123;return &#39;18899998888&#39;&#125;&#x2F;&#x2F;私有不暴露function getJob()&#123;return &#39;京东&#39;&#125;&#x2F;&#x2F;统一导出：&#123;&#125;不是对象，是类似对象的方式，本质是一个标记export&#123;name,getTel&#125; &#x2F;&#x2F;因为不是对象不能写成name:name,getTel:getTel这种形式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="导出语法：默认导出（第三种方式）"><a href="#导出语法：默认导出（第三种方式）" class="headerlink" title="导出语法：默认导出（第三种方式）"></a>导出语法：默认导出（第三种方式）</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;test.jsconst name &#x3D; &#39;刘大业&#39;function getTel()&#123;return &#39;18899998888&#39;&#125;&#x2F;&#x2F;私有不暴露function getJob()&#123;return &#39;京东&#39;&#125;&#x2F;&#x2F;默认导出：只有一组值&#x2F;&#x2F;导出对象只有&#123;default:900&#125;export default 900&#x2F;*&#x2F;&#x2F;导出对象为&#123;default:&#39;刘大业&#39;&#125;export default name*&#x2F;&#x2F;*&#x2F;&#x2F;导出多个的操作，导出对象为default:Objectexport default &#123;name:name  &#x2F;&#x2F;es6简写为namegetTel:getTel &#x2F;&#x2F;es6简写为getTel&#125;*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>​    <strong>注意：命名导入和默认导入可以同时使用</strong>：<code>import xyz,&#123;name,getTel&#125; from &#39;./test.js&#39;</code></p><h5 id="导入语法：万能语法，不管用什么导出方式都能接住（第一种方式）"><a href="#导入语法：万能语法，不管用什么导出方式都能接住（第一种方式）" class="headerlink" title="导入语法：万能语法，不管用什么导出方式都能接住（第一种方式）"></a>导入语法：万能语法，不管用什么导出方式都能接住（第一种方式）</h5><p>​    命名和分别导入、导出的值都一样，但是使用默认导出接到的值是<code>default:obj</code>，obj是一个对象，obj里面是默认导出的内容</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;index.jsimport * as test1 from &#39;.&#x2F;test.js&#39;console.log(test1)&#x2F;&#x2F;该文件需要放入浏览器中执行，所以需要引入到一个页面然后执行该页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="导入语法：命名导入，适用【分别导出、统一导出】（第二种方式）"><a href="#导入语法：命名导入，适用【分别导出、统一导出】（第二种方式）" class="headerlink" title="导入语法：命名导入，适用【分别导出、统一导出】（第二种方式）"></a>导入语法：命名导入，适用【分别导出、统一导出】（第二种方式）</h5><p>​    若命名冲突需要起别名如：<code>import &#123;name as SchoolName,getTel&#125; from &#39;./test.js&#39;</code></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;index.jsimport &#123;name,getTel&#125; from &#39;.&#x2F;test.js&#39;console.log(name)console.log(getTel())&#x2F;&#x2F;该文件需要放入浏览器中执行，所以需要引入到一个页面然后执行该页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="导入语法：默认导入，适用【默认导出】（第三种方式）"><a href="#导入语法：默认导入，适用【默认导出】（第三种方式）" class="headerlink" title="导入语法：默认导入，适用【默认导出】（第三种方式）"></a>导入语法：默认导入，适用【默认导出】（第三种方式）</h5><p>​    只要使用了默认导出，在导入时可以随便拿一个变量进行接收，接收的变量获得的是<code>default:obj</code>中的<code>obj</code></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;index.js&#x2F;&#x2F;qwe是随意起的名，适用默认导出import qwe from &#39;.&#x2F;test.js&#39;console.log(qwe)  &#x2F;&#x2F;运行结果：&#123;900&#125;&#x2F;&#x2F;该文件需要放入浏览器中执行，所以需要引入到一个页面然后执行该页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="导入语法：动态导入，不管用什么导出方式都能接住（第四种方式）"><a href="#导入语法：动态导入，不管用什么导出方式都能接住（第四种方式）" class="headerlink" title="导入语法：动态导入，不管用什么导出方式都能接住（第四种方式）"></a>导入语法：动态导入，不管用什么导出方式都能接住（第四种方式）</h5><p>​    在某一个特殊时间点：如点按钮、时间到了等，导入模块进行介入</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;index.html&lt;body&gt;&lt;!-- 模块化导入语法 --&gt;&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;button id&#x3D;&quot;btn&quot;&gt;导入模块&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&#x2F;&#x2F;index.jsconst btn &#x3D; document.getElementById(&#39;btn&#39;)&#x2F;&#x2F;这里看不懂async和await的话blog里搜ES8特性btn.onclick &#x3D; async()&#x3D;&gt;&#123;const result &#x3D; await import(&#39;.&#x2F;student.js&#39;)console.log(result)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="导入语法：import不接受任何数据（第五种方式）"><a href="#导入语法：import不接受任何数据（第五种方式）" class="headerlink" title="导入语法：import不接受任何数据（第五种方式）"></a>导入语法：import不接受任何数据（第五种方式）</h5><p>​    适用于每次启动就打印日志等行为</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;log.jsconsole.log(Math.random())&#x2F;&#x2F;index.jsimport &#39;.&#x2F;log.js&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-浏览器中运行ES6模块"><a href="#2-浏览器中运行ES6模块" class="headerlink" title="(2)浏览器中运行ES6模块"></a>(2)浏览器中运行ES6模块</h4><p>​    不写模块化导入语法浏览器无法正常执行</p><h5 id="浏览器运行：需要写模块化导入语法"><a href="#浏览器运行：需要写模块化导入语法" class="headerlink" title="浏览器运行：需要写模块化导入语法"></a>浏览器运行：需要写模块化导入语法</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;index.html&lt;body&gt;&lt;!-- 传统导入js的方式 这里不行&lt;script type&#x3D;&quot;text&#x2F;javasctipt&quot; src&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt; -- &gt;&lt;!-- 模块化导入语法 --&gt;&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>使用<code>module</code>关键字后，所有导出的字段在全局是搜索不到的，如果用text那么全局是搜索的到的</strong></p><h4 id="3-Node-服务器-中运行ES6模块"><a href="#3-Node-服务器-中运行ES6模块" class="headerlink" title="(3)Node(服务器)中运行ES6模块"></a>(3)Node(服务器)中运行ES6模块</h4><p>​    需要Node版本12及以上</p><h5 id="第一种方法：把所有模块化的js文件改名为mjs"><a href="#第一种方法：把所有模块化的js文件改名为mjs" class="headerlink" title="第一种方法：把所有模块化的js文件改名为mjs"></a>第一种方法：把所有模块化的js文件改名为mjs</h5><p>​    最后运行那个导入了模块的mjs文件，如上面那个test.js和index.js都改名为test.mjs和index.mjs，用Node运行index.mjs</p><h5 id="第二种方法：在工程文件目录增加一个package-json"><a href="#第二种方法：在工程文件目录增加一个package-json" class="headerlink" title="第二种方法：在工程文件目录增加一个package.json"></a>第二种方法：在工程文件目录增加一个package.json</h5><p>​    编写代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;type&quot;:&quot;module&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    项目结构图示</p><p>​    <a href="https://imgse.com/i/pEPGrg1"><img src="https://s21.ax1x.com/2025/01/11/pEPGrg1.png" alt="项目结构"></a></p><h3 id="4-其他模块化规范"><a href="#4-其他模块化规范" class="headerlink" title="4. 其他模块化规范"></a>4. 其他模块化规范</h3><p>​    除了CommonJS和ES6以外，还有AMD和CMD，这两个需要用时再自行了解</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS高级02-原型</title>
      <link href="/2025/01/04/JS%E9%AB%98%E7%BA%A702-%E5%8E%9F%E5%9E%8B/"/>
      <url>/2025/01/04/JS%E9%AB%98%E7%BA%A702-%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-深入面向对象"><a href="#1-深入面向对象" class="headerlink" title="1. 深入面向对象"></a>1. 深入面向对象</h3><p>​    JS通过构造函数和原型来实现面向对象</p><p>​    前端面向过程更多，但也有面向对象</p><h3 id="2-原型"><a href="#2-原型" class="headerlink" title="2. 原型"></a>2. 原型</h3><h4 id="1-案例引入"><a href="#1-案例引入" class="headerlink" title="(1)案例引入"></a>(1)案例引入</h4><pre class="line-numbers language-none"><code class="language-none">function Star()&#123;this.sing &#x3D; function()&#123;console.log(&#39;我会唱歌&#39;)&#125;&#125;const ldy &#x3D; new Star()const zxy &#x3D; new Star()&#x2F;&#x2F;obj.sing 没有括号表示函数本身，加括号表示要调用这个函数方法console.log(ldy.sing &#x3D;&#x3D;&#x3D; zxy.sing)  &#x2F;&#x2F;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    因为在构造函数中声明函数时，每次new一个新对象，都会再次为这个函数分配空间，这会造成内存的浪费。而通过原型可以解决这个问题</p><h4 id="2-原型对象-prototype"><a href="#2-原型对象-prototype" class="headerlink" title="(2)原型对象(prototype)"></a>(2)原型对象(prototype)</h4><p>​    公共的属性写在构造函数身上，公共的方法写在原型身上</p><h5 id="原型对象的目的是实现方法的共享"><a href="#原型对象的目的是实现方法的共享" class="headerlink" title="原型对象的目的是实现方法的共享"></a>原型对象的目的是实现方法的共享</h5><ul><li>构造函数通过原型分配的函数是所有对象共享的</li><li>JS规定，每一个构造函数都有一个prototype属性，指向另一个对象，我们也称为原型对象</li><li>原型对象可以挂载函数，对象实例化不会多次创建原型上的函数</li><li>我们可以把不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法了</li><li><strong>构造函数和原型对象中的this都指向调用的实例化对象</strong>，需要注意的是实例化对象要调用一下原型里的方法，原型对象的this才指向实例对象，而构造函数的this需要new一个对象才指向实例对象，否则都指向全局对象 (window)</li></ul><h5 id="原型的使用"><a href="#原型的使用" class="headerlink" title="原型的使用"></a>原型的使用</h5><pre class="line-numbers language-none"><code class="language-none">function Star()&#123;&#125;Star.prototype.sing &#x3D; function()&#123;console.log(&#39;我会唱歌&#39;)&#125;const ldy &#x3D; new Star()const zxy &#x3D; new Star()console.log(ldy.sing &#x3D;&#x3D;&#x3D; zxy.sing)  &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    图示：</p><p>​    <a href="https://imgse.com/i/pAjvyZV"><img src="https://s21.ax1x.com/2024/12/25/pAjvyZV.png" alt="原型"></a></p><h4 id="3-constructor属性"><a href="#3-constructor属性" class="headerlink" title="(3)constructor属性"></a>(3)constructor属性</h4><p>​    每一个原型对象里默认都有constructor属性，作用是指向该原型对象的构造函数</p><blockquote><p>console.log(Star.prototype.constructor === Star)  //true</p></blockquote><h5 id="constructor的使用：指回原型对象的构造函数"><a href="#constructor的使用：指回原型对象的构造函数" class="headerlink" title="constructor的使用：指回原型对象的构造函数"></a>constructor的使用：指回原型对象的构造函数</h5><pre class="line-numbers language-none"><code class="language-none">function star()&#123;&#125;&#x2F;&#x2F;使用prototype一共有两种情况&#x2F;&#x2F;第一种情况：直接给prototype追加方法Star.prototype.dance &#x3D; function()&#123;console.log(&#39;跳舞&#39;)&#125;Star.prototype.sing &#x3D; function()&#123;console.log(&#39;唱歌&#39;)&#125;&#x2F;&#x2F;第二种情况：以对象的形式，直接赋值给Star.prototypeStar.prototype &#x3D; &#123;  &#x2F;&#x2F;赋值，整个替换&#x2F;&#x2F;重新指回这个原型对象的构造函数，不写的话对象中的constructor属性就丢了constructor:Star,&#x2F;&#x2F;函数的对象里声明dance:function()&#123;console.log(&#39;跳舞&#39;)&#125;,sing:function()&#123;console.log(&#39;唱歌&#39;)&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-对象原型-proto"><a href="#4-对象原型-proto" class="headerlink" title="(4)对象原型(__proto__)"></a>(4)对象原型(<code>__proto__</code>)</h4><p>​    在每一个实例对象中都会有一个属性<code>__proto__</code>指向构造函数的prototype对象，由此实例对象可以直接使用原型的方法</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li><p><code>[[prototype]]</code>和<code>__proto__</code>意义相同，浏览器显示<code>[[prototype]]</code>，写代码写<code>__proto__</code></p></li><li><p><code>__proto__</code>是一个只读属性不可以进行修改</p></li><li><p><strong><code>__proto__</code>中也有一个constructor属性，指向创建该实例对象的构造函数</strong></p><pre class="line-numbers language-none"><code class="language-none">console.log(ldy.__proto__ &#x3D;&#x3D;&#x3D; Star.prototype)  &#x2F;&#x2F;trueconsole.log(ldy.__proto__.constructor &#x3D;&#x3D;&#x3D; Star)   &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="5-JS的继承：原型继承"><a href="#5-JS的继承：原型继承" class="headerlink" title="(5)JS的继承：原型继承"></a>(5)JS的继承：原型继承</h4><p>​    JS的面向对象大多借助原型对象实现继承的特性</p><p>​    核心思想：<code>子类构造函数的原型= new 父类构造函数</code></p><h5 id="使用原型对象来实现继承-错例"><a href="#使用原型对象来实现继承-错例" class="headerlink" title="使用原型对象来实现继承(错例)"></a>使用原型对象来实现继承(错例)</h5><p>​    样例：这个居然用一个写死的对象来当被继承的，我刚看还没反应过来，也是真的逆天</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;父类Person，这里是一个对象，而不是构造函数const Person &#x3D; &#123;head:1,eyes:2&#125;&#x2F;&#x2F;子类女人 构造函数 需要继承Personconst Woman &#x3D; &#123;&#125;&#x2F;&#x2F;核心步骤1：Women通过原型对象来继承Person，这是覆盖操作Woman.prototype &#x3D; Person&#x2F;&#x2F;核心步骤2：需要将Woman.prototype指回Women构造函数，不写这个指不回原来的Woman了Woman.prototype.constructor &#x3D; Woman&#x2F;&#x2F;生成Women的实例const red &#x3D; new Woman()&#x2F;&#x2F;打印父类的属性console.log(red.head)  &#x2F;&#x2F;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="上面代码的问题"><a href="#上面代码的问题" class="headerlink" title="上面代码的问题"></a>上面代码的问题</h5><p>​    obj.prototype都是在堆里生成，如果直接等于Person，那么指向同一个地址，那么对于Woman.prototype的修改（增加函数），Man.prototype也会获得该函数，这是有问题的</p><p><a href="https://imgse.com/i/pAvYuBd"><img src="https://s21.ax1x.com/2024/12/26/pAvYuBd.png" alt="pAvYuBd.png"></a></p><h5 id="问题解决-正例-：与错的对比着看"><a href="#问题解决-正例-：与错的对比着看" class="headerlink" title="问题解决(正例)：与错的对比着看"></a>问题解决(正例)：与错的对比着看</h5><p>​    使用构造函数，通过<code>new</code>关键字来生成不同的对象来解决上面指向同一地址的问题</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;构造函数function Person()&#123;this.eyes &#x3D; 2this.head &#x3D; 1&#125;&#x2F;&#x2F;女人 构造函数function Woman()&#123;&#125;&#x2F;&#x2F;通过原型继承PersonWoman.prototype &#x3D; new Person()&#x2F;&#x2F;指回WomanWoman.prototype.constructor &#x3D; Woman&#x2F;&#x2F;给女人添加一个方法Women.prototype.baby &#x3D; function()&#123;console.log(&#39;宝贝&#39;)&#125;const red &#x3D; new Woman()console.log(red)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-原型链"><a href="#6-原型链" class="headerlink" title="(6)原型链"></a>(6)原型链</h4><p>​    基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是链状结构，我们将原型对象的链状结构关系称为原型链</p><p>​    注意：<strong>只要是对象就有<code>__proto__</code>指向原型对象，只要是原型对象就有constructor指向创造它的构造函数</strong></p><h5 id="原型链的原理"><a href="#原型链的原理" class="headerlink" title="原型链的原理"></a>原型链的原理</h5><p>​    原型对象中也有一个<code>__proto__</code>的属性，它的指向如下</p><p>​    JS中有一个最大的类Object，普通类的构造函数的原型对象里的对象原型指向Object的原型对象</p><pre class="line-numbers language-none"><code class="language-none">console.log(Person.prototype.__prot__ &#x3D;&#x3D;&#x3D; Object.prototype)   &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    而<code>Object.prototype.__proto__</code>指向<code>null</code></p><pre class="line-numbers language-none"><code class="language-none">console.log(Object.prototype.__proto__)   &#x2F;&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="原型链图示"><a href="#原型链图示" class="headerlink" title="原型链图示"></a>原型链图示</h5><p><a href="https://imgse.com/i/pAvw45d"><img src="https://s21.ax1x.com/2024/12/26/pAvw45d.png" alt="原型链"></a></p><h5 id="原型链的使用"><a href="#原型链的使用" class="headerlink" title="原型链的使用"></a>原型链的使用</h5><p>​    因为原型对象里的方法，实例可以使用，那么通过继承，则可以获得父类的方法</p><p>​    原型链-查找规则图示：    <a href="https://imgse.com/i/pAv0FqU"><img src="https://s21.ax1x.com/2024/12/26/pAv0FqU.png" alt="原型链-查找规则"></a></p><p>​    第6条样例：</p><pre class="line-numbers language-none"><code class="language-none">console.log(red instanceof Person)   &#x2F;&#x2F;trueconsole.log(red instanceof Object)   &#x2F;&#x2F;trueconsole.log(red instanceof Array)   &#x2F;&#x2F;falseconsole.log([1,2,3] instanceof Array)   &#x2F;&#x2F;trueconsole.log(Array instanceof Object)   &#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-深浅拷贝"><a href="#3-深浅拷贝" class="headerlink" title="3. 深浅拷贝"></a>3. 深浅拷贝</h3><p>​    浅拷贝、深拷贝只针对引用类型</p><p>​    因为如果对引用类型采用直接赋值的操作进行拷贝，老对象和新对象在堆中指向的同一个对象，对新对象修改就是在对老对象进行修改，两个对象相互影响这样不符合拷贝的初衷</p><h4 id="1-浅拷贝："><a href="#1-浅拷贝：" class="headerlink" title="(1)浅拷贝："></a>(1)浅拷贝：</h4><p>​    对引用数据执行浅拷贝，它里面是简单数据类型则直接拷贝值，如果是引用数据类型则拷贝的是地址</p><h5 id="常见方法："><a href="#常见方法：" class="headerlink" title="常见方法："></a>常见方法：</h5><p>​    1.拷贝对象：Object.assign()  /  展开运算符{…obj}</p><p>​    2.拷贝数组：Array.prototype.concat()  /  […arr]</p><h5 id="对象拷贝的例子："><a href="#对象拷贝的例子：" class="headerlink" title="对象拷贝的例子："></a>对象拷贝的例子：</h5><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123;uname:&#39;pink&#39;,age:18&#125;&#x2F;&#x2F;浅拷贝const o &#x3D; &#123;...obj&#125;&#x2F;&#x2F;或 &#x2F;&#x2F;const o &#x3D; &#123;&#125;&#x2F;&#x2F;Object.assign(o,obj)o.age &#x3D; 20console.log(o)   &#x2F;&#x2F;20console.log(obj)   &#x2F;&#x2F;18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    数组自己举一反三</p><p>​    <strong>浅拷贝只拷贝最外面这一层，如果对象里还有对象（即引用数据类型），那对象的对象修改，又会出现直接赋值的情况</strong></p><h4 id="2-深拷贝："><a href="#2-深拷贝：" class="headerlink" title="(2)深拷贝："></a>(2)深拷贝：</h4><p>​    拷贝的是对象，不是地址</p><h5 id="常见方法：-1"><a href="#常见方法：-1" class="headerlink" title="常见方法："></a>常见方法：</h5><p>​    1.通过递归实现深拷贝</p><p>​    2.lodash/cloneDeep</p><p>​    3.通过JSON.stringify()实现</p><h5 id="递归实现深拷贝："><a href="#递归实现深拷贝：" class="headerlink" title="递归实现深拷贝："></a>递归实现深拷贝：</h5>]]></content>
      
      
      
        <tags>
            
            <tag> JS高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS高级01-JS的面向对象</title>
      <link href="/2024/12/22/JS%E9%AB%98%E7%BA%A701-JS%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/12/22/JS%E9%AB%98%E7%BA%A701-JS%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><p>​    规定变量被访问的范围</p><p>​    <code>JS中共有4种作用域：全局作用域、局部作用域(块作用域)、函数作用域(普通函数)以及eval作用域，作用域会影响this的指向</code></p><h4 id="1-局部作用域：-1-函数作用域、2-块作用域"><a href="#1-局部作用域：-1-函数作用域、2-块作用域" class="headerlink" title="(1)局部作用域：{1.函数作用域、2.块作用域}"></a>(1)局部作用域：{1.函数作用域、2.块作用域}</h4><p>​    1.函数内部声明的变量只能在函数内部被访问，函数执行完毕，函数内部的变量实际被清空了</p><p>​    2.<code>&#123;&#125;</code>包裹的为代码块（包括if的，for的），let、const会产生块作用域，var不会产生块作用域</p><p>​    注意：局部作用域外部未再次定义就使用会报错</p><h4 id="2-全局作用域"><a href="#2-全局作用域" class="headerlink" title="(2)全局作用域"></a>(2)全局作用域</h4><p>​    <code>&lt;script&gt;</code> 标签内和.js文件内，即【最外层】就是所谓的全局作用域，全局作用域中声明的变量，任何其他作用域都可以被访问</p><h4 id="3-垃圾回收机制"><a href="#3-垃圾回收机制" class="headerlink" title="(3)垃圾回收机制"></a>(3)垃圾回收机制</h4><ul><li>引用计数法：跟踪被引用的次数，如果为0则释放内存，缺点：相互引用的变量无法销毁会造成内存泄漏</li><li>标记清除法：从根部扫描对象，查不到的对象会被回收，解决了引用计数法的缺点</li></ul><h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="(4)闭包"></a>(4)闭包</h4><p>​    内层函数访问到外层函数的作用域：闭包=内层函数 + 外层函数的变量</p><p>​    <a href="https://imgse.com/i/pAqh4IO"><img src="https://s21.ax1x.com/2024/12/15/pAqh4IO.png" alt="闭包的使用"></a></p><p>​    此时，调用fun()函数可以打印出a的值，调用outer()也可以</p><h5 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h5><p>​    1. 在内定义数据，实现数据的私有</p><h5 id="闭包引发的问题"><a href="#闭包引发的问题" class="headerlink" title="闭包引发的问题"></a>闭包引发的问题</h5><p>​    因为函数一直被调用，变量无法回收，会导致内存的泄露</p><h4 id="5-变量提升"><a href="#5-变量提升" class="headerlink" title="(5)变量提升"></a>(5)变量提升</h4><p>​    属于JS语言缺陷，它允许变量声明之前即被访问（仅存在于var声明变量），只提升声明不提升赋值且仅提升到当前作用域最前面，实际开发少用var</p><h3 id="2-函数进阶"><a href="#2-函数进阶" class="headerlink" title="2. 函数进阶"></a>2. 函数进阶</h3><h4 id="1-函数提升"><a href="#1-函数提升" class="headerlink" title="(1)函数提升"></a>(1)函数提升</h4><p>​    函数在声明之前就可以被调用，原因：JS会把所有函数声明提升到当前作用域的最前面</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;fn()function fu()&#123;console(&#39;函数提升&#39;)&#125;&lt;&#x2F;script&gt;&#x2F;&#x2F;函数可以正常执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-普通函数的两种定义格式-命名函数和匿名函数"><a href="#2-普通函数的两种定义格式-命名函数和匿名函数" class="headerlink" title="(2)普通函数的两种定义格式(命名函数和匿名函数)"></a>(2)普通函数的两种定义格式(命名函数和匿名函数)</h4><h5 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h5><p>​    有一个确切的名字，可以直接使用</p><p>​    语法：</p><pre class="line-numbers language-none"><code class="language-none">function fn1() &#123; console.log(&quot;这是命名函数&quot;) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>​    匿名函数本身没有名字，但可以通过变量 <code>fn2</code> 来调用它</p><p>​    匿名函数属于函数表达式，不存在函数提升</p><p>​    语法：</p><pre class="line-numbers language-none"><code class="language-none">const fn2 &#x3D; function() &#123; console.log(&quot;我是匿名函数表达式&quot;) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-普通函数-命名函数和匿名函数-的this"><a href="#3-普通函数-命名函数和匿名函数-的this" class="headerlink" title="(3)普通函数(命名函数和匿名函数)的this"></a>(3)普通函数(命名函数和匿名函数)的this</h4><p>​    命名函数 和 匿名函数在 <code>this</code> 的绑定行为上是相同的，<code>this</code> 的值由函数的调用方式决定</p><h4 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="(4)箭头函数"></a>(4)箭头函数</h4><p>​    箭头函数属于表达式函数，不存在函数提升</p><p>​    <strong>基本语法，有简写小心区分</strong></p><p>​    1. 最基本的语法</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;&#x2F;&#x2F;箭头函数，参数xconst fn &#x3D; (x) &#x3D;&gt; &#123;console.log(x)&#125;&#x2F;&#x2F;调用fn(1)&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2. 当参数只有一个时可以省略小括号，只有一行代码时可以省略大括号</p><pre class="line-numbers language-none"><code class="language-none">const fn &#x3D; x &#x3D;&gt; console.log(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    3. 只有一行代码时可以省略return</p><pre class="line-numbers language-none"><code class="language-none">const fn &#x3D; x &#x3D;&gt; x+x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <code>4. 箭头函数可以直接返回一个对象</code></p><pre class="line-numbers language-none"><code class="language-none">const fn &#x3D; (uname) &#x3D;&gt; (&#123;name:uname&#125;)&#x2F;&#x2F;调用fn(&#39;刘就成&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-箭头函数的this（一定要注意作用域）"><a href="#5-箭头函数的this（一定要注意作用域）" class="headerlink" title="(5)箭头函数的this（一定要注意作用域）"></a>(5)箭头函数的this（一定要注意作用域）</h4><p>​    在普通函数中，每一个新函数根据它是如何被调用的来定义这个函数的this值</p><p>​    箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this，即看上一层作用域的this指向谁</p><p>​    <em>易错代码1</em></p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;const obj &#x3D; &#123;  uname: &#39;hello&#39;,  sayHi: () &#x3D;&gt; &#123;    console.log(this);  &#x2F;&#x2F; this指向window，而不是obj，因为obj不是作用域  &#125;&#125;obj.sayHi()&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <em>易错代码2</em></p><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123;  name: &#39;Alice&#39;,  greet: function() &#123;    &#x2F;&#x2F; 这里的 this 指向 obj    setTimeout(() &#x3D;&gt; &#123;      console.log(this.name); &#x2F;&#x2F; 箭头函数继承外部 greet() 的 this    &#125;, 1000);  &#125;&#125;;obj.greet();  &#x2F;&#x2F; 输出 &#39;Alice&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-解构、遍历与过滤"><a href="#3-解构、遍历与过滤" class="headerlink" title="3. 解构、遍历与过滤"></a>3. 解构、遍历与过滤</h3><p>​    解构是快速批量的将[值/对象属性和方法]给变量的简洁语法</p><h4 id="1-数组解构"><a href="#1-数组解构" class="headerlink" title="(1)数组解构"></a>(1)数组解构</h4><p>​    变量的顺序对应数组单元值的位置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//1.普通情况</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token comment">//数组解构</span><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> arrconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment">//2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment">//3</span><span class="token comment">//2.变量少，单元值多，可以用剩余参数接</span><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token operator">...</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//1</span>console<span class="token punctuation">,</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment">//2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment">//[3,4]</span><span class="token comment">//3.多维数组</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token punctuation">[</span>c<span class="token punctuation">,</span>d<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arrconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//1</span>console<span class="token punctuation">,</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment">//2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment">//3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment">//4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-对象解构"><a href="#2-对象解构" class="headerlink" title="(2)对象解构"></a>(2)对象解构</h4><p>​    <strong>解构的变量名必须和原对象的属性名一致，如果找不到对应的会被赋值为undefined</strong>，要起别名可以使用<code>名称:新名称</code></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;普通情况const obj &#x3D; &#123;uname:&#39;刘就成&#39;,age:24&#125;const &#123;uname:name,age&#125; &#x3D; obj console.log(name)  &#x2F;&#x2F;刘就成console.log(age)  &#x2F;&#x2F;24&#x2F;&#x2F;多级对象解构const pig &#x3D; &#123;name:&#39;佩奇&#39;,family:&#123;mother:妈妈,father:爸爸&#125;&#125;const &#123;name, family:&#123;mother,father&#125;&#125; &#x3D; pigconsole.log(name)  &#x2F;&#x2F;佩奇console.log(mother)  &#x2F;&#x2F;妈妈console.log(father)  &#x2F;&#x2F;爸爸&#x2F;&#x2F;可以只要对象中的一部分,在函数传参时可以传pig，写函数体时只用familyconst &#123;family&#125; &#x3D; pig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-foreach遍历数组"><a href="#3-foreach遍历数组" class="headerlink" title="(3)foreach遍历数组"></a>(3)foreach遍历数组</h4><p>​    只能遍历数组不能遍历对象，且内部没有return</p><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>​    语法：当前数组元素必写，索引号可选</p><pre class="line-numbers language-none"><code class="language-none">被遍历的数组.forEach(function(当前数组元素,【当前数组索引号】))&#123;&#x2F;&#x2F;函数体&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    样例：</p><pre class="line-numbers language-none"><code class="language-none">const arr &#x3D; [&#39;ren&#39;,&#39;green&#39;,&#39;pink&#39;]arr.forEach(function(item,index)&#123;console.log(item)   &#x2F;&#x2F;数组元素：red green pinkconsole.log(index)  &#x2F;&#x2F;索引号：0,1,2&#125;)&#x2F;&#x2F;改为箭头函数同时省略index的写法arr.forEach(item &#x3D;&gt; &#123;console.log(item)   &#x2F;&#x2F;数组元素：red green pink&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-filter方法过滤数组"><a href="#4-filter方法过滤数组" class="headerlink" title="(4)filter方法过滤数组"></a>(4)filter方法过滤数组</h4><p>​    返回一个符合条件的新数组，过滤不会影响原数组</p><h5 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h5><p>​    语法：currentValue必须写，index可选</p><pre class="line-numbers language-none"><code class="language-none">被遍历的数组.filter(function(currentValue,index)&#123;retun 筛选条件&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    样例：</p><pre class="line-numbers language-none"><code class="language-none">const arr &#x3D; [10,20,30]const newArr &#x3D; arr.filter(function(item,index)&#123;return item &gt;&#x3D; 20&#125;)console.log(newArr)  &#x2F;&#x2F;[20,30]&#x2F;&#x2F;改为箭头函数同时省略index的写法const newArr &#x3D; arr.filter(item &#x3D;&gt; item&gt;&#x3D; 20)console.log(newArr)  &#x2F;&#x2F;[20,30]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-深入对象"><a href="#4-深入对象" class="headerlink" title="4. 深入对象"></a>4. 深入对象</h3><p>​    <strong>对象的定义可以用修饰符const、let、var，但是对象里面的属性和方法不可以用修饰符</strong>，只能直接通过对象引用来修改它们</p><h4 id="1-创建对象的三种方式"><a href="#1-创建对象的三种方式" class="headerlink" title="(1)创建对象的三种方式"></a>(1)创建对象的三种方式</h4><ul><li><p>利用对象字面量创建对象</p><pre class="line-numbers language-none"><code class="language-none">const o &#x3D; &#123;name:&#39;佩奇&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>利用new Object创建对象</p><pre class="line-numbers language-none"><code class="language-none">const o &#x3D; new Object(&#123;name:&#39;佩奇&#39;&#125;)console.log(o)  &#x2F;&#x2F;&#123;name:&#39;佩奇&#39;&#125;&#x2F;&#x2F;也可以直接往对象变量里追加const o &#x3D; new Object()o.age &#x3D; 10console.log(o)  &#x2F;&#x2F;&#123;age:10&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>利用构造函数创建对象</p></li></ul><h4 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="(2)构造函数"></a>(2)构造函数</h4><p>​    构造函数是一种特殊的函数，主要用来创建对象，通过构造函数可以快速创建多个类似的对象</p><h5 id="构造函数的约定"><a href="#构造函数的约定" class="headerlink" title="构造函数的约定"></a>构造函数的约定</h5><p>​    1. <strong>构造函数的命名以大写字母开头</strong></p><p>​    2. 构造函数只能由“new”操作符来执行</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>​    例子：创建一个猪对象</p><pre class="line-numbers language-none"><code class="language-none">function Pig(uname,age)&#123;this.uname &#x3D; unamethis.age &#x3D; age&#125;const peiqi &#x3D; new Pig(&#39;佩奇&#39;,6)  &#x2F;&#x2F;实例化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="构造函数的存储"><a href="#构造函数的存储" class="headerlink" title="构造函数的存储"></a>构造函数的存储</h5><p>​    <strong>函数对象（包括构造函数）是存储在内存中的一个对象，这通常是在堆中</strong>，因为函数对象可以是动态创建的，并且可能会在多个地方被引用</p><p>​    如下代码：<code>Person</code> 函数本身是一个对象，它会被存储在堆内存中，通过 <code>new</code> 关键字创建的 <code>person1</code> 实例（对象）也是存储在堆内存中</p><pre class="line-numbers language-none"><code class="language-none">function Person(name) &#123;  this.name &#x3D; name;&#125;const person1 &#x3D; new Person(&#39;Alice&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-对象的this和普通函数的this以及箭头函数的this"><a href="#3-对象的this和普通函数的this以及箭头函数的this" class="headerlink" title="(3)对象的this和普通函数的this以及箭头函数的this"></a>(3)对象的this和普通函数的this以及箭头函数的this</h4><ul><li>如果你调用一个函数时使用 <code>new</code> 关键字，JavaScript 会将 <code>this</code> 绑定到新创建的对象。</li><li>如果函数是作为方法调用的，<code>this</code> 会指向调用该方法的对象。</li><li>如果函数是直接调用的，<code>this</code> 会指向全局对象</li></ul><p>​    需要注意的是：箭头函数的 <code>this</code>继承自外部函数或上下文的 <code>this</code>，它没有自己的 <code>this</code></p><h4 id="4-实例成员和静态成员"><a href="#4-实例成员和静态成员" class="headerlink" title="(4)实例成员和静态成员"></a>(4)实例成员和静态成员</h4><p>​    在 JavaScript 中，属性/方法不一定要在类或构造函数定义时就明确地定义，也可以在实例化对象后通过实例来添加和调用属性/方法</p><h5 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h5><p>​    通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员（实例属性和实例方法）</p><p>​    样例：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;实例成员function Pig(name)&#123;&#x2F;&#x2F;实例属性this.name &#x3D; name&#125;const peiqi &#x3D; new Pig(&#39;佩奇&#39;)&#x2F;&#x2F;实例属性peiqi.name &#x3D; &#39;小猪&#39;&#x2F;&#x2F;实例方法peiqi.sayHi &#x3D; () &#x3D;&gt; &#123;console.log(&#39;你好&#39;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><p>​    构造函数的属性和方法被称为静态成员(静态属性、静态方法)</p><p>​    说明：</p><pre><code> 1. 静态成员只能构造函数访问 2. 静态方法中的this指向构造函数</code></pre><p>​    样例：</p><pre class="line-numbers language-none"><code class="language-none">function Pig(name)&#123;&#x2F;&#x2F;实例属性this.name &#x3D; name&#125;&#x2F;&#x2F;静态属性Pig.eyes &#x3D; 2console.log(Pig.eyes)&#x2F;&#x2F;静态方法Pig.sayHi &#x3D; function()&#123;console.log(&#39;hi&#39;)&#125;Pig.sayHi()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-内置构造函数"><a href="#5-内置构造函数" class="headerlink" title="5. 内置构造函数"></a>5. 内置构造函数</h3><p>​    内置构造函数是 JavaScript 内部预定义的函数，允许你创建特定类型的对象，并提供了一些基本功能和属性</p><h4 id="1-JS的包装类型"><a href="#1-JS的包装类型" class="headerlink" title="(1)JS的包装类型"></a>(1)JS的包装类型</h4><p>​    <strong>JS基本数据类型</strong>：字符串、数值、布尔、undefined、null</p><p>​    只有对象才有方法，但是在js中定义字符串、数值、布尔的变量也可以调用写好的方法，是因为js底层做了封装，将这些基本数据类型转为了复杂数据类型(对象)</p><h4 id="2-其他内置构造函数"><a href="#2-其他内置构造函数" class="headerlink" title="(2)其他内置构造函数"></a>(2)其他内置构造函数</h4><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><p>​    定义：</p><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; new Object();&#x2F;&#x2F; 或者简写为：let obj &#x3D; &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    Object常用的静态方法</p><ul><li><p>Object.keys(对象名)：获取对象中所有的属性，返回的是一个数组</p><pre class="line-numbers language-none"><code class="language-none">Object.keys(Pig)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Object.values(对象名)：获取对象所有属性的值，返回也是一个数组</p><pre class="line-numbers language-none"><code class="language-none">Object.values(Pig)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​    </p><h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><p>​    数组的核心方法如下图所示：传参都为回调函数，reduce多一个初始值</p><p>​    map是对数组所有元素进行相同处理</p><p>​    <a href="https://imgse.com/i/pAXt6I0"><img src="https://s21.ax1x.com/2024/12/22/pAXt6I0.png" alt="pAXt6I0.png"></a></p><p>​    样例：(forEach，filter，map，reduce)</p><pre class="line-numbers language-none"><code class="language-none">const numbers &#x3D; [1, 2, 3, 4, 5];&#x2F;&#x2F; forEach:输出数组的每个元素numbers.forEach(function(num) &#123;  console.log(num);&#125;);&#x2F;&#x2F; filter:过滤出大于 3 的数字const filtered &#x3D; numbers.filter(function(num) &#123;  return num &gt; 3;&#125;);console.log(filtered);  &#x2F;&#x2F; [4, 5]&#x2F;&#x2F; map:每个数字乘以 2const doubled &#x3D; numbers.map(function(num) &#123;  return num * 2;&#125;);console.log(doubled);  &#x2F;&#x2F; [2, 4, 6, 8, 10]&#x2F;&#x2F; reduce:计算数组所有元素的总和，初始值是0，可以省略但会以数组的第一个值为初始值所以最好不要省&#x2F;&#x2F;accumulator是计数值(初始值由函数第二个参数决定)，currentValue是元素值(如果是对象就是完整对象)，计算时需要把数据拆出来const sum &#x3D; numbers.reduce(function(accumulator, currentValue) &#123;  return accumulator + currentValue;&#125;, 0);console.log(sum);  &#x2F;&#x2F; 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> JS高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>落实blog整改的要求.md</title>
      <link href="/2024/11/14/%E8%90%BD%E5%AE%9Eblog%E6%95%B4%E6%94%B9%E7%9A%84%E8%A6%81%E6%B1%82/"/>
      <url>/2024/11/14/%E8%90%BD%E5%AE%9Eblog%E6%95%B4%E6%94%B9%E7%9A%84%E8%A6%81%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h4 id="关于落实blog整改的要求"><a href="#关于落实blog整改的要求" class="headerlink" title="关于落实blog整改的要求"></a>关于落实blog整改的要求</h4><p>​    依据Rain关于学习习惯改革基本思想，对Rain对内门户网站做出一下整改要求</p><p>​    1.所有blog的名字需要简洁明了的概括blog内容，不得再以XXX0X的格式发布</p><p>​    2.blog应该记录重点、难点，不得以写书的方式进行blog的记录，应该明确重点，不会的记，会的就不用记了，力争打造一流blog信息    库。所以需对原先所有记录blog进行扫描，如果有弱智记录，全部删除</p><p>​    3.冗余blog，烂尾blog，能合并进行合并，不能合并全部清空删除</p><p>​    4.对blogUI、控件进一步优化，打造方便便捷的全新体验</p><p>​    5.降低blog密级，允许一部分人访问、浏览blog，逼促自身不固步自封，进一步向前</p><p>​    6.整改优化的md应该在标头添加Rain-重置<code>&lt;h2&gt;</code> 来标明</p><p>​    7.本要求之后的blog不受优化影响</p><p>​    政策详细-Rain2025改革</p><p>​    对所有基础技术栈依据博客进行完全性审核，不合格的该回炉重造，全部回炉重造<br>​    对博客中烂尾技术该删除全部删除，把冗余性给完全降低<br>​    博客内容进行细致化整理包含方向、工具、非方向三个大板块<br>​    落实博客整理以及博客内容精细化，让博客的作用发挥实处<br>​    建立面试以及面试题模块，方便对面试题的筛选<br>​    建立健全技术考核，每周对常用技术sql、前后端访问等吃饭性技术更新改革，让工作任务落到实处</p><p>​    整改日志</p><p>​    11.30：完成页面文字的更新</p><p>​    12.03：完成搜索功能</p><p>​    12.19：高亮优化、目录优化，启动一期整改，SQL、JS整改</p><p>​    1.6：添加背景，优化背景图片</p><p>​    1.8：导航栏颜色修改，主色调修改</p><p>​    1.12：添加JavaScript的blog图片</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mabatis03</title>
      <link href="/2023/11/13/Mabatis03/"/>
      <url>/2023/11/13/Mabatis03/</url>
      
        <content type="html"><![CDATA[<h2 id="多表操作与注解开发"><a href="#多表操作与注解开发" class="headerlink" title="多表操作与注解开发"></a>多表操作与注解开发</h2><h4 id="1-MyBatis多表操作的实体类设计-1"><a href="#1-MyBatis多表操作的实体类设计-1" class="headerlink" title="1. MyBatis多表操作的实体类设计(1)"></a>1. MyBatis多表操作的实体类设计(1)</h4><p>​    在多表操作时，在一对多的情况下会出现外键，外键虽然只关联副表的一个字段但表示通过整个那个外键的类来表示，如下图所示用户编号用整个用户对象来代替</p><p><a href="https://imgse.com/i/pC01jjx"><img src="https://s1.ax1x.com/2023/06/29/pC01jjx.png" alt="订单表的实体类设计"></a></p><h4 id="2-MyBatis多表操作的映射文件设计-一对一"><a href="#2-MyBatis多表操作的映射文件设计-一对一" class="headerlink" title="2. MyBatis多表操作的映射文件设计(一对一)"></a>2. MyBatis多表操作的映射文件设计(一对一)</h4><p>​    如整表查询为例，查询到的是user对象的字段但不能手动存入，所以在MyBatis配置文件中需要将查询到的数据进行封装，此时需要手动定义映射关系使用resultMap，简单关系使用resultType</p><p><a href="https://imgse.com/i/pC03zzn"><img src="https://s1.ax1x.com/2023/06/29/pC03zzn.png" alt="pC03zzn.png"></a></p><p>​    注意1：主键使用id标签，其他字段使用result标签</p><p>​    注意2：在 MyBatis 的 <code>resultMap</code> 标签中，<code>type</code> 属性用于指定映射结果的类型。它指定了结果映射的目标 Java 类型，表示将查询结果映射到哪个 Java 对象。<strong>图中因为起了别名所以没有使用全限定名</strong></p><p>​    在 MyBatis 中，<code>resultMap</code> 和 <code>resultType</code> 都是用于映射查询结果的标签，但它们在使用和功能上有一些区别。</p><ol><li><code>resultMap</code>：<code>resultMap</code> 是 MyBatis 中定义映射关系的标签，通过 <code>resultMap</code> 可以定义如何将查询结果映射到 Java 对象的属性。<code>resultMap</code> 可以包含多个 <code>result</code> 子标签，每个 <code>result</code> 标签指定了一个查询结果字段与 Java 对象属性之间的映射关系。使用 <code>resultMap</code> 可以方便地处理复杂的映射关系，如一对一、一对多等关联关系。<code>resultMap</code> 的定义可以在 XML 配置文件中，也可以通过注解方式定义。</li><li><code>resultType</code>：<code>resultType</code> 的映射与 Java 实体类是相关的。当使用 <code>resultType</code> 时，MyBatis 会将查询结果自动映射到指定的 Java 类型对象上。<code>resultType</code> 是 MyBatis 中直接指定查询结果类型的标签，通过 <code>resultType</code> 可以指定返回结果的 Java 类型。<code>resultType</code> 可以是任何可被映射的 Java 类型，如基本类型（int、String等）、自定义类、Map等。在使用 <code>resultType</code> 的情况下，MyBatis 会通过自动映射将查询结果的列名与对应的 Java 对象属性名进行匹配，并将结果赋值给对应的属性。相比于 <code>resultMap</code>，<code>resultType</code> 适用于简单的查询映射，不涉及复杂的关联关系。</li></ol><p>​    除了上图，还可以通过<code>&lt;association&gt;</code> 标签来定义user字段。在 MyBatis 中，<code>&lt;association&gt;</code> 元素用于在结果映射中定义对象之间的关联关系。它通常用于处理一对一的关联关系，其中一个对象包含对另一个对象的引用。</p><p><a href="https://imgse.com/i/pC0XW7Q"><img src="https://s1.ax1x.com/2023/06/30/pC0XW7Q.png" alt="另一种写法"></a></p><h4 id="3-MyBatis多表操作的实体类设计-2"><a href="#3-MyBatis多表操作的实体类设计-2" class="headerlink" title="3. MyBatis多表操作的实体类设计(2)"></a>3. MyBatis多表操作的实体类设计(2)</h4><p>​    用户对于订单是一对多的关系，所以此时需要给用户表中添加对应的订单list，这样可以在实体类中反映出一对多的关系</p><p><a href="https://imgse.com/i/pCByjeS"><img src="https://s1.ax1x.com/2023/07/01/pCByjeS.png" alt="pCByjeS.png"></a></p><h4 id="4-MyBatis多表操作的映射文件设计-一对多"><a href="#4-MyBatis多表操作的映射文件设计-一对多" class="headerlink" title="4. MyBatis多表操作的映射文件设计(一对多)"></a>4. MyBatis多表操作的映射文件设计(一对多)</h4><p>​    配置集合使用collection标签</p><p><a href="https://imgse.com/i/pCB6T7F"><img src="https://s1.ax1x.com/2023/07/01/pCB6T7F.png" alt="pCB6T7F.png"></a></p><p>​    注意：在原先order表中定义了字段uesr，user代表的是一个对象，但数据库表order中没有与之对应的字段，所以不需要配置，即<strong>实体表的数据可以根据需要&gt;=数据库表的数据</strong></p><h4 id="5-MyBatis多表操作设计-多对多"><a href="#5-MyBatis多表操作设计-多对多" class="headerlink" title="5. MyBatis多表操作设计(多对多)"></a>5. MyBatis多表操作设计(多对多)</h4><p>​    MyBatis的多对多操作与一对多相差不大，唯一需要注意的是，多对多有三张表</p><p><a href="https://imgse.com/i/pCDi21e"><img src="https://s1.ax1x.com/2023/07/01/pCDi21e.png" alt="pCDi21e.png"></a></p><p>​    创建实体类role和user，<strong>不用创建中间表的实体类，但需要中间表作为sql查询语句的桥梁</strong></p><p><a href="https://imgse.com/i/pCDioAP"><img src="https://s1.ax1x.com/2023/07/01/pCDioAP.png" alt="role实体类"></a></p><p><a href="https://imgse.com/i/pCDiq1g"><img src="https://s1.ax1x.com/2023/07/01/pCDiq1g.png" alt="user实体类"></a></p><p>​    编写多对多的MyBatis映射文件</p><p><a href="https://imgse.com/i/pCDFZH1"><img src="https://s1.ax1x.com/2023/07/01/pCDFZH1.png" alt="pCDFZH1.png"></a></p><p>​    测试查询情况</p><p><a href="https://imgse.com/i/pCDFmAx"><img src="https://s1.ax1x.com/2023/07/01/pCDFmAx.png" alt="pCDFmAx.png"></a></p><h4 id="6-多表查询知识小结与补充"><a href="#6-多表查询知识小结与补充" class="headerlink" title="6. 多表查询知识小结与补充"></a>6. 多表查询知识小结与补充</h4><p><a href="https://imgse.com/i/pCDFQ3D"><img src="https://s1.ax1x.com/2023/07/01/pCDFQ3D.png" alt="pCDFQ3D.png"></a></p><p>​    <strong>补充</strong></p><p>​    在 MyBatis 中，<code>&lt;collection&gt;</code> 和 <code>&lt;association&gt;</code> 元素都用于处理对象之间的关联关系，但它们有一些关键的区别。</p><ol><li>处理的数据类型：<ul><li><code>&lt;association&gt;</code> 用于处理一对一的关联关系，其中一个对象包含对另一个对象的引用。</li><li><code>&lt;collection&gt;</code> 用于处理一对多的关联关系，其中一个对象包含多个关联对象的集合。</li></ul></li><li>结果映射方式：<ul><li><code>&lt;association&gt;</code> 通过指定关联对象的属性和映射规则来创建关联对象，并将其设置到父对象中的对应属性中。</li><li><code>&lt;collection&gt;</code> 通过指定关联对象集合的属性和映射规则，以及用于构建每个关联对象的结果映射，来创建关联对象集合，并将其设置到父对象中的对应属性中。</li></ul></li><li>子元素的定义：<ul><li><code>&lt;association&gt;</code> 元素可以包含 <code>&lt;id&gt;</code> 和 <code>&lt;result&gt;</code> 子元素来映射关联对象的属性。</li><li><code>&lt;collection&gt;</code> 元素可以包含 <code>&lt;id&gt;</code>、<code>&lt;result&gt;</code>、<code>&lt;association&gt;</code>、<code>&lt;collection&gt;</code> 等子元素来映射关联对象的属性以及关联对象集合中的元素。</li></ul></li></ol><h4 id="7-MyBatis的常用注解"><a href="#7-MyBatis的常用注解" class="headerlink" title="7. MyBatis的常用注解"></a>7. MyBatis的常用注解</h4><p><a href="https://imgse.com/i/pCDxwtg"><img src="https://s1.ax1x.com/2023/07/02/pCDxwtg.png" alt="pCDxwtg.png"></a></p><p>​    注意：One和Many使用结果集封装，用于多表查询</p><p>​    使用注解后，不需要写MyBatis的映射文件，将注解写在接口中对应的方法上</p><p>​    使用注解并编写接口文件</p><p><a href="https://imgse.com/i/pCDzfqP"><img src="https://s1.ax1x.com/2023/07/02/pCDzfqP.png" alt="pCDzfqP.png"></a></p><p>​    在MyBatis核心配置文件中，需要将注解进行扫描，原先对映射文件的配置可以删除</p><p><a href="https://imgse.com/i/pCDzXq0"><img src="https://s1.ax1x.com/2023/07/02/pCDzXq0.png" alt="pCDzXq0.png"></a></p><h4 id="8-MyBatis注解实现复杂映射开发"><a href="#8-MyBatis注解实现复杂映射开发" class="headerlink" title="8. MyBatis注解实现复杂映射开发"></a>8. MyBatis注解实现复杂映射开发</h4><p>​    实现复杂关系映射之前我们可以在映射文件中通过配置<code>&lt;resultMap&gt;</code> 来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置</p><p><a href="https://imgse.com/i/pC65JGq"><img src="https://s1.ax1x.com/2023/07/06/pC65JGq.png" alt="pC65JGq.png"></a></p><p><a href="https://imgse.com/i/pC65RsO"><img src="https://s1.ax1x.com/2023/07/06/pC65RsO.png" alt="pC65RsO.png"></a></p><h5 id="1-注解实现一对一查询"><a href="#1-注解实现一对一查询" class="headerlink" title="(1) 注解实现一对一查询"></a>(1) 注解实现一对一查询</h5><p>​    使用注解的方式完成封装，在接口类进行注解编写，下图为一对一的封装</p><p><a href="https://imgse.com/i/pCcJLgf"><img src="https://s1.ax1x.com/2023/07/07/pCcJLgf.png" alt="一对一的封装"></a></p><p>​    除了上面方式还可以使用<code>@One</code>标签来完成一对一封装，<code>@One</code>标签里可以引用其他接口的方法并获得执行结果</p><p><a href="https://imgse.com/i/pCcYssS"><img src="https://s1.ax1x.com/2023/07/07/pCcYssS.png" alt="一对一查询的第二种写法"></a></p><h5 id="2-注解实现一对多查询"><a href="#2-注解实现一对多查询" class="headerlink" title="(2) 注解实现一对多查询"></a>(2) 注解实现一对多查询</h5><p>​    使用<code>@Many</code>标签来完成一对多封装，<code>@Many</code>标签里也是可以引用其他接口的方法并获得执行结果</p><p><a href="https://imgse.com/i/pCctJS0"><img src="https://s1.ax1x.com/2023/07/07/pCctJS0.png" alt="一对多查询"></a></p><h5 id="3-注解实现多对多查询"><a href="#3-注解实现多对多查询" class="headerlink" title="(3) 注解实现多对多查询"></a>(3) 注解实现多对多查询</h5><p>​    使用<code>@Many</code>标签来完成多对多封装，<code>@Many</code>标签里也是可以引用其他接口的方法并获得执行结果</p><p><a href="https://imgse.com/i/pCcNN9I"><img src="https://s1.ax1x.com/2023/07/07/pCcNN9I.png" alt="要被引用的方法"></a></p><p><a href="https://imgse.com/i/pCcNZN9"><img src="https://s1.ax1x.com/2023/07/07/pCcNZN9.png" alt="多对多查询"></a></p><h5 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="(4) 注意事项"></a>(4) 注意事项</h5><p>​    相比于使用xml配置的方式，使用注解对于sql语句进行了拆分，将之前xml配置中的一条sql语句拆分成了两条</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mabatis02</title>
      <link href="/2023/11/13/Mabatis02/"/>
      <url>/2023/11/13/Mabatis02/</url>
      
        <content type="html"><![CDATA[<h4 id="1-MyBatis的增删改查操作"><a href="#1-MyBatis的增删改查操作" class="headerlink" title="1. MyBatis的增删改查操作"></a>1. MyBatis的增删改查操作</h4><p>​    MyBatis实现增删改查操作需要三步：<br>​<br>​    1. 编写接口方法：(Mapper接口，参数，返回值)<br>​    2. 编写SQL：xml映射文件<br>​    3. 执行方法</p><h4 id="2-MyBatis的查询操作"><a href="#2-MyBatis的查询操作" class="headerlink" title="2. MyBatis的查询操作"></a>2. MyBatis的查询操作</h4><h5 id="1-查询所有数据步骤"><a href="#1-查询所有数据步骤" class="headerlink" title="(1)查询所有数据步骤"></a>(1)查询所有数据步骤</h5><p>​    编写接口方法：Mapper接口</p><p><a href="https://imgse.com/i/pFm7yTS"><img src="https://s11.ax1x.com/2024/01/26/pFm7yTS.png" alt="BrandMapper"></a></p><p>​    编写xml映射文件</p><p><a href="https://imgse.com/i/pFm7cFg"><img src="https://s11.ax1x.com/2024/01/26/pFm7cFg.png" alt="BrandMapper.xml"></a></p><p>​    执行测试</p><p><a href="https://imgse.com/i/pFm7fln"><img src="https://s11.ax1x.com/2024/01/26/pFm7fln.png" alt="测试方法以及运行结果"></a></p><p>​    上述为最基本的使用代理的查询方式，但是注意，查询到的数据有些是封装上的，有些没有被封装上为null。原因是因为表的字段名称与实体类的字段名称不一致，如表中叫<code>brand_name</code>，而实体类中叫<code>brandName</code></p><p>​    解决方案1：将查询的sql语句起别名，别名与实体类一致；缺点每个sql查询都要定义一次别名</p><p>​    解决方案1优化：使用sql片段防止重复写一段sql，注意sql标签要写在mapper标签里面；缺点不灵活</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--在BrandMapper.xml中使用sql片段--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper.BrandMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--sql片段--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>brand_column<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        id,brand_name as brandName,company_name as companyName,ordered,description,status    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pojo.Brand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>brand_column<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        from tb_brand    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    解决方案2：使用resultMap灵活的解决（最常用）</p><p>​    resultMap可以将实体类属性与表的字段映射，使用resultMap替换之前的resultType</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 自己对比代码感受一下，首先是type="pojo.Brand"是全限定名，id是唯一标识--></span><span class="token comment">&lt;!-- 这里&lt;select id="selectAll" resultMap="brandResultMap">使用的是resultMap，而不是resultType--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper.BrandMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- property是实体类属性名，column是数据库里列名--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>brandResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pojo.Brand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 主键用id，其他键用result--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>brandName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>brand_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>companyName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>company_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>brandResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select *        from tb_brand    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-通过id查询某条记录详情"><a href="#2-通过id查询某条记录详情" class="headerlink" title="(2)通过id查询某条记录详情"></a>(2)通过id查询某条记录详情</h5><p>​    编写mapper接口方法：selectById(int id)</p><p><a href="https://imgse.com/i/pFnLfJO"><img src="https://s11.ax1x.com/2024/01/27/pFnLfJO.png" alt="BrandMapper.java"></a></p><p>​    编写xml映射文件，注意：参数类型：parameterType可以省略，因为只传了一个参数</p><p><a href="https://imgse.com/i/pFnL5Se"><img src="https://s11.ax1x.com/2024/01/27/pFnL5Se.png" alt="BrandMapper.xml"></a></p><p>​    执行测试</p><p><a href="https://imgse.com/i/pFnLOFf"><img src="https://s11.ax1x.com/2024/01/27/pFnLOFf.png" alt="运行结果"></a></p><p>​    <strong>知识点：mybatis参数占位符</strong></p><ol><li><p>#{}：在执行sql时会将其替换为?，可以防止SQL注入</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_brand where id&#x3D;#&#123;id&#125;&#x2F;&#x2F;假设传值1&#x2F;&#x2F;执行结果：select * from tb_brand where id&#x3D;?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>${}：拼sql，会存在SQL注入问题</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_brand where id&#x3D;$&#123;id&#125;&#x2F;&#x2F;假设传值1&#x2F;&#x2F;执行结果：select * from tb_brand where id&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用时机</p><ul><li>参数传递的时候使用：#{}</li><li>动态传递sql的表名或列名不固定时使用：${}</li></ul></li></ol><p>​    <strong>知识点：特殊字符处理方法</strong></p><p>​    因为sql语句是写在xml文件中，所以有些字符不能正常使用比如<code>&lt;</code> </p><ol><li><p>使用转义字符</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">//原sql：select * from tb_brand where id&lt;$&#123;id&#125;//转义改为select * from tb_brand where id <span class="token entity named-entity" title="&lt;">&amp;lt;</span> $&#123;id&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用CDATA区</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;原sql：select * from tb_brand where id&lt;$&#123;id&#125;&#x2F;&#x2F;CDATA区&lt;![CDATA[ 内容 ]]&gt;，中间写要用的字符select * from tb_brandwhere id &lt;![CDATA[ &lt; ]]&gt; #&#123;id&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h5 id="3-多条件查询-难点-：通过多个条件查询记录"><a href="#3-多条件查询-难点-：通过多个条件查询记录" class="headerlink" title="(3)多条件查询(难点)：通过多个条件查询记录"></a>(3)多条件查询(难点)：通过多个条件查询记录</h5><p>​    对于多条件参数的接收mybatis有三种接收方式</p><ol><li><p>使用注解<code>@Param接收</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Brand</span><span class="token punctuation">></span></span> <span class="token function">selectByCondition</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"status"</span><span class="token punctuation">)</span><span class="token keyword">int</span> status<span class="token punctuation">,</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"companyName"</span><span class="token punctuation">)</span><span class="token class-name">String</span> companyName<span class="token punctuation">,</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"brandName"</span><span class="token punctuation">)</span><span class="token class-name">String</span> brandName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：@Param(“值”)要和xml中#{值}相对应</p></li><li><p>使用实体类封装后传参：用实体类set方法封装</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Brand</span><span class="token punctuation">></span></span> <span class="token function">selectByCondition</span><span class="token punctuation">(</span><span class="token class-name">Brand</span> brand<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 注意：这里要作为条件的brand实体类的属性要和xml中#{}里的值一一对应，不然会封装不上</p></li><li><p>使用map封装后传参：</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Brand</span><span class="token punctuation">></span></span> <span class="token function">selectByCondition</span><span class="token punctuation">(</span><span class="token class-name">Map</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 注意：这里要作为条件的Map的键要和xml中#{}里的值一一对应，不然会封装不上</p></li></ol><p>​    </p><p>​    上面三个条件查询mapper统一对应的xml如下所示</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByCondition<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>brandResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>select *from tb_brandwherestatus=#&#123;status&#125;and company_name like #&#123;companyName&#125;and brand_name like #&#123;brandName&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>对第一种做一个示例</strong></p><p>​    编写mapper方法selectByCondition</p><p><a href="https://imgse.com/i/pFuNMrV"><img src="https://s11.ax1x.com/2024/01/29/pFuNMrV.png" alt="BrandMapper.java"></a></p><p>​    编写mapper的xml映射文件</p><p><a href="https://imgse.com/i/pFuN3aF"><img src="https://s11.ax1x.com/2024/01/29/pFuN3aF.png" alt="BrandMapper.xml"></a></p><p>​    测试执行，注意我这里为方便数据直接写了”%华为%”，正常是需要字符串选择模糊查询的方式<code>%</code>or<code>_</code></p><p><a href="https://imgse.com/i/pFuNNx1"><img src="https://s11.ax1x.com/2024/01/29/pFuNNx1.png" alt="运行测试"></a></p><p>​    注意：此时可以查询到数据，但是用户输入数据时可以不是三个，是一个或者两个，那么这时需要使用动态的多条件查询</p><h5 id="4-动态多条件查询-难点-：解决上面条件查询的问题"><a href="#4-动态多条件查询-难点-：解决上面条件查询的问题" class="headerlink" title="(4)动态多条件查询(难点)：解决上面条件查询的问题"></a>(4)动态多条件查询(难点)：解决上面条件查询的问题</h5><p>​    SQL语句会随着用户的输入或外部条件的变化而变化，我们称为动态SQL </p><p>​    将3示例改为动态SQL查询只需要修改mapper的xml映射文件为动态SQL，修改后的xml文件如下图所示</p><p><a href="https://imgse.com/i/pF3v2Fg"><img src="https://s11.ax1x.com/2024/02/11/pF3v2Fg.png" alt="修改后的xml映射文件"></a></p><p>​    注意：这里xml使用了三个参数在定义的mapper映射里面也要有三个参数对应，使用接口方法时的传参可以是null因为这里我使用动态sql保证程序正常运行</p><h4 id="3-动态sql语句"><a href="#3-动态sql语句" class="headerlink" title="3. 动态sql语句"></a>3. 动态sql语句</h4><p>​    MyBatis的动态sql提供if、choose、trim、foreach</p><h5 id="1-动态sql-if"><a href="#1-动态sql-if" class="headerlink" title="(1) 动态sql-if"></a>(1) 动态sql-if</h5><p><a href="https://imgse.com/i/pClpOw8"><img src="https://s1.ax1x.com/2023/06/17/pClpOw8.png" alt="if的使用例子"></a></p><p>​    其中where标签类似于<code>1=1</code>，让sql语句在没有where条件的时候也能正常执行，但<code>1=1</code>在没有条件时会查询出表中所有字段，而使用where标签就不会</p><p>​    if标签中的test<strong>必写</strong>，test里面写判断条件，写的是传入参数的判断，标签里写要拼凑的sql语句</p><h5 id="2-动态sql-choose-when-otherwise-：选择一个，类似Java中的switch语句"><a href="#2-动态sql-choose-when-otherwise-：选择一个，类似Java中的switch语句" class="headerlink" title="(2) 动态sql-choose(when,otherwise)：选择一个，类似Java中的switch语句"></a>(2) 动态sql-choose(when,otherwise)：选择一个，类似Java中的switch语句</h5><p><a href="https://imgse.com/i/pF89iDI"><img src="https://s11.ax1x.com/2024/02/11/pF89iDI.png" alt="choose的使用例子"></a></p><p>​    注意：这里where语句可以使用<code>&lt;where&gt;</code> 标签</p><h5 id="3-动态sql-foreach"><a href="#3-动态sql-foreach" class="headerlink" title="(3) 动态sql-foreach"></a>(3) 动态sql-foreach</h5><p>​    对于where传递参数像in关键字(多个or)时，可以使用foreach</p><p><a href="https://imgse.com/i/pCNRplT"><img src="https://s1.ax1x.com/2023/06/25/pCNRplT.png" alt="pCNRplT.png"></a></p><p>​    注意，<code>collection</code> 属性的值是传递集合应该与要传递的集合的名字一致，该集合可以是Java自带的，也可以是自定义的，以便 MyBatis 可以正确地将参数值传递给 <code>foreach</code> 元素进行循环迭代。</p><p>​    <code>open</code> 属性指定在循环开始时要输出的字符串，<code>separator</code> 属性指定在每个元素之间要输出的字符串，<code>close</code> 属性指定在循环结束时要输出的字符串。</p><p>​    <code>foreach</code> 元素的 <code>item</code> 属性指定循环中的当前元素变量名，其类似于增强for循环的x，作循环输出使用。<code>#&#123;id&#125;</code> 是一个占位符，代表当前循环的元素，这里使用了 MyBatis 的参数注入方式。</p><p>​    <code>item=&quot;id&quot;</code> 表示在循环中每个元素的变量名是 <code>id</code>。<code>#&#123;id&#125;</code> 则用于在 SQL 语句中引用这个变量，并将它替换为实际的元素值</p><h4 id="4-MyBatis的添加操作"><a href="#4-MyBatis的添加操作" class="headerlink" title="4. MyBatis的添加操作"></a>4. MyBatis的添加操作</h4><h5 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h5><p>​    修改操作和增加操作很像</p><p>​    在UserMapper.xml文件中编写修改操作</p><p><a href="https://imgse.com/i/p9BDgfJ"><img src="https://s1.ax1x.com/2023/05/09/p9BDgfJ.png" alt="p9BDgfJ.png"></a></p><p>​    在测试类中进行测试</p><p><a href="https://imgse.com/i/p9BrCtg"><img src="https://s1.ax1x.com/2023/05/09/p9BrCtg.png" alt="p9BrCtg.png"></a></p><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>​    删除操作只需要传递一个id数字即可删除整行，所以不需要传递对象</p><p>​    在UserMapper.xml文件中编写删除操作，因为是传递整型，所以parameterType的值为整型的全包名；<code>#&#123;id&#125;</code>因为这里是只有一个类型且是简单类型的值，所以写啥都可以比如<code>#&#123;XXX&#125;</code>，写成id是为了提高代码可读性</p><p><a href="https://imgse.com/i/p9BrMh4"><img src="https://s1.ax1x.com/2023/05/09/p9BrMh4.png" alt="p9BrMh4.png"></a></p><p>​    在测试类中进行测试</p><p><a href="https://imgse.com/i/p9Br2E8"><img src="https://s1.ax1x.com/2023/05/09/p9Br2E8.png" alt="p9Br2E8.png"></a></p><p>​    删除操作的注意事项</p><p><a href="https://imgse.com/i/p9BsFUO"><img src="https://s1.ax1x.com/2023/05/09/p9BsFUO.png" alt="p9BsFUO.png"></a></p><h4 id="2-MyBatis映射文件深入"><a href="#2-MyBatis映射文件深入" class="headerlink" title="2. MyBatis映射文件深入"></a>2. MyBatis映射文件深入</h4><h5 id="4-sql语句的抽取"><a href="#4-sql语句的抽取" class="headerlink" title="(4) sql语句的抽取"></a>(4) sql语句的抽取</h5><pre><code>  使用sql标签进行抽取，抽取后通过定义的id名进行引入</code></pre><p><a href="https://imgse.com/i/pCNRXuD"><img src="https://s1.ax1x.com/2023/06/25/pCNRXuD.png" alt="pCNRXuD.png"></a></p><h4 id="3-MyBatis核心配置文件深入"><a href="#3-MyBatis核心配置文件深入" class="headerlink" title="3. MyBatis核心配置文件深入"></a>3. MyBatis核心配置文件深入</h4><h5 id="1-typeHandlers标签"><a href="#1-typeHandlers标签" class="headerlink" title="(1) typeHandlers标签"></a>(1) typeHandlers标签</h5><p>​    因为在Java和JDBC数据提取与存储的过程中相同的数据类型在这两种语言的存储方式是不一样的，MyBatis使用默认的类型处理器来对数据类型进行转换，有时如果需要指定类型转换就需要使用typeHandlers标签自定义进行转换</p><p><a href="https://imgse.com/i/pCNW6VH"><img src="https://s1.ax1x.com/2023/06/25/pCNW6VH.png" alt="pCNW6VH.png"></a></p><p><a href="https://imgse.com/i/pCNWxMT"><img src="https://s1.ax1x.com/2023/06/25/pCNWxMT.png" alt="pCNWxMT.png"></a></p><p>​    实际开发中，泛型改为你要转化的类型，回调方法是MyBatis框架会自动调用，只需要将其设置好就可以了</p><p>​    自定义类型转换器的实现</p><p>​    实现<code>BaseTypeHandler&lt;T&gt;</code>接口，并实现其对应的四个方法</p><p><a href="https://imgse.com/i/pCNjsLd"><img src="https://s1.ax1x.com/2023/06/25/pCNjsLd.png" alt="前两个方法"></a></p><p><a href="https://imgse.com/i/pCNj5Qg"><img src="https://s1.ax1x.com/2023/06/25/pCNj5Qg.png" alt="后两个方法"></a></p><p>​    在MyBatis核心配置文件中配置，把该类的全限定名进行配置</p><p><a href="https://imgse.com/i/pCNvlkt"><img src="https://s1.ax1x.com/2023/06/25/pCNvlkt.png" alt="pCNvlkt.png"></a></p><p>​    编写测试代码</p><p><a href="https://imgse.com/i/pCNvd7n"><img src="https://s1.ax1x.com/2023/06/25/pCNvd7n.png" alt="pCNvd7n.png"></a></p><h5 id="2-plugins标签-插件标签"><a href="#2-plugins标签-插件标签" class="headerlink" title="(2) plugins标签(插件标签)"></a>(2) plugins标签(插件标签)</h5><p><a href="https://imgse.com/i/pCNxn3T"><img src="https://s1.ax1x.com/2023/06/25/pCNxn3T.png" alt="pCNxn3T.png"></a></p><p>​    plugins标签的解析步骤</p><p>​    在pom.xml文件中导入pagehelper坐标和jsqlparser</p><p><a href="https://imgse.com/i/pCNx4bj"><img src="https://s1.ax1x.com/2023/06/25/pCNx4bj.png" alt="pCNx4bj.png"></a></p><p>​    在MyBatis核心配置文件中编写配置PageHelper插件</p><p><a href="https://imgse.com/i/pC0uvGt"><img src="https://s1.ax1x.com/2023/06/29/pC0uvGt.png" alt="pC0uvGt.png"></a></p><p>​    在数据库中进行分页查询时，不同的数据库系统可能有不同的方言（Dialect）来支持分页查询。以下是一些常见的数据库系统及其对应的方言：</p><ol><li>MySQL：MySQL 方言的分页查询可以使用 LIMIT 和 OFFSET 子句。通常的语法是 <code>LIMIT &lt;pageSize&gt; OFFSET &lt;offset&gt;</code>，其中 <code>&lt;pageSize&gt;</code> 是每页的记录数，<code>&lt;offset&gt;</code> 是偏移量（页数减一乘以每页记录数）。</li></ol><p>​    在测试代码中设置分页相关的参数，除了代码演示的还有很多，包括是否为第一页、是否为最后一页等</p><p><a href="https://imgse.com/i/pC0Qk3q"><img src="https://s1.ax1x.com/2023/06/29/pC0Qk3q.png" alt="pC0Qk3q.png"></a></p><h4 id="4-知识小结"><a href="#4-知识小结" class="headerlink" title="4. 知识小结"></a>4. 知识小结</h4><p><a href="https://imgse.com/i/pC0QmbF"><img src="https://s1.ax1x.com/2023/06/29/pC0QmbF.png" alt="pC0QmbF.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mabatis01</title>
      <link href="/2023/11/13/Mabatis01/"/>
      <url>/2023/11/13/Mabatis01/</url>
      
        <content type="html"><![CDATA[<h4 id="1-原始jdbc操作分析"><a href="#1-原始jdbc操作分析" class="headerlink" title="1. 原始jdbc操作分析"></a>1. 原始jdbc操作分析</h4><p>​    原始jdbc开发存在的问题如下：</p><p>​    1. 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能<br>​    2. sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码<br>​    3. 查询操作时，需要手动将结果集的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</p><p>​    应对上述问题给出的解决方案</p><p>​    1. 使用数据库连接池初始化连接资源<br>​    2. 将sql语句抽取到xml配置文件中<br>​    3. 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射    </p><h4 id="2-MyBatis简介"><a href="#2-MyBatis简介" class="headerlink" title="2. MyBatis简介"></a>2. MyBatis简介</h4><p>​    MyBatis就是实现上面解决方案的框架</p><p><a href="https://imgse.com/i/p907DEQ"><img src="https://s1.ax1x.com/2023/05/09/p907DEQ.png" alt="p907DEQ.png"></a></p><p>​    注意：持久层指的就是Dao层</p><h4 id="3-MyBatis传统开发步骤"><a href="#3-MyBatis传统开发步骤" class="headerlink" title="3. MyBatis传统开发步骤"></a>3. MyBatis传统开发步骤</h4><p>​    1. 添加MyBatis坐标<br>​    2. 创建user数据表，添加数据<br>​    3. 编写User实体类<br>​    4. 编写接口定义需要的方法(这个是我学到后面加的,因为MyBatis是动态代理的)<br>​    5. 编写映射文件UserMapper.xml，里面主要写sql语句<br>​    6. 编写核心文件SqlMapConfig.xml，里面主要是MyBatis框架的核心配置<br>​    7. 编写测试类</p><p>​    在pom.xml文件中引入坐标，主要是要引入jdbc驱动和MyBatis框架</p><p><a href="https://imgse.com/i/p90HdR1"><img src="https://s1.ax1x.com/2023/05/09/p90HdR1.png" alt="p90HdR1.png"></a></p><p>​    创建User数据库表</p><p><a href="https://imgse.com/i/p90HrqO"><img src="https://s1.ax1x.com/2023/05/09/p90HrqO.png" alt="p90HrqO.png"></a></p><p>​    创建数据库表对应的实体，生成get()、set()以及toString()方法</p><p><a href="https://imgse.com/i/p90H6de"><img src="https://s1.ax1x.com/2023/05/09/p90H6de.png" alt="p90H6de.png"></a></p><p>​    编写映射文件UserMapper.xml，在文件中需要引入约束头，这个约束头是官网可以找到的，下图中前两行为约束头；namespace为命名空间通过命名空间才能找到对应的sql语句；id为命名空间下对应的sql方法，resultType为对应实体表的映射，表示查询结果放在映射的实体类的对象中吗，namespace可以随意写。另外，如果没有在Idea和数据库连接，那么idea不会自动识别表信息则<code>user</code>会爆红</p><p><a href="https://imgse.com/i/p90bpeU"><img src="https://s1.ax1x.com/2023/05/09/p90bpeU.png" alt="p90bpeU.png"></a></p><p>​    编写核心文件，配置MyBatis框架，核心文件也有对应的约束头，下图前两行为约束头；default表示默认的数据源环境，将要默认的数据源的id作为属性值传入，<code>&lt;transactionManager type=&quot;&quot;&gt;</code>表示事务管理器要指定的类型；<code>&lt;dataSource type=&quot;&quot;&gt;</code>表示数据源的类型，内部为jdbc连接参数，核心文件中除了配置数据源环境还需要加载映射文件</p><p><a href="https://imgse.com/i/p90buwD"><img src="https://s1.ax1x.com/2023/05/09/p90buwD.png" alt="核心文件图1"></a></p><p><a href="https://imgse.com/i/p9B95y4"><img src="https://s1.ax1x.com/2023/05/09/p9B95y4.png" alt="核心文件图1"></a></p><p>​    新建一个java类编写测试代码</p><p><a href="https://imgse.com/i/p9BC44P"><img src="https://s1.ax1x.com/2023/05/09/p9BC44P.png" alt="p9BC44P.png"></a></p><h4 id="4-MyBatis映射文件概述"><a href="#4-MyBatis映射文件概述" class="headerlink" title="4. MyBatis映射文件概述"></a>4. MyBatis映射文件概述</h4><p><a href="https://imgse.com/i/p9B1lpF"><img src="https://s1.ax1x.com/2023/05/09/p9B1lpF.png" alt="p9B1lpF.png"></a></p><h4 id="5-MyBatis的代理开发方式-企业开发常用"><a href="#5-MyBatis的代理开发方式-企业开发常用" class="headerlink" title="5. MyBatis的代理开发方式(企业开发常用)"></a>5. MyBatis的代理开发方式(企业开发常用)</h4><h5 id="1-代理开发方式的要求"><a href="#1-代理开发方式的要求" class="headerlink" title="(1) 代理开发方式的要求"></a>(1) 代理开发方式的要求</h5><p><a href="https://imgse.com/i/pCQvj2t"><img src="https://s1.ax1x.com/2023/06/17/pCQvj2t.png" alt="要求1"></a></p><p>​    即如下图所示</p><p><a href="https://imgse.com/i/pCQxCVg"><img src="https://s1.ax1x.com/2023/06/17/pCQxCVg.png" alt="pCQxCVg.png"></a></p><p>​    <strong>注意：除了上述要求外，代理开发中xml文件和Mapper接口要放置在同一目录下</strong></p><p>​    <strong>(2)代理开发方式步骤</strong></p><p>​    编写xml文件和Dao的接口，按照上面四点配置一一对应</p><p><a href="https://imgse.com/i/pCQx8R1"><img src="https://s1.ax1x.com/2023/06/17/pCQx8R1.png" alt="pCQx8R1.png"></a></p><p><a href="https://imgse.com/i/pCQxtsK"><img src="https://s1.ax1x.com/2023/06/17/pCQxtsK.png" alt="pCQxtsK.png"></a></p><p>​    在service层中通过反射获取接口的对象，注意：与原先传统方式有别的是sqlSession对象调用的方法，且传统是在Dao的实现进行配置，而代理方式直接在service层进行相应配置，这个<strong>生成的mapper对象可以调用所有配置好的方法</strong></p><p><a href="https://imgse.com/i/pCQxDJA"><img src="https://s1.ax1x.com/2023/06/17/pCQxDJA.png" alt="pCQxDJA.png"></a></p><p>​    <strong>(3)代理开发的包扫描</strong></p><p>​    在代理开发中，核心配置文件的xml文件扫描可以替换为包扫描，这样可以简化开发</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--加载sql映射文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com/test/mapper/UserMapper.xml/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!--Mapper代理方式的包扫描--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com/test/mapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-MyBatis的核心配置文件中的标签"><a href="#6-MyBatis的核心配置文件中的标签" class="headerlink" title="6. MyBatis的核心配置文件中的标签"></a>6. MyBatis的核心配置文件中的标签</h4><h5 id="1-environments标签"><a href="#1-environments标签" class="headerlink" title="(1) environments标签"></a>(1) environments标签</h5><p>​    数据库环境的配置，支持多环境配置</p><p><a href="https://imgse.com/i/pCkg661"><img src="https://s1.ax1x.com/2023/06/08/pCkg661.png" alt="pCkg661.png"></a></p><p>​    注意：default的属性值给的是下面的id值，表示默认环境</p><p><a href="https://imgse.com/i/pCk22gs"><img src="https://s1.ax1x.com/2023/06/08/pCk22gs.png" alt="pCk22gs.png"></a></p><p>​    UNPOOLED表面于POOLED效果差不多，但是它的底层实现没有使用数据源连接池，而是使用传统的JDBC的获得请求，释放请求资源</p><h5 id="2-mapper标签"><a href="#2-mapper标签" class="headerlink" title="(2) mapper标签"></a>(2) mapper标签</h5><p>​    该标签的作用是加载映射的，加载方式有如下几种：</p><p><a href="https://imgse.com/i/pCkRxQs"><img src="https://s1.ax1x.com/2023/06/08/pCkRxQs.png" alt="pCkRxQs.png"></a></p><p>​    第三种是注释的方式，第四种是指扫包，意味着包下的全部实现注册为映射器，第一种是当前用的最多也是最重要的方式</p><h5 id="3-Properties标签"><a href="#3-Properties标签" class="headerlink" title="(3) Properties标签"></a>(3) Properties标签</h5><p>​    实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件</p><p>​    通过导入对应properties文件来解耦合</p><p><a href="https://imgse.com/i/pCZuiB6"><img src="https://s1.ax1x.com/2023/06/11/pCZuiB6.png" alt="pCZuiB6.png"></a></p><h5 id="4-typeAliases标签"><a href="#4-typeAliases标签" class="headerlink" title="(4) typeAliases标签"></a>(4) typeAliases标签</h5><p>​    通过typeAliases标签设置全限定名的别名</p><p><a href="https://imgse.com/i/pCZKCGQ"><img src="https://s1.ax1x.com/2023/06/11/pCZKCGQ.png" alt="pCZKCGQ.png"></a>    全限定名的使用场景</p><p><a href="https://imgse.com/i/pCZKixs"><img src="https://s1.ax1x.com/2023/06/11/pCZKixs.png" alt="pCZKixs.png"></a></p><p>​    使用别名后</p><p><a href="https://imgse.com/i/pCZKKG4"><img src="https://s1.ax1x.com/2023/06/11/pCZKKG4.png" alt="pCZKKG4.png"></a></p><p>​    注意：常用的类型MyBatis已经帮我们设置好了别名，下表数据类型没有写权限定名有些不够严谨，如下图所示</p><p><a href="https://imgse.com/i/pCZKILq"><img src="https://s1.ax1x.com/2023/06/11/pCZKILq.png" alt="pCZKILq.png"></a></p><h5 id="5-标签的顺序"><a href="#5-标签的顺序" class="headerlink" title="(5) 标签的顺序"></a>(5) 标签的顺序</h5><p>​    在MyBatis的xml配置文件中，标签应该按照如下顺序进行配置</p><p><a href="https://imgse.com/i/pCZK2FS"><img src="https://s1.ax1x.com/2023/06/11/pCZK2FS.png" alt="pCZK2FS.png"></a></p><h4 id="7-MyBatis相应API"><a href="#7-MyBatis相应API" class="headerlink" title="7. MyBatis相应API"></a>7. MyBatis相应API</h4><h5 id="1-SqlSession工厂构建器SqlSessionFactoryBuilder"><a href="#1-SqlSession工厂构建器SqlSessionFactoryBuilder" class="headerlink" title="(1) SqlSession工厂构建器SqlSessionFactoryBuilder"></a>(1) SqlSession工厂构建器SqlSessionFactoryBuilder</h5><p><a href="https://imgse.com/i/pCm1kp8"><img src="https://s1.ax1x.com/2023/06/13/pCm1kp8.png" alt="pCm1kp8.png"></a></p><h5 id="2-SqlSession工厂对象SqlSessionFactory"><a href="#2-SqlSession工厂对象SqlSessionFactory" class="headerlink" title="(2) SqlSession工厂对象SqlSessionFactory"></a>(2) SqlSession工厂对象SqlSessionFactory</h5><p><a href="https://imgse.com/i/pCm1gHA"><img src="https://s1.ax1x.com/2023/06/13/pCm1gHA.png" alt="pCm1gHA.png"></a></p><p>​    注意：只有增删改操作会用到这个事物操作</p><h5 id="3-SqlSession会话对象"><a href="#3-SqlSession会话对象" class="headerlink" title="(3) SqlSession会话对象"></a>(3) SqlSession会话对象</h5><p>​    第一个API是指查询一个对象(返回值是泛型)，后四个为查增改删操作</p><p>​    注意：第一个参数是MyBatis的xml文件所定义的方法，第二个参数是xml文件中所定义的方法要的参数</p><p><a href="https://imgse.com/i/pCm3Pb9"><img src="https://s1.ax1x.com/2023/06/13/pCm3Pb9.png" alt="pCm3Pb9.png"></a></p><p>​    后两个方法是事务的操作</p><p>​    注意：后面学习Spring框架后，事务交给Spring完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构08</title>
      <link href="/2023/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8408/"/>
      <url>/2023/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8408/</url>
      
        <content type="html"><![CDATA[<h2 id="查找和排序"><a href="#查找和排序" class="headerlink" title="查找和排序"></a>查找和排序</h2><h4 id="1-查找和排序的关系"><a href="#1-查找和排序的关系" class="headerlink" title="1. 查找和排序的关系"></a>1. 查找和排序的关系</h4><p>​    排序是查找的前提，排序是重点</p><h4 id="2-排序的稳定性"><a href="#2-排序的稳定性" class="headerlink" title="2. 排序的稳定性"></a>2. 排序的稳定性</h4><p>​    当两个元素值是一样的设定为A和B，A在B的前面，在排完序之后A依然在B的前面则称排序是稳定的，否则排序是不稳定的</p><h4 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h4><ul><li><p>冒泡</p></li><li><p>插入</p><p>从两个元素开始，按照规定插入，保证这两个有序，然后插入第三个元素并保证这三个元素有序，依次类推</p></li><li><p>选择</p><p>以升序为例，在所有的元素中筛选出最小的，然后与序列中第一个元素交换位置，再从剩余元素中找出最小的与序列的第二个元素交换位置，依次类推</p></li><li><p>快速排序</p></li><li><p>归并排序</p><p>两个两个有序，四个四个有序，最后整体有序</p></li></ul><h4 id="4-选择排序的算法实现-直接选择排序"><a href="#4-选择排序的算法实现-直接选择排序" class="headerlink" title="4. 选择排序的算法实现-直接选择排序"></a>4. 选择排序的算法实现-直接选择排序</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//直接选择排序</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>min<span class="token punctuation">,</span>t<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//选出最小元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>min<span class="token operator">=</span>i <span class="token punctuation">,</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">;</span> j<span class="token operator">&lt;</span>len <span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                min <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//将最小的值与前排元素交换位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">6</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h4><p>​    先找到某一个元素的排好序的确切位置，一般假定是第一个元素，把数据变为两半，然后在这两半数据中再重复之前动作，直到完全排好序</p><p>​    快速排序细节上也分为很多种，但整体思路是一样的</p><p>​    当前讲解一种的伪算法</p><p>​    假设升序排序，首先定义两个指针(L、H)分别指向首元素和末尾元素，将首元素的值保存在临时变量(val)中。</p><p>​    先移动h，将h指的值与val里的值作比较，如果h所指的值比val的小，则将h所指的值赋给L所指的值，若比val大则继续移动h；值发生交换则开始移动L，L所指的值与val作比较，如果比val小则继续移动L，如果比val大，则将L所指的指赋给H所指的值，值发生交换则开始移动H；以此类推，最后当L与H相交时，将val赋值给两个指针所指向的节点，以该节点作为分界在分别对截成的两个数组的前后进行快速排序</p><p><a href="https://imgse.com/i/p9xnifH"><img src="https://s1.ax1x.com/2023/05/31/p9xnifH.png" alt="第一轮快速排序后的数组元素顺序"></a></p><p>​    范例：快速排序算法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//递归调用快速排序</span><span class="token keyword">void</span> <span class="token function">Quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">findnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> low <span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>high<span class="token operator">></span>low<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">findnum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Quicksort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>low<span class="token punctuation">,</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Quicksort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//找出第一个元素完全排好序后应该放在的位置，在该位置放置该元素，并将该位置返回</span><span class="token keyword">int</span> <span class="token function">findnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>high<span class="token operator">></span>low<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>high<span class="token operator">></span>low<span class="token operator">&amp;&amp;</span>tmp<span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            high<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>high<span class="token operator">></span>low<span class="token operator">&amp;&amp;</span>tmp<span class="token operator">>=</span>a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">Quicksort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">6</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-全课总结"><a href="#6-全课总结" class="headerlink" title="6. 全课总结"></a>6. 全课总结</h4><p>​    <strong>再次讨论什么是数据结构？</strong></p><p>​    答：数据结构是研究数据的存储和数据操作的一门学问</p><p>​    <strong>数据的存储分为哪两个部分？</strong></p><p>​    答：个体的存储</p><p>​            个体关系的存储</p><p>​            从某个角度而言，数据的存储最核心的就是个体关系的存储，个体的存储可以忽略不计</p><p>​    <strong>再次讨论什么是泛型</strong></p><p>​    答：同一种逻辑结构，无论该逻辑结构物理存储是什么样子的，我们可以对它执行相同的操作</p><h4 id="7-未来展望"><a href="#7-未来展望" class="headerlink" title="7. 未来展望"></a>7. 未来展望</h4><p>​    学习图，如深度遍历，广度遍历</p><p>​    学习哈希表</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring07</title>
      <link href="/2023/05/31/Spring07/"/>
      <url>/2023/05/31/Spring07/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的事务控制"><a href="#Spring的事务控制" class="headerlink" title="Spring的事务控制"></a>Spring的事务控制</h2><h4 id="1-编程式事务控制三大对象"><a href="#1-编程式事务控制三大对象" class="headerlink" title="1. 编程式事务控制三大对象"></a>1. 编程式事务控制三大对象</h4><p><strong>(1). PlatformTransactionManager(平台事务管理器)</strong></p><p>​    PlatformTransactionManager接口是Spring的事务管理器，它里面提供了我们常用的操作事务的方法</p><p><a href="https://imgse.com/i/p9dvSyt"><img src="https://s1.ax1x.com/2023/05/07/p9dvSyt.png" alt="p9dvSyt.png"></a></p><p>​    注意：PlatformTransactionManager是接口类型，不同的Dao层技术有不同的事项类，如Dao层技术是jdbc或mybatis时为：<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>，Dao层技术是hibernate时为：<code>org.springframework.orm.hibernate5.HibernateTransactionManager</code></p><p><strong>(2). TransactionDefinition(事务定义对象)</strong></p><p>​    它里面有如下方法</p><p><a href="https://imgse.com/i/p9dxKgA"><img src="https://s1.ax1x.com/2023/05/07/p9dxKgA.png" alt="p9dxKgA.png"></a></p><p>​    这个里面的api不重要，<strong>重要的是明白对象是封装一些事物相关参数</strong></p><p>​    事务的隔离级别</p><p><a href="https://imgse.com/i/p9dxBD0"><img src="https://s1.ax1x.com/2023/05/07/p9dxBD0.png" alt="p9dxBD0.png"></a></p><p>​    事务的传播行为</p><p><a href="https://imgse.com/i/p9wz9tU"><img src="https://s1.ax1x.com/2023/05/08/p9wz9tU.png" alt="p9wz9tU.png"></a></p><p><strong>(3). TransactionStatus(事物的状态对象)</strong></p><p>​    TransactionStatus接口提供的是事物具体的运行状态，方法介绍如下(api不重要，了解即可)</p><p><a href="https://imgse.com/i/p9wzTD1"><img src="https://s1.ax1x.com/2023/05/08/p9wzTD1.png" alt="p9wzTD1.png"></a></p><p>​    注意：事物的状态是被动信息不是主动设置的</p><p><strong>(4). 三者的关系</strong></p><p>​    平台事务管理器：控制事物行为，需要通过配置方式指定</p><p>​    事务定义对象：维护事物的参数信息，需要通过配置方式指定</p><p>​    事物的状态对象：在事物运行的过程中封装状态信息，被动的产生</p><p>​    平台事务管理器+事务定义对象=事物的状态对象</p><h4 id="2-基于XML的声明式事务控制"><a href="#2-基于XML的声明式事务控制" class="headerlink" title="2. 基于XML的声明式事务控制"></a>2. 基于XML的声明式事务控制</h4><p><strong>(1).什么是声明式事务控制</strong></p><p><a href="https://imgse.com/i/p90SHMj"><img src="https://s1.ax1x.com/2023/05/08/p90SHMj.png" alt="p90SHMj.png"></a></p><p>​    注意：Spring对于声明式事务控制的底层实现是AOP</p><p><strong>(2).声明式事务的实现</strong></p><p>​    声明式事务控制明确事项：</p><ul><li>谁是切点：就是业务方法(在service层)</li><li>谁是通知：就是事务控制</li><li>配置切面：增强和切点配置</li></ul><p>​    基础三个层，controller层执行方法提交，service层编写业务方法，Dao层编写底层jdbc方法</p><p>​    controller层</p><p><a href="https://imgse.com/i/p909KhT"><img src="https://s1.ax1x.com/2023/05/08/p909KhT.png" alt="p909KhT.png"></a></p><p>​    service层</p><p><a href="https://imgse.com/i/p909Vns"><img src="https://s1.ax1x.com/2023/05/08/p909Vns.png" alt="p909Vns.png"></a></p><p>​    Dao层</p><p><a href="https://imgse.com/i/p909Ch8"><img src="https://s1.ax1x.com/2023/05/08/p909Ch8.png" alt="p909Ch8.png"></a></p><p>​    上述三层的业务逻辑为，A账户向B账户转钱，A账户-500，B账户+500，问题在于service层如果执行完accountDao.out()方法后被异常中断，会导致A账户减少了钱，但B账户没有增加钱</p><p>​    <strong>通过声明式事务改进上面业务</strong></p><p>​    对于事务的增强，需要引入对应的命名空间<code>tx</code>，pom.xml文件中也需要引入</p><p><a href="https://imgse.com/i/p90903D"><img src="https://s1.ax1x.com/2023/05/08/p90903D.png" alt="p90903D.png"></a></p><p><a href="https://imgse.com/i/p9092UP"><img src="https://s1.ax1x.com/2023/05/08/p9092UP.png" alt="p9092UP.png"></a></p><p>​        在xml文件中，将service层作为目标对象，内部的那个业务方法作为切点。在平台事务管理器中注入了dataSource为数据源对象。在配置事务通知中，<code>transaction-manager=&quot;&quot;</code>属性值为平台事务管理器。配置事务的织入中，<code>&lt;aop:advisor&gt;</code>表示为aop对事物织入，其中<code>advice-ref</code>为通知引用</p><p><a href="https://imgse.com/i/p90P2p8"><img src="https://s1.ax1x.com/2023/05/08/p90P2p8.png" alt="p90P2p8.png"></a></p><p><a href="https://imgse.com/i/p90CqLd"><img src="https://s1.ax1x.com/2023/05/08/p90CqLd.png" alt="p90CqLd.png"></a></p><p>​    注意：织入方式也可以抽取切点表达式</p><p>​    <code>&lt;tx:attributes&gt;</code>表示定义事务的属性信息，<code>&lt;tx:method&gt;</code>可以配置多个，其中<code>name</code>属性表示哪些方法被增强，<code>*</code>表示任意方法，其还有其他属性，详细看TransactionDefinition(事务定义对象)这一小节</p><p>​    详细写全后的代码，name表示切点方法名称，isolation表示事务的隔离级别，propagation表示事务的传播行为，timeout表示超时时间，read-only表示是否只读</p><p><a href="https://imgse.com/i/p90iyDJ"><img src="https://s1.ax1x.com/2023/05/08/p90iyDJ.png" alt="p90iyDJ.png"></a></p><h4 id="3-基于注解的声明式事务控制"><a href="#3-基于注解的声明式事务控制" class="headerlink" title="3. 基于注解的声明式事务控制"></a>3. 基于注解的声明式事务控制</h4><p>​    对上面业务使用注解方式配置</p><p>​    dao层代码</p><p><a href="https://imgse.com/i/p90AK41"><img src="https://s1.ax1x.com/2023/05/08/p90AK41.png" alt="p90AK41.png"></a></p><p>​    service层代码，<code>@Transactional</code>注解写在方法前表示对当前方法增加事务，写在类前表示对类中所有方法增加事务，该注解编译时遵循就近原则，该注解可以配置例如隔离级别、传播行为等</p><p><a href="https://imgse.com/i/p90A42V"><img src="https://s1.ax1x.com/2023/05/08/p90A42V.png" alt="p90A42V.png"></a></p><p>​    在xml文件中配置组件扫描</p><p><a href="https://imgse.com/i/p90AGuD"><img src="https://s1.ax1x.com/2023/05/08/p90AGuD.png" alt="p90AGuD.png"></a></p><p>​    不能被注解代替的xml配置以及在xml文件中配置注解驱动</p><p><a href="https://imgse.com/i/p90P2p8"><img src="https://s1.ax1x.com/2023/05/08/p90P2p8.png" alt="p90P2p8.png"></a></p><p><a href="https://imgse.com/i/p90Ah80"><img src="https://s1.ax1x.com/2023/05/08/p90Ah80.png" alt="p90Ah80.png"></a></p><p>​    controller层测试</p><p><a href="https://imgse.com/i/p90ATrF"><img src="https://s1.ax1x.com/2023/05/08/p90ATrF.png" alt="p90ATrF.png"></a></p><p>​    总结</p><p><a href="https://imgse.com/i/p90EPVH"><img src="https://s1.ax1x.com/2023/05/08/p90EPVH.png" alt="p90EPVH.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring06</title>
      <link href="/2023/05/31/Spring06/"/>
      <url>/2023/05/31/Spring06/</url>
      
        <content type="html"><![CDATA[<h4 id="1-SpringAOP的入门"><a href="#1-SpringAOP的入门" class="headerlink" title="1. SpringAOP的入门"></a>1. SpringAOP的入门</h4><p><strong>SpringAOP的简介</strong></p><p><a href="https://imgse.com/i/p9GSeds"><img src="https://s1.ax1x.com/2023/05/01/p9GSeds.png" alt="p9GSeds.png"></a></p><p><a href="https://imgse.com/i/p9GS1QU"><img src="https://s1.ax1x.com/2023/05/01/p9GS1QU.png" alt="p9GS1QU.png"></a></p><p>​    你可以理解为，一个项目A功能要和B、C、D三个功能结合形成三个不同的功能，传统OOP哪怕封装也需要进行调用，而AOP则是写好A功能放那就行，通过配置的方式使用A功能，<strong>即这4个功能相互独立，在运行时(内存中)通过配置指定结合，A功能可以看作一个增强，A和B功能通过配置方式结合组合的功能叫做切面</strong></p><p><strong>AOP的作用及其优势</strong></p><ul><li>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</li><li>优势：减少重复代码，提高开发效率，并且便于维护</li></ul><p><strong>AOP的底层实现</strong></p><p><a href="https://imgse.com/i/p9GpwAs"><img src="https://s1.ax1x.com/2023/05/01/p9GpwAs.png" alt="p9GpwAs.png"></a></p><p><strong>SpringAOP的动态代理技术</strong></p><ul><li>JDK代理：基于接口的动态代理技术</li><li>cglib代理：基于父类的动态代理技术</li></ul><p><a href="https://imgse.com/i/p9GpfE9"><img src="https://s1.ax1x.com/2023/05/01/p9GpfE9.png" alt="p9GpfE9.png"></a></p><p><strong>JDK代理</strong></p><p>​    上一个blog有详细代码，这里略</p><p><strong>cglib代理</strong></p><p>​    在导入的<code>Spring-conntext</code>中已经集成了cglib的坐标，不需要额外导包</p><p>​    基于cglib生成代理对象的步骤</p><pre><code>1. 创建增强器 2. 设置父类 3. 设置回调 4. 创建代理对象</code></pre><p>​    cglib的代码演示，Target是目标对象，Advice是添加功能的对象里面有要添加的方法，内部的intercept方法类似invoke方法其中methodProxy形参不用管</p><p><a href="https://imgse.com/i/p9NNBuR"><img src="https://s1.ax1x.com/2023/05/05/p9NNBuR.png" alt="p9NNBuR.png"></a></p><p><a href="https://imgse.com/i/p9NNPcd"><img src="https://s1.ax1x.com/2023/05/05/p9NNPcd.png" alt="p9NNPcd.png"></a></p><h4 id="2-AOP相关概念"><a href="#2-AOP相关概念" class="headerlink" title="2. AOP相关概念"></a>2. AOP相关概念</h4><p>​    <strong>AOP的相关术语</strong></p><ul><li>Target(目标对象)：代理的目标对象</li><li>Proxy(代理)：一个类被AOP植入增强后产生的一个结果代理类</li><li>Joinpoint(连接点)：所谓连接点是指那些被拦截到的点(方法)。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点，<strong>可以被增强的方法叫做连接点</strong></li><li><strong>Pointcut(切入点)**：切入点是指我们要对哪些Joipoint进行拦截的定义，</strong>连接点真正要被增强了叫做切入点**</li><li><strong>Advice(通知/增强)**：通知是指拦截到Joinpoint之后所要做的事情就是通知，</strong>将连接点和一些功能结合的方法叫做增强**</li><li>**Aspect(切面)**：是切入点和通知(引介)的结合</li><li>Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而Aspect采用编译期织入和类装载期织入，<strong>切入点和通知结合的过程</strong></li></ul><h4 id="3-AOP开发明确的事项"><a href="#3-AOP开发明确的事项" class="headerlink" title="3. AOP开发明确的事项"></a>3. AOP开发明确的事项</h4><p><a href="https://imgse.com/i/p9NgXkQ"><img src="https://s1.ax1x.com/2023/05/05/p9NgXkQ.png" alt="p9NgXkQ.png"></a></p><h4 id="4-基于XML的AOP开发"><a href="#4-基于XML的AOP开发" class="headerlink" title="4. 基于XML的AOP开发"></a>4. 基于XML的AOP开发</h4><p> <strong>(1)基于XML的AOP开发的步骤</strong></p><ol><li>导入AOP相关坐标</li><li>创建目标接口和目标类(内部有切点)</li><li>创建切面类(内部有增强方法)</li><li>将目标类和切面类的对象创建权交给spring</li><li>在<code>applicationContext.xml</code>中配置织入关系</li><li>测试代码</li></ol><p>​    在pom.xml导入spring-context和aspectjweaver坐标，spring本身有aop的实现，第三方aspectj也有且很优秀，spring官方主张使用aspectj</p><p><a href="https://imgse.com/i/p9NhHIO"><img src="https://s1.ax1x.com/2023/05/05/p9NhHIO.png" alt="p9NhHIO.png"></a></p><p>​    创建目标接口和目标类，下图只有目标类</p><p><a href="https://imgse.com/i/p9N5Pn1"><img src="https://s1.ax1x.com/2023/05/05/p9N5Pn1.png" alt="p9N5Pn1.png"></a></p><p>​    创建切面类</p><p><a href="https://imgse.com/i/p9N4sld"><img src="https://s1.ax1x.com/2023/05/05/p9N4sld.png" alt="p9N4sld.png"></a></p><p>​    创建xml文件完成配置，将目标对象和切面对象交给Spring管理，并在xml文件中告诉Spring框架哪些切点需要被增强。<strong>注意：aop需要引入命名空间</strong>。其中，<code>aop:before</code>表示在切点之前执行<code>mehod=&quot;&quot;</code>方法，pointcut里面配置的是切点表达式里面的方法是要被增强的方法</p><p>​    <code>&lt;aop:config&gt;</code>：表示aop的配置</p><p>​    <code>&lt;aop:aspect ref=&quot;myAspect&quot;&gt;</code>：指定切面是谁</p><p>​    <code>&lt;aop:before&gt;</code>：表示增强(通知)的类型</p><p>​    <code>method=&quot;before&quot;&gt;</code>：表示前置增强要执行的方法的名字是什么，即切面myAspect内部的before方法</p><p>​    <code>pointcup=&quot;execution(public void com.itheima.aop.Target.save())&quot;</code>：表示切点表达式，<strong>可以通过切点表达式指定多个方法，见下面详解</strong></p><p><a href="https://imgse.com/i/p9NHU0A"><img src="https://s1.ax1x.com/2023/05/05/p9NHU0A.png" alt="p9NHU0A.png"></a></p><p><a href="https://imgse.com/i/p9NHkWT"><img src="https://s1.ax1x.com/2023/05/05/p9NHkWT.png" alt="p9NHkWT.png"></a></p><p>​    测试代码，在pom.xml配置</p><p><a href="https://imgse.com/i/p9NbQBj"><img src="https://s1.ax1x.com/2023/05/05/p9NbQBj.png" alt="p9NbQBj.png"></a></p><p>​    编写测试代码</p><p><a href="https://imgse.com/i/p9NbUvF"><img src="https://s1.ax1x.com/2023/05/05/p9NbUvF.png" alt="p9NbUvF.png"></a></p><p>​    运行结果</p><p><a href="https://imgse.com/i/p9NbDER"><img src="https://s1.ax1x.com/2023/05/05/p9NbDER.png" alt="p9NbDER.png"></a></p><p> <strong>(2)切点表达式的写法</strong></p><p>​    表达式语法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//execution是关键字</span><span class="token function">execution</span><span class="token punctuation">(</span><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 方法返回值类型 包名<span class="token punctuation">.</span>类名<span class="token punctuation">.</span>方法名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>访问修饰符可以省略</li><li>返回值类型、包名、类名、方法名可以使用星号<code>*</code>代表任意</li><li>包名与类名之间一个点<code>.</code>代表当前包下的类，两个点<code>..</code>表示当前包及该包子包下的类</li><li>参数列表可以使用两个点<code>..</code>表示任意个数、任意类型的参数列表</li></ul><p>​    最常用的形式：表示aop包下的任意类的任意方法任意参数任意返回值</p><p><a href="https://imgse.com/i/p9UOiee"><img src="https://s1.ax1x.com/2023/05/06/p9UOiee.png" alt="p9UOiee.png"></a></p><p> <strong>(3)通知的种类</strong></p><p>​    通知的配置语法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span>aop<span class="token operator">:</span>通知类型 method<span class="token operator">=</span><span class="token string">"切面类中方法名"</span> pointcut<span class="token operator">=</span><span class="token string">"切点表达式"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>aop<span class="token operator">:</span>通知类型<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    通知的类型</p><p><a href="https://imgse.com/i/p9UOtS0"><img src="https://s1.ax1x.com/2023/05/06/p9UOtS0.png" alt="p9UOtS0.png"></a></p><p>​    <strong>注意：除环绕通知外其余的都比较简单，不需要传特定参数，直接使用就行</strong></p><p>​    环绕通知</p><p>​    因为无法区分里面的方法是在之前执行还是之后执行，所以在编写环绕通知的方法时要给一个参数类型<code>ProceedingJoinPoint pjp</code>该参数表示切点，通过<code>pjp.proceed()</code>方法区分在其前面执行的方法在切点前执行，在其后执行的方法在切点后执行</p><p>​    在MyAspect.java中编写环绕通知的方法</p><p><a href="https://imgse.com/i/p9UXobF"><img src="https://s1.ax1x.com/2023/05/06/p9UXobF.png" alt="p9UXobF.png"></a></p><p> <strong>(4)切点表达式的抽取</strong></p><p><a href="https://imgse.com/i/p9UjM5j"><img src="https://s1.ax1x.com/2023/05/06/p9UjM5j.png" alt="p9UjM5j.png"></a></p><p>​    对之前代码进行抽取</p><p><a href="https://imgse.com/i/p9Uj32q"><img src="https://s1.ax1x.com/2023/05/06/p9Uj32q.png" alt="p9Uj32q.png"></a></p><p> <strong>(5)知识要点总结</strong></p><p><a href="https://imgse.com/i/p9Ujrxx"><img src="https://s1.ax1x.com/2023/05/06/p9Ujrxx.png" alt="p9Ujrxx.png"></a></p><h4 id="5-基于注解的AOP开发"><a href="#5-基于注解的AOP开发" class="headerlink" title="5. 基于注解的AOP开发"></a>5. 基于注解的AOP开发</h4><p><strong>(1)基于注解的aop开发步骤</strong></p><p><a href="https://imgse.com/i/p9ar2nO"><img src="https://s1.ax1x.com/2023/05/06/p9ar2nO.png" alt="p9ar2nO.png"></a></p><p>​    编写目标类，接口略</p><p><a href="https://imgse.com/i/p9aRBq0"><img src="https://s1.ax1x.com/2023/05/06/p9aRBq0.png" alt="p9aRBq0.png"></a></p><p>​    编写切面类</p><p><a href="https://imgse.com/i/p9aWaFO"><img src="https://s1.ax1x.com/2023/05/06/p9aWaFO.png" alt="p9aWaFO.png"></a></p><p>​    编写xml配置</p><p><a href="https://imgse.com/i/p9aWx1J"><img src="https://s1.ax1x.com/2023/05/06/p9aWx1J.png" alt="p9aWx1J.png"></a></p><p>​    编写测试类</p><p><a href="https://imgse.com/i/p9af34S"><img src="https://s1.ax1x.com/2023/05/06/p9af34S.png" alt="p9af34S.png"></a></p><p><strong>(2)注解通知的类型</strong></p><p>​    通知配置的语法：<code>@通知注解(&quot;切点表达式&quot;)</code></p><p>​    注解通知的类型</p><p><a href="https://imgse.com/i/p9af2uR"><img src="https://s1.ax1x.com/2023/05/06/p9af2uR.png" alt="p9af2uR.png"></a></p><p>​    注意：注解只是替代原先xml文件的配置，但是需要的方法还是要有的，例如环绕配置如下</p><p><a href="https://imgse.com/i/p9afoCD"><img src="https://s1.ax1x.com/2023/05/06/p9afoCD.png" alt="p9afoCD.png"></a></p><p><strong>(3)切点表达式的抽取</strong></p><p><a href="https://imgse.com/i/p9ahFrn"><img src="https://s1.ax1x.com/2023/05/06/p9ahFrn.png" alt="p9ahFrn.png"></a></p><p><strong>(4)注解开发aop的小结</strong></p><p><a href="https://imgse.com/i/p9ahaxH"><img src="https://s1.ax1x.com/2023/05/06/p9ahaxH.png" alt="p9ahaxH.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构07</title>
      <link href="/2023/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8407/"/>
      <url>/2023/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8407/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h4 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1. 树的定义"></a>1. 树的定义</h4><p>​    <strong>专业的定义：</strong></p><p>​    1. 有且只有一个称为根的节点<br>​    2. 有若干个互不相交的子树，这些子树本身也是一颗树</p><p>​    <strong>通俗的定义：</strong></p><p>​    1. 树是由节点和边(指针)组成<br>​    2. 每个节点只有一个父节点但可以有多个子节点<br>​    3. 但有一个节点例外，该节点没有父节点，此节点称为根节点</p><h4 id="2-树的专业术语"><a href="#2-树的专业术语" class="headerlink" title="2. 树的专业术语"></a>2. 树的专业术语</h4><ul><li>节点：树的节点由数据元素及其若干分支组成</li><li>父节点：节点上面紧挨着的节点</li><li>子节点：父节点下面一层的节点</li><li>兄弟：父节点下的所有子结点互为兄弟结点</li><li>子孙：以某节点为根的子树中的任一节点</li><li>深度：从根节点到最底层节点的层数，根节点是第一层</li><li>叶子节点：没有子节点的节点</li><li>非终端节点：非叶子节点</li><li>度：子节点的个数</li></ul><p>​    </p><h4 id="3-树的分类"><a href="#3-树的分类" class="headerlink" title="3. 树的分类"></a>3. 树的分类</h4><ul><li><p>一般树</p><p>任意一个节点的子节点的个数都不受限制</p></li><li><p>二叉树</p><p>任意一个节点的子节点的个数最多两个，且子节点的位置不可更改</p></li><li><p>森林</p><p>n个互不相交的树的集合</p></li></ul><h4 id="4-二叉树的分类"><a href="#4-二叉树的分类" class="headerlink" title="4. 二叉树的分类"></a>4. 二叉树的分类</h4><ul><li><p>一般二叉树</p></li><li><p>满二叉树</p><p>在不增加树的层数的情况下，无法再多添加一个节点的二叉树</p></li><li><p>完全二叉树</p><p>如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树</p></li></ul><h4 id="5-树的存储"><a href="#5-树的存储" class="headerlink" title="5. 树的存储"></a>5. 树的存储</h4><h5 id="1-二叉树的存储-比较成熟"><a href="#1-二叉树的存储-比较成熟" class="headerlink" title="(1) 二叉树的存储(比较成熟)"></a>(1) 二叉树的存储(比较成熟)</h5><p>​    <strong>连续存储[必须是完全二叉树]</strong></p><p>​    优点：查找某个节点的父节点和子节点(也包括判断有没有子节点)速度很快，时间复杂度O(1)</p><p>​    缺点：耗用内存空间过大</p><p>​    当二叉树不是完全的时候需要去补全，先转换为满二叉树再转化为完全二叉树，如下图所示，蓝色为补全节点，黄框可以不补全</p><p><a href="https://imgse.com/i/p9IHXcR"><img src="https://s1.ax1x.com/2023/05/22/p9IHXcR.png" alt="图5.1 二叉树补全"></a></p><p>​    存蓝点的原因是方便还原树的形状</p><p>​    通过先序、中序、后序可以将树从非线性结构转换为线性结构，使用数组存储时，不可以 只存储有效节点，因为只通过先序、中序、后序的任一一种无法还原原先的二叉树</p><p>​    <strong>链式存储(不是链表存)</strong></p><p>​    每一个节点分成三个部分，左右存指针，中间存数据</p><p><a href="https://imgse.com/i/p9oSKUI"><img src="https://s1.ax1x.com/2023/05/22/p9oSKUI.png" alt="图5.2 链式存储树的方式"></a></p><p>​    内存浪费：空指针浪费n+1个</p><p>​    找父节点也很困难</p><h5 id="2-一般树的存储方法"><a href="#2-一般树的存储方法" class="headerlink" title="(2) 一般树的存储方法"></a>(2) 一般树的存储方法</h5><ol><li><p>双亲表示法</p><p>使用数组的方式进行存储，一个存储块分为两个区域，一个区域存节点名，另一个区域存父节点所在的数组元素的下标</p><p><strong>双亲表示法求父节点方便</strong></p><p><a href="https://imgse.com/i/p9TKczF"><img src="https://s1.ax1x.com/2023/05/23/p9TKczF.png" alt="p9TKczF.png"></a></p><p><a href="https://imgse.com/i/p9TKBaq"><img src="https://s1.ax1x.com/2023/05/23/p9TKBaq.png" alt="双亲表示法"></a></p></li><li><p>孩子表示法</p><p>使用数组的方式进行存储，也是分成两个区域，一个区域存节点，另一个区域是链表存指针依次指向其子节点</p><p><strong>孩子表示法求子节点方便</strong></p><p><a href="https://imgse.com/i/p9TJNbF"><img src="https://s1.ax1x.com/2023/05/23/p9TJNbF.png" alt="左边为树，右边是表示方法"></a></p></li><li><p>孩子双亲表示法</p><p>把上面两种方法结合在一起，在数组中存放三个域</p><p><strong>求父节点和子节点都很方便</strong></p><p><a href="https://imgse.com/i/p9TJI2t"><img src="https://s1.ax1x.com/2023/05/23/p9TJI2t.png" alt="p9TJI2t.png"></a></p></li><li><p>二叉树表示法</p><p>因为在实现过程中对于孩子双亲表示法不方便，所以使用了二叉树表示法，<strong>二叉树方便使用代码来表示</strong>，详细见第6大节</p></li></ol><h5 id="3-森林的存储"><a href="#3-森林的存储" class="headerlink" title="(3) 森林的存储"></a>(3) 森林的存储</h5><p>​    一般是把森林转化为二叉树再进行存储</p><p>​    把森林中每一个树的根节点当作兄弟节点，然后像一般树转化为二叉树那样将森林转换为二叉树</p><p><a href="https://imgse.com/i/p97CHeS"><img src="https://s1.ax1x.com/2023/05/24/p97CHeS.png" alt="森林转化为二叉树"></a></p><h4 id="6-普通树的二叉树表示法"><a href="#6-普通树的二叉树表示法" class="headerlink" title="6. 普通树的二叉树表示法"></a>6. 普通树的二叉树表示法</h4><p>​    把一个普通树转化成二叉树来存储</p><p>​    <strong>转换方法：设法保证任意一个节点的左指针域指向它的第一个孩子，右指针域指向它的兄弟节点，只要能满足此条件，就可以把一个普通树转化为二叉树</strong></p><p><a href="https://imgse.com/i/p9TYbS1"><img src="https://s1.ax1x.com/2023/05/23/p9TYbS1.png" alt="普通树转化为二叉树图示"></a></p><p>​    一个普通树转化成的二叉树一定没有右子树</p><h4 id="7-二叉树的操作"><a href="#7-二叉树的操作" class="headerlink" title="7. 二叉树的操作"></a>7. 二叉树的操作</h4><p>​    1. 遍历，先中后的遍历都是指二叉树的遍历<br>​    2. 已知两种遍历序列求原始二叉树</p><p>​        <strong>通过先中或中后遍历序列可以还原二叉树</strong>，但先后不能还原出原始二叉树</p><p>​    <strong>注意：遍历时当访问到根节点时将该节点记录</strong></p><h5 id="1-二叉树的先序遍历"><a href="#1-二叉树的先序遍历" class="headerlink" title="(1). 二叉树的先序遍历"></a>(1). 二叉树的先序遍历</h5><p>​    <strong>先序遍历[先访问根节点]</strong></p><p>​    递归的进行(先访问树的根节点，再访问左子树，再访问右子树)</p><p><a href="https://imgse.com/i/p9bvb4A"><img src="https://s1.ax1x.com/2023/05/26/p9bvb4A.png" alt="p9bvb4A.png"></a></p><h5 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="(2). 二叉树的中序遍历"></a>(2). 二叉树的中序遍历</h5><p>​    <strong>中序遍历[中间访问根节点]</strong></p><p>​    递归的进行(先遍历树的左子树，再访问根节点，再遍历右子树)</p><p><a href="https://imgse.com/i/p9qSLC9"><img src="https://s1.ax1x.com/2023/05/26/p9qSLC9.png" alt="p9qSLC9.png"></a></p><h5 id="3-二叉树的后序遍历"><a href="#3-二叉树的后序遍历" class="headerlink" title="(3). 二叉树的后序遍历"></a>(3). 二叉树的后序遍历</h5><p>​    <strong>后序遍历[最后访问根节点]</strong></p><p>​    递归的进行(先遍历树的左子树，再遍历右子树，再访问根节点)</p><p><a href="https://imgse.com/i/p9qPRaT"><img src="https://s1.ax1x.com/2023/05/26/p9qPRaT.png" alt="p9qPRaT.png"></a></p><h5 id="4-已知先序和中序求后序"><a href="#4-已知先序和中序求后序" class="headerlink" title="(4). 已知先序和中序求后序"></a>(4). 已知先序和中序求后序</h5><p>​    首先使用先序和中序将二叉树求出来，然后再通过二叉树求出后序</p><p>​    使用先序确定节点顺序(找每个子树的根节点)，中序确定是左子树还是右子树</p><p><a href="https://imgse.com/i/p9X15FS"><img src="https://s1.ax1x.com/2023/05/29/p9X15FS.png" alt="由先序和中序得出原始二叉树"></a></p><p>​    从树可以得出后序为：DECBHGFA</p><h5 id="5-已知中序和后序求先序"><a href="#5-已知中序和后序求先序" class="headerlink" title="(5). 已知中序和后序求先序"></a>(5). 已知中序和后序求先序</h5><p>​    首先使用中序和后序将二叉树求出来，然后再通过二叉树求出先序</p><p>​    使用后序确定节点顺序(找根节点，子树中最后出现的节点为根节点)，中序确定是左子树还是右子树，把大的树不断递归上面方法变成小树最后得出具体节点</p><p><a href="https://imgse.com/i/p9X82Uf"><img src="https://s1.ax1x.com/2023/05/29/p9X82Uf.png" alt="由中序和后序得出原始二叉树"></a></p><p>​    从树可以得出先序为：ABCDEFGH</p><h4 id="8-树的应用"><a href="#8-树的应用" class="headerlink" title="8. 树的应用"></a>8. 树的应用</h4><ul><li><p>树是数据库中数据组织一种重要形式</p></li><li><p>操作系统子、父进程的关系本身就是一棵树</p></li><li><p>面向对象语言中类的继承关系</p></li><li><p>哈夫曼树：一个事物有n种可能取值，每一种取值又有不同的概率，如何使得工作的效率达到最高</p></li></ul><h4 id="9-链式二叉树遍历的具体程序演示"><a href="#9-链式二叉树遍历的具体程序演示" class="headerlink" title="9. 链式二叉树遍历的具体程序演示"></a>9. 链式二叉树遍历的具体程序演示</h4><p>​    静态链式二叉树的创建与先序、中序、后序遍历代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token comment">//二叉树英文叫Binart Tree</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BTNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>    <span class="token comment">//p是指针 L是左 child是子节点</span>    <span class="token keyword">struct</span> <span class="token class-name">BTNode</span> <span class="token operator">*</span>pLchild<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">BTNode</span> <span class="token operator">*</span>pRchlid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>BTN<span class="token punctuation">,</span><span class="token operator">*</span>PBTN<span class="token punctuation">;</span><span class="token comment">//该函数为静态的创造树，但内存是需要动态分配的</span>PBTN <span class="token function">CreateBTree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先序遍历</span><span class="token keyword">void</span>  <span class="token function">PreTraverseBTree</span><span class="token punctuation">(</span>PBTN pT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//中序遍历</span><span class="token keyword">void</span>  <span class="token function">InTraverseBTree</span><span class="token punctuation">(</span>PBTN pT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//后序遍历</span><span class="token keyword">void</span>  <span class="token function">PostTraverseBTree</span><span class="token punctuation">(</span>PBTN pT<span class="token punctuation">)</span><span class="token punctuation">;</span>PBTN <span class="token function">CreateBTree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    PBTN pA <span class="token operator">=</span> <span class="token punctuation">(</span>PBTN<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PBTN pB <span class="token operator">=</span> <span class="token punctuation">(</span>PBTN<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PBTN pC <span class="token operator">=</span> <span class="token punctuation">(</span>PBTN<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PBTN pD <span class="token operator">=</span> <span class="token punctuation">(</span>PBTN<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PBTN pE <span class="token operator">=</span> <span class="token punctuation">(</span>PBTN<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pA<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>    pA<span class="token operator">-></span>pLchild <span class="token operator">=</span> pB<span class="token punctuation">;</span>    pA<span class="token operator">-></span>pRchlid <span class="token operator">=</span> pC<span class="token punctuation">;</span>    pB<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>    pB<span class="token operator">-></span>pLchild <span class="token operator">=</span> pB<span class="token operator">-></span>pRchlid <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pC<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token string">'C'</span><span class="token punctuation">;</span>    pC<span class="token operator">-></span>pLchild <span class="token operator">=</span> pD<span class="token punctuation">;</span>    pC<span class="token operator">-></span>pRchlid <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pD<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token string">'D'</span><span class="token punctuation">;</span>    pD<span class="token operator">-></span>pLchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pD<span class="token operator">-></span>pRchlid <span class="token operator">=</span> pE<span class="token punctuation">;</span>    pE<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token string">'E'</span><span class="token punctuation">;</span>    pE<span class="token operator">-></span>pLchild <span class="token operator">=</span> pE<span class="token operator">-></span>pRchlid <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//返回根节点的地址</span>    <span class="token keyword">return</span> pA<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">PreTraverseBTree</span><span class="token punctuation">(</span>PBTN pT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>pT<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token operator">-></span>pLchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">PreTraverseBTree</span><span class="token punctuation">(</span>pT<span class="token operator">-></span>pLchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token operator">-></span>pRchlid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">PreTraverseBTree</span><span class="token punctuation">(</span>pT<span class="token operator">-></span>pRchlid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span>  <span class="token function">InTraverseBTree</span><span class="token punctuation">(</span>PBTN pT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token operator">-></span>pLchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">InTraverseBTree</span><span class="token punctuation">(</span>pT<span class="token operator">-></span>pLchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>pT<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token operator">-></span>pRchlid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">InTraverseBTree</span><span class="token punctuation">(</span>pT<span class="token operator">-></span>pRchlid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span>  <span class="token function">PostTraverseBTree</span><span class="token punctuation">(</span>PBTN pT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token operator">-></span>pLchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">PostTraverseBTree</span><span class="token punctuation">(</span>pT<span class="token operator">-></span>pLchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> pT<span class="token operator">-></span>pRchlid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">PostTraverseBTree</span><span class="token punctuation">(</span>pT<span class="token operator">-></span>pRchlid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>pT<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    PBTN pT <span class="token operator">=</span> <span class="token function">CreateBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PostTraverseBTree</span><span class="token punctuation">(</span>pT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构06</title>
      <link href="/2023/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8406/"/>
      <url>/2023/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8406/</url>
      
        <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h4 id="1-递归的定义"><a href="#1-递归的定义" class="headerlink" title="1. 递归的定义"></a>1. 递归的定义</h4><p>​    一个函数自己直接或间接调用自己</p><h4 id="2-递归满足的三个条件"><a href="#2-递归满足的三个条件" class="headerlink" title="2. 递归满足的三个条件"></a>2. 递归满足的三个条件</h4><ol><li>一个明确的终止条件</li><li>该函数所处理的数据规模必须在递减(相对于终止条件而言)</li><li>这个转化必须是可解的</li></ol><h4 id="3-循环和递归的区别"><a href="#3-循环和递归的区别" class="headerlink" title="3. 循环和递归的区别"></a>3. 循环和递归的区别</h4><p>​    理论上所有的循环都可以转化为递归，但用递归解决的问题用循环不一定可以解决</p><p><strong>递归的特点</strong></p><ul><li>易理解</li><li>速度慢</li><li>存储空间大</li></ul><p><strong>循环的特点</strong></p><ul><li>不易理解</li><li>速度快</li><li>存储空间小</li></ul><h4 id="4-汉诺塔"><a href="#4-汉诺塔" class="headerlink" title="4. 汉诺塔"></a>4. 汉诺塔</h4><p>​     汉诺塔的伪算法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>先把A柱子上的前n<span class="token operator">-</span><span class="token number">1</span>个盘子从A借助C移动到B将A柱子上的第n个盘子直接移到C再将B柱子上的n<span class="token operator">-</span><span class="token number">1</span>个盘子借助A移到C<span class="token punctuation">&#125;</span><span class="token comment">//当n的值等于1时可以直接移动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    C语言对于汉诺塔的实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//函数参数的意义：将n个盘子从x借助y移动到z</span><span class="token keyword">void</span> <span class="token function">hannota</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">char</span> x<span class="token punctuation">,</span><span class="token keyword">char</span> y<span class="token punctuation">,</span><span class="token keyword">char</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> x <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> y <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> z <span class="token operator">=</span> <span class="token string">'C'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入有几个盘子：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将A上n个盘子借助B移动到C</span>    <span class="token function">hannota</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//x,y,z对应A,B,C</span><span class="token keyword">void</span> <span class="token function">hannota</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">char</span> x<span class="token punctuation">,</span><span class="token keyword">char</span> y<span class="token punctuation">,</span><span class="token keyword">char</span> z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"直接将第%d个盘子从%c移动到%c\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>x<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token comment">//将A上的n-1个盘子借助C移动到B</span>        <span class="token function">hannota</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>z<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将第n个盘子从A移动到C</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"直接将第%d个盘子从%c移动到%c\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>x<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//最后将B上n-1个盘子借助A移动到C，此时B等于是之前的A，A与B的角色相互转化</span>        <span class="token function">hannota</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>x<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-递归的应用"><a href="#5-递归的应用" class="headerlink" title="5. 递归的应用"></a>5. 递归的应用</h4><p>​    树和森林就是递归的方式定义的</p><p>​    树和图的很多算法都是以递归来实现</p><p>​    很多数学公式就是以递归方式定义的，如斐波拉契序列(1,2,3,5,8,13,21,34)</p><h4 id="6-为什么数据结构难"><a href="#6-为什么数据结构难" class="headerlink" title="6. 为什么数据结构难"></a>6. 为什么数据结构难</h4><p>​    需要将现实中多维的事务在计算机中以一维内存的方式进行表示</p><p>​    在Java中，ArrayList是数组实现的，LinkedList是链表实现的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理</title>
      <link href="/2023/05/04/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2023/05/04/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="1-代理模式的概念"><a href="#1-代理模式的概念" class="headerlink" title="1. 代理模式的概念"></a>1. 代理模式的概念</h4><p>​    为其他对象提供一种代理以控制对这个对象的访问，在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到桥梁的作用</p><h4 id="2-代理的作用"><a href="#2-代理的作用" class="headerlink" title="2. 代理的作用"></a>2. 代理的作用</h4><p>​    1. 功能增强：在原有的功能上增加额外的功能，新增加的功能叫做功能增强<br>​    2. 控制访问：代理类不让直接访问目标</p><h4 id="3-代理的实现方式"><a href="#3-代理的实现方式" class="headerlink" title="3. 代理的实现方式"></a>3. 代理的实现方式</h4><ol><li><p>静态代理</p><p>代理类是自己手工实现的，自己创建一个Java类，表示代理类，同时你所要代理的目标类是确定的</p></li><li><p>动态代理</p><p>当静态代理中目标类很多的时候，可以使用动态代理，避免静态代理具有的缺点</p></li></ol><h4 id="4-静态代理详解"><a href="#4-静态代理详解" class="headerlink" title="4. 静态代理详解"></a>4. 静态代理详解</h4><p>​    静态代理的特点：实现简单、容易理解</p><p>​    静态代理的缺点：当目标类增加，代理类可能也需要成倍的增加，造成代理类数量过多；当接口中功能增加或者修改会影响众多的实现类，厂家类，代理都需要修改</p><p>​    范例：模拟一个用户买u盘的行为，用户是客户端类，商家是代理，厂家是目标类；商家和厂家都是卖u盘的，他们完成的功能是一致的</p><p>​    三者的关系：用户(客户端)—–商家(代理)—–厂家(目标)</p><p><a href="https://imgse.com/i/p9JZg3Q"><img src="https://s1.ax1x.com/2023/05/02/p9JZg3Q.png" alt="p9JZg3Q.png"></a></p><p>​    代码太low不想copy了，大致思路：创建一个卖u盘方法，厂家实现这个方法，商家也要实现这个方法，在这个方法中商家调用厂家实现的方法，在此基础上增加一点功能(给优惠券、加价格)，用户通过调用商家的方法购买u盘</p><p>​    代理类完成的功能：<br>​    1. 目标类中方法的调用<br>​    2.  功能增强</p><h4 id="5-动态代理详解"><a href="#5-动态代理详解" class="headerlink" title="5. 动态代理详解"></a>5. 动态代理详解</h4><p>​    动态代理是指代理类对象在程序运行时由JVM根据反射机制动态生成的。动态代理不需要定义代理类的.java源文件</p><p>​    动态代理时jdk运行期间，动态创建class字节码并加载到JVM。</p><p>​    <strong>动态代理的实现方式常用的有两种</strong></p><ul><li>使用JDK动态代理：使用Java反射包<code>(java.lang.reflect)</code>中的类<code>(InvocationHandler,Method,Proxy)</code>和接口实现动态代理的功能</li><li>通过CGLIB动态代理：cglib是第三方的工具库，它可以创建代理对象；cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法，实现功能的修改，因为cglib是继承，重写方法，所以要求目标类不能是final的，方法也不能是final的。cglib这个要求比较宽松所以其在很多框架都有使用，如<code>mybatis</code>，<code>spring</code></li></ul><p>​    注意：对于无接口的类，要为其创建动态代理，就要使用cglib实现</p><h4 id="6-JDK动态代理"><a href="#6-JDK动态代理" class="headerlink" title="6. JDK动态代理"></a>6. JDK动态代理</h4><p><strong>反射机制在动态代理的应用</strong></p><p>​    新建一个print接口以及printImpl和printImpl2实现类</p><p><a href="https://imgse.com/i/p9YpmBF"><img src="https://s1.ax1x.com/2023/05/03/p9YpmBF.png" alt="p9YpmBF.png"></a></p><p><a href="https://imgse.com/i/p9Yp191"><img src="https://s1.ax1x.com/2023/05/03/p9Yp191.png" alt="p9Yp191.png"></a></p><p><a href="https://imgse.com/i/p9YptBD"><img src="https://s1.ax1x.com/2023/05/03/p9YptBD.png" alt="p9YptBD.png"></a></p><p>​    通过反射机制，使得只需要替换实例的名字，就可以执行不同语句的输出</p><p><a href="https://imgse.com/i/p9YpbbF"><img src="https://s1.ax1x.com/2023/05/03/p9YpbbF.png" alt="p9YpbbF.png"></a></p><p>​    运行结果</p><p><a href="https://imgse.com/i/p9Ypx81"><img src="https://s1.ax1x.com/2023/05/03/p9Ypx81.png" alt="p9Ypx81.png"></a></p><p><strong>JDK动态代理的实现</strong></p><p>​    反射包java.lang.reflect，三个类：InvocationHandler，Method，Proxy</p><p>​    InvocationHandler(中文名：调用处理器)接口：其中只有一个方法invoke()</p><p>​    invoke方法表示代理对象要执行的功能代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>invoke方法的参数：</p><ul><li>Object proxy：jdk创建的代理对象，通过静态方法newProxyInstance()创建该代理对象，详细见下面</li><li>Method：目标类中的方法</li><li>Object[] args：目标类中方法的参数</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span><span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>newProxyInstance方法的参数：</p><ul><li>ClassLoader：类加载器，负责向内存中加载对象，使用反射获取对象的classLoader，如：<code>a.getclass().getClassLoader()</code>。使用时需要<strong>目标对象的类加载器</strong></li><li>Class&lt;?&gt;[]：接口，<strong>目标对象实现的接口</strong>，也是反射获取的</li><li>InvocationHandler：<strong>自己写的代理类</strong>要完成的功能</li><li>返回值：就是代理对象</li></ul><p><strong>实现动态代理的步骤</strong></p><ol><li>创建接口，定义目标类要完成的功能</li><li>创建目标类实现接口</li><li>创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能<ul><li>调用目标方法</li><li>增强功能</li></ul></li><li>使用proxy类的静态方法，创建代理对象，并把返回值转为接口类型</li></ol><p>​    创建learn接口，定义day方法</p><p><a href="https://imgse.com/i/p9Yv1De"><img src="https://s1.ax1x.com/2023/05/04/p9Yv1De.png" alt="p9Yv1De.png"></a></p><p>​    创建learnImpl目标类实现该接口</p><p><a href="https://imgse.com/i/p9Yv0KS"><img src="https://s1.ax1x.com/2023/05/04/p9Yv0KS.png" alt="p9Yv0KS.png"></a></p><p>​    创建handle类实现InvocationHandler接口，并在invoke方法中完成代理类的功能</p><p><a href="https://imgse.com/i/p9YvWvT"><img src="https://s1.ax1x.com/2023/05/04/p9YvWvT.png" alt="p9YvWvT.png"></a></p><p>​    创建main类，在main方法中使用proxy类的静态方法创建代理对象，并由代理对象执行接口方法(增强后的)</p><p><a href="https://imgse.com/i/p9YxQGq"><img src="https://s1.ax1x.com/2023/05/04/p9YxQGq.png" alt="p9YxQGq.png"></a></p><h4 id="7-Proxy-newProxyInstance-方法的补充"><a href="#7-Proxy-newProxyInstance-方法的补充" class="headerlink" title="7. Proxy.newProxyInstance()方法的补充"></a>7. Proxy.newProxyInstance()方法的补充</h4><p>​    该方法的API</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span><span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    第一个参数：loader为用于定义代理类的类加载器，目前我已知有两种写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.先获得对象，如上面获得对象a，调用a.getClass().getClassLoader()获得</span><span class="token comment">//2.知道对象的类，使用反射加载，如上面代码以learn接口为例，使用learn.class.getClassLoader()获得</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    第二个参数：interfaces为代理类要实现的接口列表，目前我已知也有两种写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.先获得对象，如上面获得对象a，调用a.getClass().getInterfaces()获得</span><span class="token comment">//2.知道对象的类，使用反射加载，如上面代码以learn接口为例，使用new class[]&#123;learn.class&#125;获得</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring05</title>
      <link href="/2023/04/29/Spring05/"/>
      <url>/2023/04/29/Spring05/</url>
      
        <content type="html"><![CDATA[<h2 id="JdbcTemplate与SpringMVC异常处理"><a href="#JdbcTemplate与SpringMVC异常处理" class="headerlink" title="JdbcTemplate与SpringMVC异常处理"></a>JdbcTemplate与SpringMVC异常处理</h2><h4 id="1-JdbcTemplate概述"><a href="#1-JdbcTemplate概述" class="headerlink" title="1. JdbcTemplate概述"></a>1. JdbcTemplate概述</h4><p><a href="https://imgse.com/i/p9m5UyR"><img src="https://s1.ax1x.com/2023/04/24/p9m5UyR.png" alt="p9m5UyR.png"></a></p><h4 id="2-JdbcTemplate开发步骤"><a href="#2-JdbcTemplate开发步骤" class="headerlink" title="2. JdbcTemplate开发步骤"></a>2. JdbcTemplate开发步骤</h4><p>​    1. 导入spring-jdbc和spring-tx坐标<br>​    2. 创建数据库表和实体<br>​    3. 创建JdbcTemplate对象<br>​    4. 执行数据库操作</p><p>​    在pom.xml文件下导入坐标</p><p><a href="https://imgse.com/i/p9mbzA1"><img src="https://s1.ax1x.com/2023/04/24/p9mbzA1.png" alt="p9mbzA1.png"></a></p><p>​     创建数据库表，编写实体类，编写实体类对象的get方法和set方法</p><p><a href="https://imgse.com/i/p9mLyQS"><img src="https://s1.ax1x.com/2023/04/24/p9mLyQS.png" alt="p9mLyQS.png"></a></p><p>​    使用数据源对象获取数据库相关参数，使用无参构造产生一个JdbcTemplate对象，通过<code>JdbcTemplate.setDataSource(数据源对象)</code>方法获得与数据库的连接，之后就可以通过JdbcTemplate对象对数据库进行操作(增删改查)，<strong>数据库进行操作(增删改)使用的方法都是这一个<code>update(sql语句)</code>只需要修改对应的sql语句即可</strong></p><p><a href="https://imgse.com/i/p9mzdoQ"><img src="https://s1.ax1x.com/2023/04/24/p9mzdoQ.png" alt="p9mzdoQ.png"></a></p><h4 id="3-优化：使用Spring产生JdbcTenplate对象"><a href="#3-优化：使用Spring产生JdbcTenplate对象" class="headerlink" title="3. 优化：使用Spring产生JdbcTenplate对象"></a>3. 优化：使用Spring产生JdbcTenplate对象</h4><p><a href="https://imgse.com/i/p9nSGtJ"><img src="https://s1.ax1x.com/2023/04/24/p9nSGtJ.png" alt="p9nSGtJ.png"></a></p><p>​    创建一个Spring的配置文件叫做applicationContext.xml，在里面配置数据源对象和jdbc模板对象，<strong>这里数据库端口号写错了应该为3306</strong></p><p><a href="https://imgse.com/i/p9n9Ezn"><img src="https://s1.ax1x.com/2023/04/24/p9n9Ezn.png" alt="p9n9Ezn.png"></a></p><p>​    在Java代码中编写</p><p><a href="https://imgse.com/i/p9n9UeK"><img src="https://s1.ax1x.com/2023/04/24/p9n9UeK.png" alt="p9n9UeK.png"></a></p><p>​    当然，还可以进一步抽取jdbc.properties，前面笔记有过，这里不记了；先建立jdbc.properties文件，命名空间导入，然后加载jdbc.properties文件，最后用<code>$&#123;&#125;</code>引出数据</p><p>​    注意：之后对于jdbc的配置，看见直接就是这样一套</p><p><a href="https://imgse.com/i/p9nCvHf"><img src="https://s1.ax1x.com/2023/04/24/p9nCvHf.png" alt="p9nCvHf.png"></a></p><h4 id="4-JdbcTemplate的查询操作"><a href="#4-JdbcTemplate的查询操作" class="headerlink" title="4. JdbcTemplate的查询操作"></a>4. JdbcTemplate的查询操作</h4><p><strong>查询全部</strong></p><p>​    对于查询多个参数使用的query()方法有两个参数，第一个参数是sql语句，第二个参数是<code>RowMapper&lt;T&gt;</code> 它是一个接口，返回<code>List&lt;T&gt;</code>的数据，在使用时传递一个Spring已经实现好这个接口的实现类<code>BeanPropertyRowMapper</code>，当然这个接口<code>RowMapper&lt;T&gt;</code>的实现类还有其他的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//泛型使用account，它是自己建的实体类的名称，方法传参传递该对象的字节码，即Account.class</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Account</span><span class="token punctuation">></span></span> accountList <span class="token operator">=</span> jdbcTemplate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from account"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">BeanPropertyRowMapper</span><span class="token generics"><span class="token punctuation">&lt;</span>account<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Account</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <strong>总结</strong>：查询表中的对象，使用<code>queryForObject(sql语句,RowMapper&lt;&gt;(),Object args)</code>,第二个参数可以写RowMapper接口的实现类实例，<code>BeanPropertyRowMappe&lt;标注返回类类型&gt;(返回类.class)</code>；第三个参数是你想要放入sql中的条件；</p><p><strong>查询一个对象</strong></p><p>​    queryForObject方法第一个参数是sql，第二个参数是接口的实现类<code>BeanPropertyRowMapper</code>，第三个参数传递<code>?</code>的值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Account</span> account <span class="token operator">=</span> jdbcTemplate<span class="token punctuation">.</span><span class="token function">queryForObject</span><span class="token punctuation">(</span><span class="token string">"select *from account where name=?"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">BeanPropertyRowMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Account</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Account</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>聚合查询</strong></p><p>​    这个queryForObject方法第一个参数是sql，第二个参数是<code>Class&lt;T&gt; requiredType</code></p><pre class="line-numbers language-none"><code class="language-none">jdbcTemplate.queryForObject(&quot;select count(*) from account&quot;,Long.class);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-拦截器-interceptor"><a href="#5-拦截器-interceptor" class="headerlink" title="5. 拦截器(interceptor)"></a>5. 拦截器(interceptor)</h4><p><strong>(1)拦截器的作用</strong></p><p>​    SpringMVC的拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行<strong>预处理</strong>和<strong>后处理</strong>，拦截器对访问目标资源(Controller)的方法时做一些相应的干预</p><p><strong>(2)拦截器和过滤器的区别</strong></p><p><a href="https://imgse.com/i/p9K7YJx"><img src="https://s1.ax1x.com/2023/04/26/p9K7YJx.png" alt="p9K7YJx.png"></a></p><p>​    拦截范围的配置是在web.xml文件中</p><p><strong>(3)自定义拦截器的步骤</strong></p><p>​    1. 创建拦截器类实现<code>HandlerInterceptor</code>接口<br>​    2. 在Spring-mvc.xml配置interceptor<br>​    3. 测试拦截器的拦截效果</p><p>​    <strong>插入的小知识</strong></p><p>​    <strong>default关键字介绍：</strong></p><p>​    default是在java8中引入的关键字，也可称为Virtual extension methods——虚拟扩展方法。出现该关键字的原因是，由于接口在Java中定义之初，有一个缺点，那就是，如果定义了一个接口，接口中又定义了N个方法，那么某个具体的类在实现该接口时，需要实现接口中的所有方法，不管是否需要用到接口中的方法。如果接口中的某个方法被default关键字修饰了，那么具体的实现类中可以不用实现方法。<strong>default关键字在接口中修饰方法时，方法可以有方法体</strong></p><p>​    被拦截的Controller设计为</p><p><a href="https://imgse.com/i/p9MkvuQ"><img src="https://s1.ax1x.com/2023/04/26/p9MkvuQ.png" alt="p9MkvuQ.png"></a></p><p>​    新建一个拦截器的实现类实现<code>HandlerInterceptor</code>接口，该接口中的方法都是使用default修饰符来空实现，所以需要将要使用的方法覆盖，方法的种类：preHandle()方法是在目标方法执行之前执行；postHandle()方法是在目标方法执行之后，视图对象返回之前执行；afterCompletion()方法是在目标方法执行完毕后执行</p><p><a href="https://imgse.com/i/p9MpI76"><img src="https://s1.ax1x.com/2023/04/26/p9MpI76.png" alt="p9MpI76.png"></a></p><p>​    在Spring-mvc.xml文件里配置拦截器，<code>&lt;mvc:interceptors&gt;</code> 标签内部可以配置多个拦截器，<code>&lt;mvc:interceptor&gt;</code>表示一个拦截器，<code>&lt;bean&gt;</code>中注入拦截器实现类的全限定名，<code>&lt;mvc:mapping&gt;</code>中写对哪些资源执行拦截操作，<code>path=&quot;/**&quot;/</code>表示对所有的目标方法都执行拦截操作</p><p><a href="https://imgse.com/i/p9MkP6e"><img src="https://s1.ax1x.com/2023/04/26/p9MkP6e.png" alt="p9MkP6e.png"></a></p><p>​    测试结果：因为preHandle()方法的返回值为false，所以页面由原先显示的内容变为无显示，控制台打印为</p><p><a href="https://imgse.com/i/p9Mk87n"><img src="https://s1.ax1x.com/2023/04/26/p9Mk87n.png" alt="p9Mk87n.png"></a></p><p>​    改为true后，执行结果为，第二个打印来自Controller层的println方法</p><p><a href="https://imgse.com/i/p9MkwX4"><img src="https://s1.ax1x.com/2023/04/26/p9MkwX4.png" alt="p9MkwX4.png"></a></p><p><strong>(4)拦截器方法详解</strong></p><ul><li><p>preHandle(HttpServletRequest request,HttpServletResponse response,Object handler)</p><p>主要使用request和response，如http请求封装在request中，return的true和false当作开关使用，如果是false不让页面访问可以使用request转发或者response重定向</p></li><li><p>postHandle(HttpServletRequest request,HttpServletResponse response,Object handler,ModelAndView modelandview)</p><p>有个modelandview变量，可以把本应该传到页面的模型和视图给更改掉</p></li><li><p>afterCompletion(HttpServletRequest request,HttpServletResponse response,Object handle,Exception ex)</p><p>用的比较少，ex是将最后拿到的异常给封装</p></li></ul><p><strong>(5)多个拦截器拦截一个页面其中函数的运行效果</strong></p><p>​    在spring-mvc.xml的配置顺序决定了拦截器的率先执行顺序</p><p><a href="https://imgse.com/i/p9M30Tf"><img src="https://s1.ax1x.com/2023/04/26/p9M30Tf.png" alt="p9M30Tf.png"></a></p><h4 id="6-项目中出现的异常"><a href="#6-项目中出现的异常" class="headerlink" title="6. 项目中出现的异常"></a>6. 项目中出现的异常</h4><p>​    一般会在dao层抛出异常，在service层解决异常(try&amp;catch)</p><h4 id="7-SpringMVC异常处理机制"><a href="#7-SpringMVC异常处理机制" class="headerlink" title="7. SpringMVC异常处理机制"></a>7. SpringMVC异常处理机制</h4><p><strong>异常的种类</strong></p><p><a href="https://imgse.com/i/p9QR8iT"><img src="https://s1.ax1x.com/2023/04/27/p9QR8iT.png" alt="p9QR8iT.png"></a></p><p><strong>Springmvc框架对于异常的处理思路</strong></p><p> <a href="https://imgse.com/i/p9QRsJO"><img src="https://s1.ax1x.com/2023/04/27/p9QRsJO.png" alt="p9QRsJO.png"></a></p><p><a href="https://imgse.com/i/p9QRcSe"><img src="https://s1.ax1x.com/2023/04/27/p9QRcSe.png" alt="p9QRcSe.png"></a></p><p>​    <code>HandlerExceptionResolver</code>异常处理器中SpringMVC框架已经定义好了一些异常处理，如果不想用也可以自己定义(逻辑操作、代码操作)</p><p><strong>异常处理的两种方式</strong></p><ul><li>使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver</li><li>实现Spring的异常处理接口HandleExceptionResolver自定义自己的异常处理器，其可以自己对应操作跳页、直接处理、记录日志等</li></ul><h4 id="8-简单异常处理器SimpleMappingExceptionResolver"><a href="#8-简单异常处理器SimpleMappingExceptionResolver" class="headerlink" title="8. 简单异常处理器SimpleMappingExceptionResolver"></a>8. 简单异常处理器SimpleMappingExceptionResolver</h4><p>​    SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置，即主要是发现异常并跳转到指定的页面，只是一种异常和要跳转页面的映射关系</p><p>​    在Spring-mvc.xml文件中可以配置简单映射异常处理器</p><p><a href="https://imgse.com/i/p91zsV1"><img src="https://s1.ax1x.com/2023/04/29/p91zsV1.png" alt="p91zsV1.png"></a></p><p>​    其中，<code>name=&quot;defaultErrorView&quot;</code>表示默认错误视图，value的属性值为要跳转的视图名称，<code>name=&quot;exceptionMappings&quot;</code>表示异常的映射们，key的属性值为异常的全限定名，当有该异常时跳转到后面value指定的页面(<strong>不同的异常类型可以设置跳转到不同的视图</strong>)，若都没有则执行默认的，即跳转到默认错误视图指定的那个页面</p><h4 id="9-自定义异常处理步骤"><a href="#9-自定义异常处理步骤" class="headerlink" title="9. 自定义异常处理步骤"></a>9. 自定义异常处理步骤</h4><p><a href="https://imgse.com/i/p93S1zD"><img src="https://s1.ax1x.com/2023/04/29/p93S1zD.png" alt="p93S1zD.png"></a></p><p>​    新建一个Java类，在Java类中实现<code>HandlerExceptionResolver</code>接口，实现接口中的方法<code>resolveException(HttpServletRequest hsrt,HttpServletResonse hsre,Objecr o,Exception e)</code>，通过判断不同的异常执行不同的操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*参数Exception：异常对象返回值：ModelAndView：跳转到错误视图信息*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgse.com/i/p9393bd"><img src="https://s1.ax1x.com/2023/04/29/p9393bd.png" alt="p9393bd.png"></a></p><p>​    在Spring-mvc.xml中配置自定义的异常处理器</p><p><a href="https://imgse.com/i/p939sVs"><img src="https://s1.ax1x.com/2023/04/29/p939sVs.png" alt="p939sVs.png"></a></p><p>​    最后测试完成就行</p><h4 id="10-SpringMVC异常处理的总结"><a href="#10-SpringMVC异常处理的总结" class="headerlink" title="10. SpringMVC异常处理的总结"></a>10. SpringMVC异常处理的总结</h4><p><a href="https://imgse.com/i/p9392GV"><img src="https://s1.ax1x.com/2023/04/29/p9392GV.png" alt="p9392GV.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring04</title>
      <link href="/2023/04/25/Spring04/"/>
      <url>/2023/04/25/Spring04/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC的数据的请求和响应"><a href="#SpringMVC的数据的请求和响应" class="headerlink" title="SpringMVC的数据的请求和响应"></a>SpringMVC的数据的请求和响应</h2><h4 id="1-SpringMVC的数据相应方式"><a href="#1-SpringMVC的数据相应方式" class="headerlink" title="1. SpringMVC的数据相应方式"></a>1. SpringMVC的数据相应方式</h4><p><strong>1. 页面跳转</strong></p><ul><li>直接返回字符串</li><li>通过ModelAndView对象返回</li></ul><p><strong>2.回写数据</strong></p><ul><li>直接返回字符串</li><li>返回对象或集合</li></ul><h4 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2. 页面跳转"></a>2. 页面跳转</h4><p>​    <strong>(1).返回字符串形式</strong></p><p>​        此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转</p><p><a href="https://imgse.com/i/p9Vqgdx"><img src="https://s1.ax1x.com/2023/04/22/p9Vqgdx.png" alt="p9Vqgdx.png"></a></p><p>​    该种形式就是上面代码模拟的形式</p><p>​    <strong>(2).返回ModelAndView形式</strong></p><p>​    Model表示模型，作用为封装数据；View表示视图，作用为展示数据。在返回视图给页面时可以不携带数据，只展示视图</p><p><a href="https://imgse.com/i/p9VOPjH"><img src="https://s1.ax1x.com/2023/04/22/p9VOPjH.png" alt="p9VOPjH.png"></a></p><p>​    modelAndView.setViewName(“页面路径”)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ModelAndView</span> mv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token string">"/user/save/result"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认为forward模式  </span><span class="token comment">//ModelAndView mv = new ModelAndView("redirect:/user/save/result");//redirect模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    也可以为model设置数据，通过方法<code>modelAndView.addObject(键值对)</code></p><p><a href="https://imgse.com/i/p9VOxqs"><img src="https://s1.ax1x.com/2023/04/22/p9VOxqs.png" alt="p9VOxqs.png"></a></p><p>​    当然也可以换一种方式，通过注入思想，直接在方法传递形参，因为本身方法是SpringMVC调用，所以在调用方法时自动创造形参相对应的对象</p><p><a href="https://imgse.com/i/p9VxqTs"><img src="https://s1.ax1x.com/2023/04/22/p9VxqTs.png" alt="p9VxqTs.png"></a></p><p>​    在使用字符串形式时，也可以通过Model对象来传递参数，下面代码的model对象也是由SpringMVC自动创建</p><p><a href="https://imgse.com/i/p9Vze1K"><img src="https://s1.ax1x.com/2023/04/22/p9Vze1K.png" alt="p9Vze1K.png"></a></p><h4 id="3-回写数据"><a href="#3-回写数据" class="headerlink" title="3. 回写数据"></a>3. 回写数据</h4><p>​    <strong>(1).直接返回字符串</strong></p><p><a href="https://imgse.com/i/p9VzXHH"><img src="https://s1.ax1x.com/2023/04/22/p9VzXHH.png" alt="p9VzXHH.png"></a></p><p>​    可以通过SpringMVC框架直接注入：通过形参声明response引用类型由SpringMVC分配对象</p><p><a href="https://imgse.com/i/p9ZSVEj"><img src="https://s1.ax1x.com/2023/04/22/p9ZSVEj.png" alt="p9ZSVEj.png"></a></p><p>​    注意：回写是不需要跳转，方法返回值为void</p><p><a href="https://imgse.com/i/p9ZSu80"><img src="https://s1.ax1x.com/2023/04/22/p9ZSu80.png" alt="p9ZSu80.png"></a></p><p>​    浏览器输入页面后得到回写的字符串</p><p><a href="https://imgse.com/i/p9ZSGVJ"><img src="https://s1.ax1x.com/2023/04/22/p9ZSGVJ.png" alt="p9ZSGVJ.png"></a></p><p><a href="https://imgse.com/i/p9Zpmee"><img src="https://s1.ax1x.com/2023/04/22/p9Zpmee.png" alt="p9Zpmee.png"></a></p><p>​    注意：该注解加在方法前，如果不加注解，SpringMVC会把返回的return的字符串当作跳转页面名称进行资源匹配</p><p>​    使用<code>@ResponseBody</code>注解进行字符串的回写</p><p><a href="https://imgse.com/i/p9Zp5Sx"><img src="https://s1.ax1x.com/2023/04/22/p9Zp5Sx.png" alt="p9Zp5Sx.png"></a></p><p>​    上述回写字符串一般没什么意义，在实际开发中会回写json格式字符串，把某个实体类中存储的数据转换器json格式进行返回</p><p>​    首先在pom.xml导json相关的包，</p><p><a href="https://imgse.com/i/p9Zx2Us"><img src="https://s1.ax1x.com/2023/04/23/p9Zx2Us.png" alt="p9Zx2Us.png"></a></p><p><a href="https://imgse.com/i/p9ZxfCq"><img src="https://s1.ax1x.com/2023/04/23/p9ZxfCq.png" alt="p9ZxfCq.png"></a></p><p>​    通过新建对象ObjectMapper，并调用对象中方法<code>writeValueAsString(要转成json格式字符串的对象)</code>，进行转换</p><p><a href="https://imgse.com/i/p9ZxxxK"><img src="https://s1.ax1x.com/2023/04/23/p9ZxxxK.png" alt="p9ZxxxK.png"></a></p><p>​    <strong>(2).返回对象或者集合</strong></p><p>​    对于手动转型为字符串的操作，SpringMVC有提供自动转型的功能，但要实现该功能需要手动的进行配置</p><p>​    找处理器适配器<code>(org.springframework.web.servlet.HandlerAdapter)</code>中的<code>RequestMappingHandlerAdapter</code>，在这个类中提供有<code>setMessageConverters</code>方法指定多个消息转换器</p><p><a href="https://imgse.com/i/p9eFYtg"><img src="https://s1.ax1x.com/2023/04/23/p9eFYtg.png" alt="p9eFYtg.png"></a></p><p>​    在spring-mvc.xml文件中注入且<strong>修改处理器适配器的转换逻辑</strong></p><p><a href="https://imgse.com/i/p9eiHln"><img src="https://s1.ax1x.com/2023/04/23/p9eiHln.png" alt="p9eiHln.png"></a></p><p>​    此时在java类只要传递对象SpringMVC就可以自动的把它转换为json格式</p><p><a href="https://imgse.com/i/p9eFkm6"><img src="https://s1.ax1x.com/2023/04/23/p9eFkm6.png" alt="p9eFkm6.png"></a></p><p>​    除了上述的spring-mvc.xml配置非常繁琐还可以通过如下方式简化配置</p><p><a href="https://imgse.com/i/p9ekC4g"><img src="https://s1.ax1x.com/2023/04/23/p9ekC4g.png" alt="p9ekC4g.png"></a></p><p>​    <strong>HandlerMapping(处理器映射器)，是SpringMVC中用来处理Request请求URL到具体Controller的，其自身也分成很多种类；</strong></p><p>​    <strong>HandlerAdapter(处理器适配器)，是SpringMVC中用来处理具体请求映射到具体方法的，其自身也分很多种类</strong></p><p>​    在spring-mvc.xml文件中配置注解驱动取代注入配置处理器适配器，注意：使用mvc的注解驱动需要导入命名空间和约束路径</p><p><a href="https://imgse.com/i/p9eF5B6"><img src="https://s1.ax1x.com/2023/04/23/p9eF5B6.png" alt="p9eF5B6.png"></a></p><p>​    导入完之后编写注解驱动</p><p><a href="https://imgse.com/i/p9eF29J"><img src="https://s1.ax1x.com/2023/04/23/p9eF29J.png" alt="p9eF29J.png"></a></p><h4 id="4-SpringMVC获得请求参数"><a href="#4-SpringMVC获得请求参数" class="headerlink" title="4. SpringMVC获得请求参数"></a>4. SpringMVC获得请求参数</h4><p><a href="https://imgse.com/i/p9eAqOI"><img src="https://s1.ax1x.com/2023/04/23/p9eAqOI.png" alt="p9eAqOI.png"></a></p><p><strong>(1).获得基本类型参数</strong></p><p>​    Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配</p><p>​    注意：客户端请求任何参数都是字符串形式，但用了Spring框架可以帮你把数据进行自动转型</p><p>​    编写方法获得请求参数<code>localhost:8080/user/quick11?username=zhangsan&amp;age=18</code> </p><p>​    该方法有<code>@ResponBody</code>表示不进行页面跳转，返回值为void表示不回写数据，两个形参由于接收GET请求的参数</p><p><a href="https://imgse.com/i/p9eEyAf"><img src="https://s1.ax1x.com/2023/04/23/p9eEyAf.png" alt="p9eEyAf.png"></a></p><p><strong>(2).获得POJO类型参数</strong></p><p>​    Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配</p><p><a href="https://imgse.com/i/p9eVAvd"><img src="https://s1.ax1x.com/2023/04/23/p9eVAvd.png" alt="p9eVAvd.png"></a></p><p><strong>(3).获得数组类型参数</strong></p><p>​    Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配</p><p>​    因为数组默认是打印地址，所以要使用<code>Arrays.asList()</code>方法打印</p><p><a href="https://imgse.com/i/p9eeA0I"><img src="https://s1.ax1x.com/2023/04/23/p9eeA0I.png" alt="p9eeA0I.png"></a></p><p><strong>(4).获得集合类型参数</strong></p><p>​    获得集合参数时，在编写方法时要将集合参数包装到一个POJO中，以POJO为形参才能够接收</p><p>​    封装的POJO一般叫做VO对象，为该对象生成get、set以及toString方法</p><p><a href="https://imgse.com/i/p9eQIbQ"><img src="https://s1.ax1x.com/2023/04/23/p9eQIbQ.png" alt="p9eQIbQ.png"></a></p><p>​    在提交数据时，需要使用form表单进行提交，name的属性值要与后端的值相同</p><p><a href="https://imgse.com/i/p9elNZQ"><img src="https://s1.ax1x.com/2023/04/23/p9elNZQ.png" alt="p9elNZQ.png"></a></p><p>​    Controller业务中的方法vo来当作形参接收，vo与表单的userList[x]相对应</p><p><a href="https://imgse.com/i/p9e3K3t"><img src="https://s1.ax1x.com/2023/04/23/p9e3K3t.png" alt="p9e3K3t.png"></a></p><p><strong>(5).获得ajax发送的集合类型参数</strong></p><p>​    当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用<code>@RequestBody</code>可以直接接收集合数据无需使用POJO进行包装</p><p>​    一般发生ajax请求除了可以使用原生的js外，还可以导入jQuery包</p><p>​    导入jQuery包，编写ajax请求</p><p><a href="https://imgse.com/i/p9eYsQ1"><img src="https://s1.ax1x.com/2023/04/23/p9eYsQ1.png" alt="p9eYsQ1.png"></a></p><p>​    服务端直接用集合来接收，方法参数前要加注解<code>@RequestBody</code></p><p><a href="https://imgse.com/i/p9eYLTS"><img src="https://s1.ax1x.com/2023/04/23/p9eYLTS.png" alt="p9eYLTS.png"></a></p><p>​    因为有静态资源访问的问题，需要在<code>spring-mvc.xml</code>文件下加一句话</p><p><a href="https://imgse.com/i/p9etep9"><img src="https://s1.ax1x.com/2023/04/23/p9etep9.png" alt="p9etep9.png"></a></p><h4 id="5-SpringMVC获得请求参数-静态资源访问的开启"><a href="#5-SpringMVC获得请求参数-静态资源访问的开启" class="headerlink" title="5. SpringMVC获得请求参数-静态资源访问的开启"></a>5. SpringMVC获得请求参数-静态资源访问的开启</h4><p>​    如果不加静态资源设置spring-mvc.xml会使得访问不成功，原因是导入的jQuery文件找不到，因为在web.xml的文件中的前端控制器的配置是<code>/</code>，其是缺省的servlet，客户端发送请求找对应servlet进行处理，如果没有则全部交给缺省的进行处理，即下面代码中名字叫<code>DispatcherServlet</code>的servlet进行处理，但其内部进行虚拟路径的匹配，而jQuery.js也通过<code>@RequestMapping(&quot;/quick15&quot;)</code>进行匹配，但是没有，所以匹配不上</p><p><a href="https://imgse.com/i/p9eU9aT"><img src="https://s1.ax1x.com/2023/04/23/p9eU9aT.png" alt="p9eU9aT.png"></a></p><p>​    下面代码表示在SpringMVC框架中开放资源的访问权限，mapping表示映射地址，location表示哪个目录下的资源是对外开放的</p><p><a href="https://imgse.com/i/p9etep9"><img src="https://s1.ax1x.com/2023/04/23/p9etep9.png" alt="p9etep9.png"></a></p><h4 id="6-请求数据乱码问题"><a href="#6-请求数据乱码问题" class="headerlink" title="6. 请求数据乱码问题"></a>6. 请求数据乱码问题</h4><p>​    Tomcat8.5的服务器，对于GET请求是不会乱码的，但POST请求对于中文会出现乱码问题</p><p><a href="https://imgse.com/i/p9edQvd"><img src="https://s1.ax1x.com/2023/04/23/p9edQvd.png" alt="p9edQvd.png"></a></p><p>​    在web.xml文件中配置一个全局过滤器，并配置过滤器以那种方式进行编码，<code>&lt;filter-mapping&gt;</code> 配置对什么资源进行过滤，<code>/*</code>表示对所有的资源进行过滤</p><p><a href="https://imgse.com/i/p9ed2PU"><img src="https://s1.ax1x.com/2023/04/23/p9ed2PU.png" alt="p9ed2PU.png"></a></p><h4 id="7-参数绑定注解-requestParam"><a href="#7-参数绑定注解-requestParam" class="headerlink" title="7. 参数绑定注解@requestParam"></a>7. 参数绑定注解<code>@requestParam</code></h4><p><a href="https://imgse.com/i/p9ewnZq"><img src="https://s1.ax1x.com/2023/04/23/p9ewnZq.png" alt="p9ewnZq.png"></a></p><p>​    实际意思就是，请求参数xxx与Controller中的业务方法的参数名称要不一致时，可以在Controller中的业务方法的参数名称使用<code>@requestParam(value=&quot;xxx&quot;)</code>绑定请求参数xxx，且该注解如果只有一个属性可以省略value</p><p><a href="https://imgse.com/i/p9e0l7t"><img src="https://s1.ax1x.com/2023/04/23/p9e0l7t.png" alt="p9e0l7t.png"></a></p><h4 id="8-获得Restful风格的参数"><a href="#8-获得Restful风格的参数" class="headerlink" title="8. 获得Restful风格的参数"></a>8. 获得Restful风格的参数</h4><p><a href="https://imgse.com/i/p9eW8SI"><img src="https://s1.ax1x.com/2023/04/23/p9eW8SI.png" alt="p9eW8SI.png"></a></p><p><a href="https://imgse.com/i/p9eWNm8"><img src="https://s1.ax1x.com/2023/04/23/p9eWNm8.png" alt="p9eWNm8.png"></a></p><p><a href="https://imgse.com/i/p9eWy60"><img src="https://s1.ax1x.com/2023/04/23/p9eWy60.png" alt="p9eWy60.png"></a></p><p>​    上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用<code>@PathVariable</code>注解进行占位符的匹配获取工作</p><p>​    在<code>@RequestMapping(&quot;/quick/&#123;xxxx&#125;&quot;)</code>来进行占位符的声明，用<code>@PathVariable(value=&quot;xxxx&quot;)</code>来获取占位符对应的参数，<strong>xxxx必须完全匹配</strong>，并把参数赋值给方法的形参</p><p><a href="https://imgse.com/i/p9efENQ"><img src="https://s1.ax1x.com/2023/04/23/p9efENQ.png" alt="p9efENQ.png"></a></p><h4 id="9-自定义类型转换器"><a href="#9-自定义类型转换器" class="headerlink" title="9. 自定义类型转换器"></a>9. 自定义类型转换器</h4><p><a href="https://imgse.com/i/p9efqvq"><img src="https://s1.ax1x.com/2023/04/23/p9efqvq.png" alt="p9efqvq.png"></a></p><p><strong>自定义类型转换器的开发步骤：</strong></p><ol><li>定义转换器类实现Converter接口(SpringMVC提供的转换器接口)</li><li>在Spring-mvc.xml配置文件中声明转换器</li><li>在<code>&lt;annotation-driven&gt;</code> 中引用转换器</li></ol><p>​    <code>Converter&lt;S,T&gt;</code>接口，要实现泛型，S代表要转换前的类型，后面的T代表要转成的类型，在该接口中有一个未实现方法convert需要实现，参数是S，返回值为T</p><p>​    新建一个DateConverter的实现类，实现converter接口</p><p><a href="https://imgse.com/i/p9e5YCQ"><img src="https://s1.ax1x.com/2023/04/23/p9e5YCQ.png" alt="p9e5YCQ.png"></a></p><p>​    在Spring-mvc.xml配置文件中声明转换器，<code>&lt;list&gt;</code>中为刚刚自定义转换器类的全限定名 <a href="https://imgse.com/i/p9e5wD0"><img src="https://s1.ax1x.com/2023/04/23/p9e5wD0.png" alt="p9e5wD0.png"></a></p><p>​    通过指定转换器工厂帮产生日期转换器，传刚刚注入的id值</p><p><a href="https://imgse.com/i/p9e5hb6"><img src="https://s1.ax1x.com/2023/04/23/p9e5hb6.png" alt="p9e5hb6.png"></a></p><h4 id="10-获得Servlet相关API"><a href="#10-获得Servlet相关API" class="headerlink" title="10. 获得Servlet相关API"></a>10. 获得Servlet相关API</h4><p><a href="https://imgse.com/i/p9e73ss"><img src="https://s1.ax1x.com/2023/04/23/p9e73ss.png" alt="p9e73ss.png"></a></p><p>​    获取方式为，在想要使用的方法的形参进行注入，因为方法是框架调用，所以SpringMVC框架会帮你生成引用类型对应的对象</p><p>​    这个知识点前面有使用过</p><h4 id="11-获得请求头信息"><a href="#11-获得请求头信息" class="headerlink" title="11. 获得请求头信息"></a>11. 获得请求头信息</h4><p>​    请求头是键值对形式</p><p><a href="https://imgse.com/i/p9ebDV1"><img src="https://s1.ax1x.com/2023/04/23/p9ebDV1.png" alt="p9ebDV1.png"></a></p><p>​    注意：required的取值为true或者false，表示访问资源时是否要携带指定的请求头</p><p>​    <strong>网页的请求头</strong></p><p><a href="https://imgse.com/i/p9ebbRS"><img src="https://s1.ax1x.com/2023/04/23/p9ebbRS.png" alt="p9ebbRS.png"></a></p><p>​    获得请求头User-Agent请求头携带的信息，<code>@RequestHeader</code>的value对应的值要与网页的一致</p><p><a href="https://imgse.com/i/p9eqAsJ"><img src="https://s1.ax1x.com/2023/04/23/p9eqAsJ.png" alt="p9eqAsJ.png"></a></p><p>​    由于Cookie比较特殊，所以有如下注解获得Cookie对应的信息</p><p><a href="https://imgse.com/i/p9eqJeA"><img src="https://s1.ax1x.com/2023/04/23/p9eqJeA.png" alt="p9eqJeA.png"></a></p><p>​    使用<code>@CookieValue</code>获得cookie值</p><p><a href="https://imgse.com/i/p9eq6wn"><img src="https://s1.ax1x.com/2023/04/23/p9eq6wn.png" alt="p9eq6wn.png"></a></p><h4 id="12-文件上传"><a href="#12-文件上传" class="headerlink" title="12. 文件上传"></a>12. 文件上传</h4><p><strong>文件上传客户端三要素</strong></p><p>​    1. 表单项<code>type=&quot;file&quot;</code></p><p>​    2. 表单的提交方式是<code>POST</code><br>​    3. 表单的enctype属性是多部分表单形式，及<code>enctype=&quot;multipart/form-data&quot;</code></p><p>​    创建upload.jsp文件，编写文件上传表单</p><p><a href="https://imgse.com/i/p9mUl9g"><img src="https://s1.ax1x.com/2023/04/24/p9mUl9g.png" alt="p9mUl9g.png"></a></p><p><strong>文件上传原理</strong></p><ul><li>当form表单修改为多部份表单时，request.getParameter()将失效</li><li>enctype=<code>&quot;application/x-www-form-urlencoded&quot;</code>时，form表单的正文格式是：<code>key=value&amp;key=value&amp;key=value</code>，即键值对格式，这种方法也是form表单的默认提交格式</li><li>当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式：</li></ul><p><a href="https://imgse.com/i/p9ma0dP"><img src="https://s1.ax1x.com/2023/04/24/p9ma0dP.png" alt="p9ma0dP.png"></a></p><p><strong>单文件上传步骤</strong></p><p>​    1. 导入fileupload和io坐标</p><p>​    2. 配置文件上传解析器，<strong>应该这个xml文件也是由之前的<code>&lt;mvc-annotation-driven&gt;</code>解析的，这是我的猜测待考证</strong><br>​    3. 编写文件上传代码</p><p>​    在pom.xml导入fileupload和io坐标</p><p><a href="https://imgse.com/i/p9mdEwt"><img src="https://s1.ax1x.com/2023/04/24/p9mdEwt.png" alt="p9mdEwt.png"></a></p><p>​    在spring-mvc.xml文件中配置文件上传解析器</p><p><a href="https://imgse.com/i/p9mdXcQ"><img src="https://s1.ax1x.com/2023/04/24/p9mdXcQ.png" alt="p9mdXcQ.png"></a></p><p>​    在后台代码中，<strong>形参设置时应该与请求参数(form表单传递过来的参数)相一致</strong>，只不过传递的文件会被SpringMVC封装为一个叫MultipartFile类型的对象，其名字应该与form表单中file的name属性值一致</p><p>​    在后台代码接收前面upload.jsp中form表单传递的值</p><p><a href="https://imgse.com/i/p9m0QZn"><img src="https://s1.ax1x.com/2023/04/24/p9m0QZn.png" alt="p9m0QZn.png"></a></p><p>​    除了打印，将接收到的文件转存到磁盘某个位置(未来有服务器可以存到网络地址)，<code>getOriginaFilename()</code>作用为获得上传文件的文件名</p><p><a href="https://imgse.com/i/p9mBFOJ"><img src="https://s1.ax1x.com/2023/04/24/p9mBFOJ.png" alt="p9mBFOJ.png"></a></p><p><strong>多文件上传步骤</strong></p><p>​    与单文件上传一样，注意后台形参接收时与请求参数一致就行</p><p>​    如果前台<code>&lt;input type=&quot;file&quot; name =&quot;xxx&quot;&gt;</code> 多个name的属性值一样，那么后台使用数组接收就行，注意：数组名应与name属性值一致</p><p><a href="https://imgse.com/i/p9mB7A1"><img src="https://s1.ax1x.com/2023/04/24/p9mB7A1.png" alt="p9mB7A1.png"></a></p><p><a href="https://imgse.com/i/p9mBbh6"><img src="https://s1.ax1x.com/2023/04/24/p9mBbh6.png" alt="p9mBbh6.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring03</title>
      <link href="/2023/04/25/Spring03-%E7%9B%91%E5%90%AC%E5%99%A8%E5%AD%98%E5%82%A8spring%E5%AE%B9%E5%99%A8%E4%B8%8ESpringMVC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/25/Spring03-%E7%9B%91%E5%90%AC%E5%99%A8%E5%AD%98%E5%82%A8spring%E5%AE%B9%E5%99%A8%E4%B8%8ESpringMVC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring容器对象的管理"><a href="#1-Spring容器对象的管理" class="headerlink" title="1. Spring容器对象的管理"></a>1. Spring容器对象的管理</h3><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>​    Spring容器对象需要通过<code>new ClasspathXmlApplicationContext(Spring的xml配置文件)</code>或<code>new AnnotationConfigApplicationContext(SpringConfiguration.class)</code>获得，但在编写Web项目，不同的类中，每当需要获得Bean时都要编写一次，这样会使得Spring容器对象创建多次</p><h4 id="1-Web项目：使用自定义监听器管理Spring容器对象-非重点用于引出Spring自带的监听器"><a href="#1-Web项目：使用自定义监听器管理Spring容器对象-非重点用于引出Spring自带的监听器" class="headerlink" title="(1)Web项目：使用自定义监听器管理Spring容器对象(非重点用于引出Spring自带的监听器)"></a>(1)Web项目：使用自定义监听器管理Spring容器对象(非重点用于引出Spring自带的监听器)</h4><p>​    在Web项目中，可以使用ServletContextListener<strong>监听整个Web应用启动和销毁的生命周期</strong>，当Web应用启动时，就可创建Spring容器对象，将其存储在最大的域servletContext中，这样在任意位置都可以从域中获得Spring容器对象</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>​    1.在监听器的包内定义一个ServletContextListener类</p><p>​    2.在web.xml将这个ServletContextListener类进行配置</p><p>​    3.其他Servlet、Filter、Listener类通过this.getServletContext来获得存储在servletContext域中的Spring容器对象</p><h5 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h5><p>​    1.在listener包下新建ContextLoaderListener.java，继承实现servletContextListener接口</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;ContextLoaderListener.javapublic class ContextLoaderListener implements ServletContextListener&#123;&#x2F;&#x2F;上下文初始化时调用的方法public void contextInitialized(ServletContextEvent servletContextEvent)&#123;ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&#x2F;&#x2F;将app存储到最大的域（ServletContext）中ServletContext servletContext &#x3D; servletContextEvent.getServletContext();servletContext.setAttribute(&quot;app&quot;,app);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2.在web.xml文件，配置ContextLoaderListener.java，告知tomcat有这个监听器</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;web.xml&lt;web-app version&#x3D;&quot;3.0&quot; ...&gt;&#x2F;&#x2F;配置自定义监听器&lt;listener&gt;&lt;listener-class&gt;com.itheima.listener.ContextLoaderListener&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    3.Web层代码-UserServlet类中，通过this.getServletContext来获得存储在servletContext域中的Spring容器对象</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserServlet.javapublic class UserServlet extends HttpServlet&#123;@Overrideprotected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Exception&#123;&#x2F;&#x2F;获取上下文ServletContext servletContext &#x3D; this.getServletContext();&#x2F;&#x2F;获取在servletContext里的Spring容器对象ApplicationContext app &#x3D; (ApplicationContext)servletContext.getAttribute(&quot;app&quot;);&#x2F;&#x2F;使用Spring容器对象，获得容器里的beanUserService userService &#x3D; app.getBean(UserService.class);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-Web项目：使用Spring封装的监听器管理Spring容器对象（重点）"><a href="#2-Web项目：使用Spring封装的监听器管理Spring容器对象（重点）" class="headerlink" title="(2)Web项目：使用Spring封装的监听器管理Spring容器对象（重点）"></a>(2)Web项目：使用Spring封装的监听器管理Spring容器对象（重点）</h4><p>​    Spring提供了监听器ContextLoaderListener，其内部基于ServletContextListener进行封装，其还提供了工具类WebApplicationContextUtils用于获得Spring容器对象，在Web项目中的主要作用是：1.加载Spring容器对象，2.将该容器封装在Web的上下文对象中</p><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><p>​    1.在pom.xml文件导入spring-web坐标</p><p>​    2.在web.xml中配置ContextLoaderListener监听器，以及导入Spring配置文件applicationContext.xml</p><p>​    3.使用WebApplicationContextUtils获得Spring容器对象</p><h5 id="样例代码-1"><a href="#样例代码-1" class="headerlink" title="样例代码"></a>样例代码</h5><p>​    1.在pom.xml文件导入spring-web坐标</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;pom.xml&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;&lt;artifactId&gt;&gt;spring-web&lt;&#x2F;artifactId&gt;&lt;version&gt;5.0.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2.在web.xml文件下配置Spring提供的监听器，并在配置前告知监听器加载Spring配置文件的路径，监听器会通过这个路径的文件自动创建Spring容器对象（该功能是Spring封装好的）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;web.xml&lt;web-app version&#x3D;&quot;3.0&quot; ...&gt;&#x2F;&#x2F;告知监听器加载Spring配置文件的路径，监听器会通过这个文件获得Spring容器对象&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;&lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt;&#x2F;&#x2F;配置Spring的监听器&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    3.在UserServlet.java，编写获得Web上下文，再通过Web上下文获得Spring容器对象，再通过Spring容器对象获得bean</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserServlet.javapublic class UserServlet extends HttpServlet&#123;@Overrideprotected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Exception&#123;&#x2F;&#x2F;获取上下文ServletContext servletContext &#x3D; this.getServletContext();&#x2F;&#x2F;获取在servletContext里的Spring容器对象WebApplicationContext app &#x3D; WebApplicationContextUtils.getWebApplicationContext(servletContext);&#x2F;&#x2F;使用Spring容器对象，获得容器里的beanUserService userService &#x3D; app.getBean(UserService.class);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-SpringMVC框架的概述"><a href="#2-SpringMVC框架的概述" class="headerlink" title="2. SpringMVC框架的概述"></a>2. SpringMVC框架的概述</h3><p>​    Spring MVC 基于Servlet，其通常作为Web层的一部分，它可以独立于其他Spring模块来运行，也可以结合Spring的其他功能，如Spring事务管理、数据访问、AOP等</p><p>​    <code>SpringMVC可以通过一套注解让简单的Java类成为处理请求的控制器（servlet类）</code>，而无需实现任何接口，同时还支持RESTful编程风格的请求</p><h4 id="1-SpringMVC框架的使用"><a href="#1-SpringMVC框架的使用" class="headerlink" title="(1)SpringMVC框架的使用"></a>(1)SpringMVC框架的使用</h4><p>​    Spring MVC 项目的设计上有一个 <strong>上下文分层</strong> 的概念，Web 上下文和 Root 上下文（Spring容器对象）是分开的。这种分层有助于提高模块化和可维护性。<code>applicationContext.xml</code> 通常用于定义非 Web 相关的服务和数据访问对象，而 <code>spring-mvc.xml</code> 负责配置 Web 相关的组件（例如，处理请求的控制器、视图解析器等）</p><p>​    当 <code>DispatcherServlet</code> 加载 <code>spring-mvc.xml</code> 时，它会创建一个 <strong>Web Application Context</strong>，用于管理 Web 层相关的 Bean</p><h5 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h5><p>​    1.导入SpringMVC坐标<br>​    2.在web.xml中配置SpringMVC前端控制器，并配置加载spring-mvc.xml<br>​    3.新建spring-mvc.xml作为SpringMVC的配置文件，在该文件中配置组件扫描，扫描web层的包<br>​    4.编写UserController.java，用注解将其配置到Spring容器中<br>​    5.运行后用浏览器访问资源测试</p><h5 id="样例代码-2"><a href="#样例代码-2" class="headerlink" title="样例代码"></a>样例代码</h5><p>​    1.在pom.xml文件导入SpringMVC包</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;pom.xml&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;&lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2.在web.xml中配置SpringMVC的前端控制器 ，在 Spring MVC 项目中，spring-mvc.xml 是由 <strong><code>DispatcherServlet</code></strong> 来加载的，而不是 <code>ContextLoaderListener</code>。<code>DispatcherServlet</code> 是 Spring MVC 的核心，它充当前端控制器（Front Controller），负责处理所有 HTTP 请求。<code>DispatcherServlet</code> 会读取它自己的配置文件（通常是 <code>spring-mvc.xml</code>），初始化 Web 层相关的组件，例如控制器、视图解析器、请求映射等</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;web.xml&lt;servlet&gt;&lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;&#x2F;&#x2F;init-param：用于告知前端控制器配置这个Servlet时配置文件在哪&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;&lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;&lt;&#x2F;init-param&gt;&#x2F;&#x2F;load-on-startup:代表服务器启动时就去加载servlet(优先级设置为1)&lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;&lt;&#x2F;servlet&gt;&#x2F;&#x2F;servlet-mapping:为映射地址&lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;&#x2F;&#x2F;这个&#x2F;表示缺省的servlet，即每次访问任何请求都要走这个servlet，若为YYY.xxx为扩展名为YYY.xxx时才走这个servlet&lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    3.创建SpringMVC的xml文件，进行组件扫描，按定义SpringMVC只管Web层所以只扫描controller</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;spring-mvc.xml&#x2F;&#x2F;需要在命名空间里补一个context的命名空间&lt;beans xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context&gt; &#x2F;&#x2F;配置扫描controller层 &lt;context:component-scan base-package&#x3D;&quot;com.itheima.controller&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    4.编写UserController.java，用注解将其配置到Spring容器中</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserController.java@Controllerpublic class UserController&#123;&#x2F;&#x2F;这个属于SpringMVC的注解，详细功能见下面@RequestMapping(&quot;&#x2F;quick&quot;)public String save()&#123;System.out.println(&quot;运行成功&quot;);return &quot;success.jsp&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-SpringMVC的注解：-RequestMapping-“请求路径”"><a href="#2-SpringMVC的注解：-RequestMapping-“请求路径”" class="headerlink" title="(2)SpringMVC的注解：@RequestMapping(“请求路径”)"></a>(2)SpringMVC的注解：@RequestMapping(“请求路径”)</h4><p>​    <code>@RequestMapping</code>是 Spring MVC 中用于处理 HTTP 请求的注解。<code>它可以用于类级别或者方法级别</code>，用来定义请求的 URL 映射、HTTP 方法（如 GET、POST 等）以及请求参数等信息</p><ul><li><strong>方法级别</strong>：用来映射具体的请求路径，并指定该方法处理哪些 HTTP 请求。</li><li><strong>类级别</strong>：用来为控制器类定义一个基础的路径，方法级别的路径会在类级别路径的基础上追加。</li></ul><h5 id="样例：方法级别"><a href="#样例：方法级别" class="headerlink" title="样例：方法级别"></a>样例：方法级别</h5><p>​    在浏览器请求路径：<code>http://localhost:8080/quick</code>可以访问success.jsp的资源</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserController.java@Controllerpublic class UserController&#123;&#x2F;&#x2F;请求地址为 http:&#x2F;&#x2F;localhost:8080&#x2F;quick@RequestMapping(&quot;&#x2F;quick&quot;)public String save()&#123;System.out.println(&quot;运行成功&quot;);return &quot;success.jsp&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="样例：类级别"><a href="#样例：类级别" class="headerlink" title="样例：类级别"></a>样例：类级别</h5><p>​    在浏览器请求路径：<code>http://localhost:8080/user/quick</code>可以访问success.jsp的资源</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserController.java@Controller@RequestMapping(&quot;&#x2F;user&quot;)public class UserController&#123;&#x2F;&#x2F;请求地址为 http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;quick@RequestMapping(&quot;&#x2F;quick&quot;)public String save()&#123;System.out.println(&quot;运行成功&quot;);return &quot;success.jsp&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="请求路径的参数配置"><a href="#请求路径的参数配置" class="headerlink" title="请求路径的参数配置"></a>请求路径的参数配置</h5><p>​    通过请求路径的参数配置可以进一步细分请求的匹配条件</p><ul><li>value：用于指定请求的URL，在只有value的情况下可以省略，但多个属性不能省，上面代码完整的应该为<code>@RequestMapping(value=&quot;/quick&quot;)</code></li><li>method：用于指定请求的方式，默认是GET，如果要改为POST，它存储方式是枚举类型为<code>@RequestMapping(value=&quot;/quick&quot;,method=RequestMethod.POST)</code></li></ul><h4 id="3-Spring新注解-代替-RequestMapping"><a href="#3-Spring新注解-代替-RequestMapping" class="headerlink" title="(3)Spring新注解-代替 @RequestMapping"></a>(3)Spring新注解-代替 @RequestMapping</h4><p>​    Spring 4.3 引入了几个更为具体的注解，用来代替 @RequestMapping，使代码更加语义化</p><ul><li><code>@GetMapping</code>：用于处理 GET 请求</li><li><code>@PostMapping</code>：用于处理 POST 请求</li><li><code>@PutMapping</code>：用于处理 PUT 请求</li><li><code>@DeleteMapping</code>：用于处理 DELETE 请求</li><li><code>@PatchMapping</code>：用于处理 PATCH 请求</li></ul><h4 id="4-SpringMVC的执行流程"><a href="#4-SpringMVC的执行流程" class="headerlink" title="(4)SpringMVC的执行流程"></a>(4)SpringMVC的执行流程</h4><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><a href="https://imgse.com/i/pE1FvkV"><img src="https://s21.ax1x.com/2025/02/24/pE1FvkV.png" alt="SpringMVC的执行流程"></a></p><h5 id="上图流程解释（重点）"><a href="#上图流程解释（重点）" class="headerlink" title="上图流程解释（重点）"></a>上图流程解释（重点）</h5><p>​    当你在浏览器中输入一个 URL（比如 <code>http://localhost:8080/quick</code>）并按下回车时，浏览器会向服务器发起一个 <strong>HTTP 请求</strong>。这个请求可能包含一些数据（如表单数据、请求头等）。服务器接收到请求后，会做出一个 <strong>HTTP 响应</strong>，将结果返回给浏览器，通常是网页内容、图片等。<strong>Servlet 容器（如 Tomcat）会在每次接收到请求时自动创建这两个对象</strong>【HttpServletRequest（简称 <strong>req</strong>）和 HttpServletResponse（简称 <strong>resp</strong>）】并将它们传递给 DispatcherServlet（Spring 的前端控制器），<strong>DispatcherServlet 将请求路由到对应的控制器方法并将 req和resp对象传递给控制器方法</strong>，然后控制器方法就可以使用它们来处理请求和构建响应，最后，控制器方法返回响应的视图或数据，DispatcherServlet会通过 resp将数据发送回浏览器</p><h5 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h5><p>​    Servlet是 Java 提供的一种技术，用于在服务器端处理 HTTP 请求和生成 HTTP 响应。简单来说，Servlet 就是一个可以处理 Web 请求的 Java 类。当用户访问一个 Web 应用时，服务器会调用对应的 Servlet 来处理请求。</p><h3 id="3-SpringMVC的其他组件"><a href="#3-SpringMVC的其他组件" class="headerlink" title="3. SpringMVC的其他组件"></a>3. SpringMVC的其他组件</h3><p>​    除了DispatcherServlet（前端控制器），要实现请求的处理和响应，Spring MVC 的其他组件还包括 HandlerMapping（请求映射）、Controller（请求处理）、HandlerAdapter（调用控制器）、ModelAndView（模型视图）、ViewResolver（视图解析器）等，这些其他组件都是由DispatcherServlet调用完成工作</p><p>​    <code>这里所有组件的配置都是在spring-web.xml文件中配置</code></p><h4 id="1-SpringMVC各组件执行流程"><a href="#1-SpringMVC各组件执行流程" class="headerlink" title="(1)SpringMVC各组件执行流程"></a>(1)SpringMVC各组件执行流程</h4><h5 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h5><p><a href="https://imgse.com/i/pE1ZJbj"><img src="https://s21.ax1x.com/2025/02/24/pE1ZJbj.png" alt="SpringMVC各组件执行流程"></a></p><h5 id="SpringMVC代码层面的执行流程（各组件）"><a href="#SpringMVC代码层面的执行流程（各组件）" class="headerlink" title="SpringMVC代码层面的执行流程（各组件）"></a>SpringMVC代码层面的执行流程（各组件）</h5><p>​    1.web.xml加载：在Servlet容器启动时，web.xml配置文件加载加载，配置 DispatcherServlet 和 ContextLoaderListener<br>​    2.ContextLoaderListener加载：ContextLoaderListener初始化并加载 Root Web Context（例如 applicationContext.xml），通常包含服务层和数据源的配置<br>​    3.DispatcherServlet 加载：DispatcherServlet 加载并初始化 Web ApplicationContext（spring-mvc.xml）<br>​    4.请求到达 DispatcherServlet：请求由 DispatcherServlet 拦截，HandlerMapping 查找匹配的控制器（Controller）<br>​    5.HandlerAdapter 执行控制器：一旦找到匹配的控制器，DispatcherServlet使用HandlerAdapter来调用控制器方法。HandlerAdapter负责执行控制器方法，并处理控制器方法的返回值（比如视图名或数据）<br>​    6.视图解析与响应：DispatcherServlet 通过视图解析器（ViewResolver）渲染视图，将最终响应通过 HttpServletResponse返回给浏览器</p><h4 id="2-SpringMVC组件在spring-web-xml的配置"><a href="#2-SpringMVC组件在spring-web-xml的配置" class="headerlink" title="(2)SpringMVC组件在spring-web.xml的配置"></a>(2)SpringMVC组件在spring-web.xml的配置</h4><p>​    SpringMVC组件在原生环境是配置好的，可以在spring-web.xml对组件再配置进行功能上增强（aop思想）</p><h5 id="样例：视图解析器（viewResolver）的配置"><a href="#样例：视图解析器（viewResolver）的配置" class="headerlink" title="样例：视图解析器（viewResolver）的配置"></a>样例：视图解析器（viewResolver）的配置</h5><p>​    在进行视图跳转时，对每一次请求<code>u</code>进行<code>前缀+u+后缀</code>的拼接作为请求路径</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;spring-mvc.xml&#x2F;&#x2F;配置视图解析器&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&#x2F;&#x2F;用其父类提供的set方法进行注入&#x2F;&#x2F;设置视图路径的前缀&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;jsp&#x2F;&quot;&gt;&#x2F;&#x2F;设置视图路径的后缀&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring02</title>
      <link href="/2023/04/25/Spring02-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8ESpring%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/04/25/Spring02-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8ESpring%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring配置连接池-数据源"><a href="#1-Spring配置连接池-数据源" class="headerlink" title="1. Spring配置连接池(数据源)"></a>1. Spring配置连接池(数据源)</h3><p>​    连接池是对数据库连接的管理工具，常见的连接池有：DBCP、C3P0、BoneCP、Druid等</p><h4 id="1-连接池和数据库的区别"><a href="#1-连接池和数据库的区别" class="headerlink" title="(1)连接池和数据库的区别"></a>(1)连接池和数据库的区别</h4><h5 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h5><ul><li>连接池是一种用于管理数据库连接的机制，它通过提前创建一定数量的数据库连接，并在应用程序中重复利用这些连接，从而减少了频繁创建和销毁数据库连接的开销</li><li>当应用程序需要与数据库进行交互时，连接池会从池中获取一个可用的连接，当操作完成后，该连接会被归还给连接池，以便其他请求使用</li><li>连接池的主要作用是提高数据库操作的效率，特别是在高并发环境下。</li></ul><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><ul><li>数据库是一个系统，用来存储和管理数据。它允许用户通过SQL语句来进行数据的增、删、改、查等操作</li><li>常见的数据库有关系型数据库（如MySQL、PostgreSQL）和非关系型数据库（如MongoDB、Redis）</li></ul><h4 id="2-连接池的手动连接使用-非Spring"><a href="#2-连接池的手动连接使用-非Spring" class="headerlink" title="(2)连接池的手动连接使用(非Spring)"></a>(2)连接池的手动连接使用(非Spring)</h4><h5 id="手动连接步骤"><a href="#手动连接步骤" class="headerlink" title="手动连接步骤"></a>手动连接步骤</h5><p>​    1.添加连接池的依赖和数据库驱动的依赖（pom.xml）<br>​    2.配置连接池基本连接信息和数据库连接信息（jdbc.properties）<br>​    3.创建和初始化连接池（DataSourse.java）<br>​    4.获取连接并使用（DataSourse.java）<br>​    5.关闭连接（DataSourse.java）</p><h5 id="手动连接实操"><a href="#手动连接实操" class="headerlink" title="手动连接实操"></a>手动连接实操</h5><p>​    1.在pom.xml文件中导入坐标，mysql、c3p0</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;pom.xml&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;version&gt;5.1.32&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;&lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;&lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2.在resource文件夹下创建jdbc.properties文件，配置数据库连接信息</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;jdbc.propertiesjdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    3.加载.properties文件来连接数据库，通过Java提供的ResourceBundle类以及该类提供的getBundle(“.properties文件的类加载路径且不需要写扩展名”)方法，来导入.properties文件。通过ResourceBundle对象的getString(“.properties文件中定义的key值”)，来获得对应的字符串</p><p>​    4-5.获取连接/断开连接</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;DataSourse.javapublic void useDataSourse() throws Exception&#123;&#x2F;&#x2F;读取jdbc.properties配置文件ResourceBundle rb &#x3D; ResourceBundle.getBundle(&quot;jdbc&quot;);String driver &#x3D; rb.getString(&quot;jdbc.driver&quot;);String url &#x3D; rb.getString(&quot;jdbc.url&quot;);String username &#x3D; rb.getString(&quot;jdbc.username&quot;);String password &#x3D; rb.getString(&quot;jdbc.password&quot;);&#x2F;&#x2F;创建连接池对象，将连接参数配置ComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource();dataSource.setDriverClass(driver);dataSource.setJdbcUrl(url);dataSource.setUser(username);dataSource.setPassword(password);&#x2F;&#x2F;获取连接Connection connection &#x3D; dataSource.getConnection();System.out.println(connection);&#x2F;&#x2F;关闭连接connection.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-连接池使用Spring容器连接"><a href="#3-连接池使用Spring容器连接" class="headerlink" title="(3)连接池使用Spring容器连接"></a>(3)连接池使用Spring容器连接</h4><p>​    对于c3p0连接池的对象dataSource的创建使用Spring容器完成</p><h5 id="Spring容器连接步骤"><a href="#Spring容器连接步骤" class="headerlink" title="Spring容器连接步骤"></a>Spring容器连接步骤</h5><p>​    1.导入Spring坐标、连接池坐标、数据库坐标（pom.xml）<br>​    2.创建数据库连接的配置文件（jdbc.properties）<br>​    3.创建Spring的配置文件（applicationContext.xml）<br>​    4.使用Spring容器获得连接池对象（SpringDataSourse.java）<br>​    5.获取连接并使用（SpringDataSourse.java）<br>​    6.关闭连接(SpringDataSourse.java)</p><h5 id="Spring连接实操"><a href="#Spring连接实操" class="headerlink" title="Spring连接实操"></a>Spring连接实操</h5><p>​    1.在pom.xml文件中导入坐标，mysql、c3p0、Spring</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;pom.xml&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;version&gt;5.1.32&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;&lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;&lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;&lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    2.在resource文件夹下创建jdbc.properties文件，配置数据库连接信息</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;jdbc.propertiesjdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testjdbc.username&#x3D;rootjdbc.password&#x3D;root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    3.在resource文件夹下创建Spring的applicationContext.xml配置文件，抽取properties文件，需要在命名空间添加引入Context，配置连接池的bean</p><pre class="line-numbers language-none"><code class="language-none">&lt;beans xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; &#x2F;&#x2F;命名空间添加这两句话用于引入Context   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &#x2F;&#x2F;加载外部的properties文件到Spring容器中，当前文件在类加载路径下&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;&#x2F;&#x2F;name的值和set方法有关&lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    4.使用Spring容器获得连接池对象</p><p>​    5-6.获取连接/断开连接</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;SpringDataSourse.javapublic void useSpringDataSourse throws Exception&#123;&#x2F;&#x2F;获得连接池对象ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource &#x3D; (DataSource) app.getBean(&quot;dataSouce&quot;);&#x2F;&#x2F;获取连接Connection connection &#x3D; dataSource.getConnection();System.out.println(connection);&#x2F;&#x2F;关闭连接connection.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-Spring注解开发"><a href="#2-Spring注解开发" class="headerlink" title="2. Spring注解开发"></a>2. Spring注解开发</h3><p>​    Spring是轻代码重配置的框架，配置比较繁重影响开发效率，<code>注解完全代替xml配置文件可以简化配置</code>，提高开发效率</p><h4 id="1-Spring注解开发的准备工作"><a href="#1-Spring注解开发的准备工作" class="headerlink" title="(1)Spring注解开发的准备工作"></a>(1)Spring注解开发的准备工作</h4><p>​    要使用注解需要提前告诉Spring，通过在applicationContext.xml文件中配置组件扫描，指定哪个包及其子包下的Java文件需要进行扫描以便识别使用注解配置的类、字段和方法</p><h5 id="语法：配置组件扫描"><a href="#语法：配置组件扫描" class="headerlink" title="语法：配置组件扫描"></a>语法：配置组件扫描</h5><p>​    <code>base-package=&quot;包名&quot;</code>，其会扫描该包下所有的子包，包下所有使用了注解的都会被扫描到</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;applicationContext.xml，是在下方，不是命名空间配置，这个也需要引入context命名空间&lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&gt;&lt;&#x2F;context:component-scan&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-Spring原始注解-核心注解-的介绍"><a href="#2-Spring原始注解-核心注解-的介绍" class="headerlink" title="(2)Spring原始注解(核心注解)的介绍"></a>(2)Spring原始注解(核心注解)的介绍</h4><p>​    Spring原始注解主要用于<code>代替Spring的xml文件来配置和管理 Spring 容器中的 Bean</code>，处理依赖注入、事务管理、事件处理等任务</p><h5 id="常用的原始注解"><a href="#常用的原始注解" class="headerlink" title="常用的原始注解"></a>常用的原始注解</h5><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Component</td><td align="center">写在类上，标记这个类作为 Spring 容器中的 Bean</td></tr><tr><td align="center">@Controller</td><td align="center">写在作为Spring MVC 控制器的类上，与@Component效果一样，仅作为语义区分</td></tr><tr><td align="center">@Service</td><td align="center">写在作为服务层的类上，与@Component效果一样，仅作为语义区分</td></tr><tr><td align="center">@Repository</td><td align="center">写在作为数据访问层的类上，与@Component效果一样，仅作为语义区分</td></tr><tr><td align="center">@Autowired</td><td align="center">写在字段、构造方法或set方法上，自动将一个Spring容器的Bean 注入到另一个 Bean</td></tr><tr><td align="center">@Qualifier</td><td align="center">@Autowired根据类型注入Bean，当有多个相同类型的Bean时，在其下方使用该注解指定要注入的 Bean 的名字</td></tr><tr><td align="center">@Value</td><td align="center">写在字段上，用于注入普通值或外部配置值（如 application.properties或 application.yml文件中的属性）</td></tr><tr><td align="center">@Scope</td><td align="center">写在类上，定义 Bean 的作用域</td></tr><tr><td align="center">@PostConstruct</td><td align="center">写在方法上，该方法在该类的Bean初始化后自动执行</td></tr><tr><td align="center">@PreDestroy</td><td align="center">写在方法上，该方法在容器销毁该类的Bean前自动执行</td></tr></tbody></table><h4 id="3-Spring的原始注解详解"><a href="#3-Spring的原始注解详解" class="headerlink" title="(3)Spring的原始注解详解"></a>(3)Spring的原始注解详解</h4><h5 id="Component-“唯一标识”"><a href="#Component-“唯一标识”" class="headerlink" title="@Component(“唯一标识”)"></a>@Component(“唯一标识”)</h5><p>​    使用注解<code>@Component(&quot;唯一标识&quot;)</code>等同在xml文件中对bean的配置，在需要Spring容器管理的类上方写注解，</p><p>​    <strong>注意：唯一标识可以不写，如@Component</strong></p><p>样例：@Component的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserDaoImpl.java&#x2F;&#x2F;等价于xml文件：&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao&#123;public void save()&#123;System.out.println(&quot;save running...&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><p>​    使用注解<code>@Autowired</code>等同于在xml文件中的propety属性的注入配置，写在字段上，Spring 会自动为该字段注入一个 Bean（前提是容器中有与字段类型匹配的 Bean），没有找到合适的或找到多个其会抛出异常</p><p>​    一个bean可省：如果存在多个符合条件的 bean可以在其下方加<code>@Qualifier(&quot;唯一标识&quot;)</code>指定注入bean的名字</p><p>样例：@Autowired的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserServiceImpl.java&#x2F;&#x2F;等价于xml文件：&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;@Component(&quot;userService&quot;)public class UserServiceImpl implements UserService&#123;&#x2F;&#x2F;等价于xml文件：&lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&gt;&lt;&#x2F;property&gt;@Autowired@Qualifier(&quot;userDao&quot;)private UserDao userDao;&#x2F;&#x2F;注入字段不需要额外写set方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Controller，-Service，-Repository"><a href="#Controller，-Service，-Repository" class="headerlink" title="@Controller，@Service，@Repository"></a>@Controller，@Service，@Repository</h5><p>​    他们都属于特殊类型的@Component注解，功能与其一致，作用是增强代码的可读性：@Controller—web层；@Service—service层；@Repository—dao层</p><p>​    <strong>注意：他们三个都可以写唯一标识，如@Controller(“userController”)</strong></p><p>样例：@Controller，@Service，@Repository的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserController.java@Controllerpublic class UserController&#123;    &#x2F;&#x2F; 控制器逻辑&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserServiceImpl.java@Servicepublic class UserServiceImpl implements UserService&#123;    &#x2F;&#x2F; 业务逻辑&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserDaoImpl.java@Repositorypublic class UserDaoImpl implements UserDao&#123;    &#x2F;&#x2F; 数据访问逻辑&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Value-“要注入的值”"><a href="#Value-“要注入的值”" class="headerlink" title="@Value(“要注入的值”)"></a>@Value(“要注入的值”)</h5><p>​    @Value用于注入属性值，可以值直接注入bean或者将外部的配置值（如application.properties或application.yml文件中的属性）注入到 Bean 的字段中，在值注入中虽然值是你提供的，但还是Spring来进行注入，而使用外部配置值需要将这些文件提前注入到Spring容器中</p><p>样例：@Value(“要注入的值”)的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserDaoImpl.java@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao&#123;&#x2F;&#x2F;将String类型的itcast注入it，直接注入@Value(&quot;itcast&quot;)private String it;&#x2F;&#x2F;Spring容器中要提前加载jdbc.properties文件才可以通过&#96;$&#123;&#125;&#96;对文件里的内容进行注入@Value(&quot;$&#123;jdbc.drive&#125;&quot;)private String driver;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Scope-“属性值”"><a href="#Scope-“属性值”" class="headerlink" title="@Scope(“属性值”)"></a>@Scope(“属性值”)</h5><p>​    @Scope定义bean的范围，其写在类的上方，用来设置bean是单例还是多例</p><p>样例：@Scope(“属性值”)的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserServiceImpl.java@Component(&quot;userService&quot;)&#x2F;&#x2F;设置创建的bean是多例，单例设置为@Scope(&quot;singleton&quot;)@Scope(&quot;prototype&quot;)public class UserServiceImpl implements UserService&#123;&#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h5><p>​    写在类中的方法前，用于设置bean在创建或者销毁时要执行的方法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;UserServiceImpl.java@Component(&quot;userService&quot;)public class UserServiceImpl implements UserService&#123;&#x2F;&#x2F;配置该方法在bean创建时调用@PostConstructpublic void init()&#123;System.out.println(&quot;Service类的bean初始化调用&quot;);&#125;&#x2F;&#x2F;配置该方法在bean销毁前调用@PreDestroypublic void destroy()&#123;System.out.println(&quot;Service类的bean销毁前调用&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-Spring3新注解-配置注解-介绍"><a href="#4-Spring3新注解-配置注解-介绍" class="headerlink" title="(4)Spring3新注解(配置注解)介绍"></a>(4)Spring3新注解(配置注解)介绍</h4><p>​    原始注解不能完全代替xml配置文件，<code>通过使用@Configuration注解的类可以充当Spring的Java配置文件，取代传统的 applicationContext.xml配置文件</code></p><h5 id="使用Spring新注解替代的配置如下："><a href="#使用Spring新注解替代的配置如下：" class="headerlink" title="使用Spring新注解替代的配置如下："></a>使用Spring新注解替代的配置如下：</h5><ul><li>非自定义的类的bean导入：如需要将第三方jar包中的类配置到Spring容器中</li><li>加载properties文件的配置：&lt; context:property-placeholder &gt;</li><li>组件扫描的配置：&lt; context:component-scan &gt;</li><li>引入其他文件：&lt; import &gt; </li></ul><h5 id="Spring3的新注解"><a href="#Spring3的新注解" class="headerlink" title="Spring3的新注解"></a>Spring3的新注解</h5><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Configuration</td><td align="center">写在类上，用于标注该类为Java的配置类用于代替Spring的xml配置文件</td></tr><tr><td align="center">@ComponentScan</td><td align="center">写在Java的配置类上，用于指定自动扫描的包及子包</td></tr><tr><td align="center">@Bean</td><td align="center">写在方法上，将该方法的返回值交由Spring容器管理</td></tr><tr><td align="center">@PropertySource</td><td align="center">写在类上，用于加载外部的属性文件（如 .properties文件）</td></tr><tr><td align="center">@Import</td><td align="center">写在Java的配置类上，用于将其他的配置类导入到该配置类</td></tr></tbody></table><h4 id="5-Spring新注解详解"><a href="#5-Spring新注解详解" class="headerlink" title="(5)Spring新注解详解"></a>(5)Spring新注解详解</h4><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h5><p>​    @Configuration用于标识一个类作为配置类，Spring 容器就会自动扫描这个类，并将它作为配置类来处理。配置类是用来定义 Spring 容器中的bean 配置的，这些类通常包含了多个@Bean注解的方法，这些方法会创建并返回Spring 容器中的bean</p><p>样例：@Configuration的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;SpringConfiguration&#x2F;&#x2F;标志该类是Spring的核心配置类@Configurationpublic class SpringConfiguration&#123;&#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ComponentScan-“包名”"><a href="#ComponentScan-“包名”" class="headerlink" title="@ComponentScan(“包名”)"></a>@ComponentScan(“包名”)</h5><p>​    @ComponentScan用于指定自动扫描的包及其子包，其相当于xml文件中的组件扫描</p><p>样例：@ComponentScan(“包名”)的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;SpringConfiguration@Configuration&#x2F;&#x2F;等价于&lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&#x2F;&gt;@ComponentScan(&quot;com.itheima&quot;)public class SpringConfiguration&#123;&#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h5><p>​    @Bean用于将当前方法的返回值以当前方法名为id存储到Spring容器中，可以使用@Bean(“id”)来显示的指定存储的bean的唯一id</p><p>样例：@Bean的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;SpringConfiguration@Configuration@ComponentScan(&quot;com.itheima&quot;)public class SpringConfiguration&#123;&#x2F;&#x2F;将当前方法的返回值以id为getDataSource存储在Spring容器中@Beanpublic DataSource getDataSource() throws PropertyVetoException&#123;&#x2F;&#x2F;这里与xml文件不同的是，xml是将ComboPooledDataSource的dataSource放入Spring容器，这里是执行后的返回值ComboPooledDataSource dataSource &#x3D; new ComboPooledDataSource();        dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;);        dataSource.setUser(&quot;root&quot;);        dataSource.setPassword(&quot;root&quot;);        return dataSource;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="PropertySource-“文件路径”"><a href="#PropertySource-“文件路径”" class="headerlink" title="@PropertySource(“文件路径”)"></a>@PropertySource(“文件路径”)</h5><p>​    @PropertySource用于加载外部的属性文件（例如 .properties文件）到Spring容器中</p><p>样例：@PropertySource(“文件路径”)的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;SpringConfiguration@Configuration@ComponentScan(&quot;com.itheima&quot;)&#x2F;&#x2F;等价与：&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;@PropertySource(&quot;classpath:jdbc.properties&quot;)public class SpringConfiguration&#123;&#x2F;&#x2F;使用@value即可读取.properties文件里的信息@Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;        @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;        @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;        @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Import-“配置类的名字-class”"><a href="#Import-“配置类的名字-class”" class="headerlink" title="@Import(“配置类的名字.class”)"></a>@Import(“配置类的名字.class”)</h5><p>​    @Import用于将一个或多个外部的配置类或者资源（如 Bean 定义：bean定义会随着导入外部的配置类一起导入）导入到当前配置类中</p><p>样例：@Import(“配置类的名字.class”)的使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;SpringConfiguration@Configuration@ComponentScan(&quot;com.itheima&quot;)&#x2F;&#x2F;等价与：&lt;import resource&#x3D;&quot;applicationContext-dataSource.xml&quot;&#x2F;&gt;@Import(DataSourceConfiguration.class)&#x2F;&#x2F;多个导入：@Import(&#123;xxx.class,yyy.class,zzz.class&#125;)public class SpringConfiguration&#123;&#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-配置类来加载Spring容器对象"><a href="#6-配置类来加载Spring容器对象" class="headerlink" title="(6)配置类来加载Spring容器对象"></a>(6)配置类来加载Spring容器对象</h4><p>​    在使用applicationContext.xml文件时，是通过加载xml文件来获得Spring容器对象，而使用配置类后同样需要加载配置类</p><p>样例：配置类的加载</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;main.javapublic static void main(String[] args)&#123;&#x2F;&#x2F;获得Spring容器对象，之前用xml是：ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(applicationContext.xml);ApplicationContext app &#x3D; new AnnotationConfigApplicationContext(SpringConfiguration.class);UserService u &#x3D; app.getBean(UserService.class);u.save();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring01-Bean与IoC</title>
      <link href="/2023/04/25/Spring01-Bean%E4%B8%8EIoC/"/>
      <url>/2023/04/25/Spring01-Bean%E4%B8%8EIoC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-传统Javaweb开发的困惑与解决方案"><a href="#1-传统Javaweb开发的困惑与解决方案" class="headerlink" title="1. 传统Javaweb开发的困惑与解决方案"></a>1. 传统Javaweb开发的困惑与解决方案</h3><h5 id="问题1：传统javaweb的开发中对于数据的操作，往往都需要new对象来完成操作"><a href="#问题1：传统javaweb的开发中对于数据的操作，往往都需要new对象来完成操作" class="headerlink" title="问题1：传统javaweb的开发中对于数据的操作，往往都需要new对象来完成操作"></a>问题1：传统javaweb的开发中对于数据的操作，往往都需要new对象来完成操作</h5><p><a href="https://imgse.com/i/ppbxDFU"><img src="https://s1.ax1x.com/2023/04/10/ppbxDFU.png" alt="ppbxDFU.png"></a></p><p>​    解决思路：程序代码中不去new对象，第三方根据要求为程序提供需要的Bean对象</p><h5 id="问题2：事物功能、日志功能耦合在业务代码中"><a href="#问题2：事物功能、日志功能耦合在业务代码中" class="headerlink" title="问题2：事物功能、日志功能耦合在业务代码中"></a>问题2：事物功能、日志功能耦合在业务代码中</h5><p><a href="https://imgse.com/i/ppbxrYF"><img src="https://s1.ax1x.com/2023/04/10/ppbxrYF.png" alt="ppbxrYF.png"></a></p><p>​    解决思路：第三方提供Bean对象的**代理对象(BeanProxy)**，该对象是对Bean的增强，可以完成事物操作</p><h3 id="2-Spring程序开发步骤"><a href="#2-Spring程序开发步骤" class="headerlink" title="2. Spring程序开发步骤"></a>2. Spring程序开发步骤</h3><p>​    在jsp/servlet中，会用接口来引用接口实现的对象，来实现开发<br>​<br>​    对于Spring开发，会在xml配置文件中用id标识来绑定接口实现类全限定名，而后在service类通过Spring框架读取xml文件根据标识来获取Dao对象，如下图</p><p><a href="https://imgse.com/i/ppb9xOA"><img src="https://s1.ax1x.com/2023/04/09/ppb9xOA.png" alt="Spring开发图示"></a></p><h5 id="Spring开发步骤总结："><a href="#Spring开发步骤总结：" class="headerlink" title="Spring开发步骤总结："></a>Spring开发步骤总结：</h5><p>​    1.通过maven导入Spring开发的基本坐标<br>​    2.编写Dao接口和实现类<br>​    3.创建Spring核心配置文件，在main/resources/创建xml文件<br>​    4.在xml文件中配置UserDaoImpl<br>​    5.在service层使用Spring的API获得Bean实例(Dao)</p><h3 id="3-Spring开发的基本坐标"><a href="#3-Spring开发的基本坐标" class="headerlink" title="3. Spring开发的基本坐标"></a>3. Spring开发的基本坐标</h3><p>​    导入的基本坐标如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;            &lt;version&gt;5.0.5.RELEASE&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-Spring中的Bean"><a href="#4-Spring中的Bean" class="headerlink" title="4. Spring中的Bean"></a>4. Spring中的Bean</h3><p>​    可以把<strong>Bean</strong>看作是Spring框架中的“对象”或“组件”。简单来说，它就是在Spring容器中由Spring管理的一个类的实例。Spring框架会创建这个类的对象，并在适当的时候将它交给你使用</p><h3 id="5-Spring配置文件xml详解"><a href="#5-Spring配置文件xml详解" class="headerlink" title="5. Spring配置文件xml详解"></a>5. Spring配置文件xml详解</h3><p>​    <code>在Spring的XML配置中，XML文件实际上是代替了手动使用new关键字来创建对象</code></p><h5 id="模板如下："><a href="#模板如下：" class="headerlink" title="模板如下："></a>模板如下：</h5><p>​    需要使用Spring的xml进行生成xml文件才能获得模板</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;        &lt;bean id&#x3D;&quot;唯一标识&quot; class&#x3D;&quot;类的全限定名&quot;&gt;&lt;&#x2F;bean&gt;    &lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-Bean标签的最简配置"><a href="#1-Bean标签的最简配置" class="headerlink" title="(1)Bean标签的最简配置"></a>(1)Bean标签的最简配置</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"唯一标识"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"类的全限定名"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span> <span class="token comment">//class是bean的基本属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功</p><h4 id="2-Bean标签的范围配置"><a href="#2-Bean标签的范围配置" class="headerlink" title="(2)Bean标签的范围配置"></a>(2)Bean标签的范围配置</h4><p>​    属性<code>scope</code>：指对象的作用范围，取值如下：</p><table><thead><tr><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>singleton</strong></td><td align="center"><strong>默认值，单例</strong></td></tr><tr><td align="center"><strong>prototype</strong></td><td align="center"><strong>多例</strong></td></tr><tr><td align="center">request</td><td align="center">WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中</td></tr><tr><td align="center">session</td><td align="center">WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中</td></tr><tr><td align="center">global session</td><td align="center">WEB项目中，应用在Portlet环境，如果没有Portlet环境那么global session相当于session</td></tr></tbody></table><h5 id="单例和多例的区别："><a href="#单例和多例的区别：" class="headerlink" title="单例和多例的区别："></a>单例和多例的区别：</h5><p>​    单例是不管getBean(“id”)获取几次，都是同一地址的对象，多例获取几次，就创造几个对象，详细如下图所示</p><p><a href="https://imgse.com/i/ppb8rIf"><img src="https://s1.ax1x.com/2023/04/09/ppb8rIf.png" alt="单例和多例的区别"></a> </p><h4 id="3-与Bean生命周期有关的方法"><a href="#3-与Bean生命周期有关的方法" class="headerlink" title="(3)与Bean生命周期有关的方法"></a>(3)与Bean生命周期有关的方法</h4><p>​    属性<code>init-method</code>：指定类的初始化时执行的方法<br>​    属性<code>destroy-method</code>：指定类的销毁时执行的方法<br>​<br>​    这些要指定的方法需要在接口实现类中编写，在使用bean标签时指定</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"唯一标识"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"类的全限定名"</span> init<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"bean初始化要执行的方法名"</span> destroy<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"bean销毁时要执行的方法名"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    bean的创建是在main函数中用Spring的API创建</p><h4 id="4-Bean的实例化-如何创建-三种方法"><a href="#4-Bean的实例化-如何创建-三种方法" class="headerlink" title="(4)Bean的实例化(如何创建)三种方法"></a>(4)Bean的实例化(如何创建)三种方法</h4><h5 id="通过无参构造方法实例化"><a href="#通过无参构造方法实例化" class="headerlink" title="通过无参构造方法实例化"></a>通过无参构造方法实例化</h5><p>​    Spring默认使用无参构造器来实例化Bean，Spring容器会自动通过<code>new</code>操作符创建一个Bean对象，然后填充它的属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//MyBean.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBean</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyBean constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//applicationContext.xml</span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"myBean"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.example.MyBean"</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="通过-工厂-静态方法实例化：需要使用属性factory-method"><a href="#通过-工厂-静态方法实例化：需要使用属性factory-method" class="headerlink" title="通过(工厂)静态方法实例化：需要使用属性factory-method"></a>通过(工厂)静态方法实例化：需要使用属性factory-method</h5><p>​    工厂方法是在类中定义的一个静态方法或实例方法，用于返回该类的Bean对象</p><p>​    <code>factory-method</code>属性用于指向<code>静态工厂方法</code>或指向<code>实例方法</code>来创建Bean，该方法将由Spring容器调用来实例化Bean</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//MyBean.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBean</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyBean constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">MyBean</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//applicationContext.xml</span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"myBean"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.example.MyBean"</span> factory<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"createInstance"</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="通过工厂类实例化：需要使用属性factory-bean、factory-method"><a href="#通过工厂类实例化：需要使用属性factory-bean、factory-method" class="headerlink" title="通过工厂类实例化：需要使用属性factory-bean、factory-method"></a>通过工厂类实例化：需要使用属性factory-bean、factory-method</h5><p>​    <code>factory-bean</code>：通过一个工厂Bean来实例化Bean，工厂Bean中的方法负责创建Bean实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//MyBean.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBean</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyBean constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//MyBeanFactory.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">MyBean</span> <span class="token function">createMyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//applicationContext.xml</span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"myBeanFactory"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.example.MyBeanFactory"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"myBean"</span> factory<span class="token operator">-</span>bean<span class="token operator">=</span><span class="token string">"myBeanFactory"</span> factory<span class="token operator">-</span>method<span class="token operator">=</span><span class="token string">"createMyBean"</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    当前重点还是深入了解无参构造方法实例化</p><h3 id="6-Bean的依赖注入-DI-：用于实现控制反转（IoC）"><a href="#6-Bean的依赖注入-DI-：用于实现控制反转（IoC）" class="headerlink" title="6. Bean的依赖注入(DI)：用于实现控制反转（IoC）"></a>6. Bean的依赖注入(DI)：用于实现控制反转（IoC）</h3><p>​    依赖注入是指在对象的创建和管理过程中，Spring容器会自动将需要的依赖（其他Bean）注入到当前Bean中，而不需要手动创建这些依赖对象，依赖主要是当前对象需要调用依赖对象提供的方法</p><h4 id="1-非依赖注入：需要的依赖从spring容器外部获取"><a href="#1-非依赖注入：需要的依赖从spring容器外部获取" class="headerlink" title="(1)非依赖注入：需要的依赖从spring容器外部获取"></a>(1)非依赖注入：需要的依赖从spring容器外部获取</h4><p>​    该方式也使用了spring容器，但与传统只是把new对象变为了对象由spring管理，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;Dao层public class UserDaoImpl implements UserDao&#123;public void save()&#123;System.out.println(&quot;save running...&quot;)&#125;&#125;&#x2F;&#x2F;service层public class UserServiceImpl implements UserService&#123;public void save()&#123;ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&#x2F;&#x2F;外部获取spring管理的容器UserDao userDao &#x3D; (UserDao) app.getBean(&quot;userDao&quot;);userDao.save();&#125;&#125;&#x2F;&#x2F;controller层public class UserController&#123;public static void main(String[] args)&#123;ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService &#x3D; (UserService)app.getBean(&quot;userService&quot;);userService.save();&#125;&#125;&#x2F;&#x2F;applicationContext.xml&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-依赖注入：需要的依赖从spring容器内部注入-两种注入方法"><a href="#2-依赖注入：需要的依赖从spring容器内部注入-两种注入方法" class="headerlink" title="(2)依赖注入：需要的依赖从spring容器内部注入(两种注入方法)"></a>(2)依赖注入：需要的依赖从spring容器内部注入(两种注入方法)</h4><p>​    依赖注入是Spring框架核心IoC的具体实现</p><h5 id="第一种：使用set方法注入（最常用）"><a href="#第一种：使用set方法注入（最常用）" class="headerlink" title="第一种：使用set方法注入（最常用）"></a>第一种：使用set方法注入（最常用）</h5><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>​    1.创建DAO或其他Bean，需要被注入到Service层</p><p>​    2.在Service层提供一个set方法，用于接收外部Bean的注入</p><p>​    3.在Controller层调用Service层的方法</p><h5 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h5><p>​    与非依赖注入的代码相比改的都是service层和xml文件</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;Dao层public class UserDaoImpl implements UserDao&#123;public void save()&#123;System.out.println(&quot;save running...&quot;)&#125;&#125;&#x2F;&#x2F;service层public class UserServiceImpl implements UserService&#123;private UserDao userDao;&#x2F;&#x2F;该方法名用于注入时使用public void setUserDao(UserDao userDao)&#123;this.userDao &#x3D; userDao;&#125;public void save()&#123;userDao.save();&#125;&#125;&#x2F;&#x2F;controller层public class UserController&#123;public static void main(String[] args)&#123;ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService &#x3D; (UserService)app.getBean(&quot;userService&quot;);userService.save();&#125;&#125;&#x2F;&#x2F;applicationContext.xml&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;&#x2F;**name的值是上面setUserDao去掉set且第一个字母变小写ref用于引用对象，这里引用的时userDao的唯一标识id*&#x2F;&lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="第二种：使用有参构造方法注入："><a href="#第二种：使用有参构造方法注入：" class="headerlink" title="第二种：使用有参构造方法注入："></a>第二种：使用有参构造方法注入：</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;Dao层public class UserDaoImpl implements UserDao&#123;public void save()&#123;System.out.println(&quot;save running...&quot;)&#125;&#125;&#x2F;&#x2F;service层public class UserServiceImpl implements UserService&#123;private UserDao userDao;&#x2F;&#x2F;构造方法实现public UserServiceImpl(UserDao userDao)&#123;this.userDao &#x3D; userDao;&#125;&#x2F;&#x2F;补充无参构造public UserServiceImpl()&#123;&#125;public void save()&#123;userDao.save();&#125;&#125;&#x2F;&#x2F;controller层public class UserController&#123;public static void main(String[] args)&#123;ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService &#x3D; (UserService)app.getBean(&quot;userService&quot;);userService.save();&#125;&#125;&#x2F;&#x2F;applicationContext.xml&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;&#x2F;**name的值是上面UserServiceImpl构造方法的形参名ref用于引用对象，这里引用的时userDao的唯一标识id*&#x2F;&lt;constructor-arg name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-Bean依赖注入的数据类型"><a href="#7-Bean依赖注入的数据类型" class="headerlink" title="7. Bean依赖注入的数据类型"></a>7. Bean依赖注入的数据类型</h3><p>​    在spring中，除对象的引用可以注入，普通数据类型、集合都可以在容器中进行注入(用set或者构造方法)</p><h4 id="1-普通数据类型的注入（set方式）"><a href="#1-普通数据类型的注入（set方式）" class="headerlink" title="(1)普通数据类型的注入（set方式）"></a>(1)普通数据类型的注入（set方式）</h4><h5 id="样例：String、int的注入"><a href="#样例：String、int的注入" class="headerlink" title="样例：String、int的注入"></a>样例：String、int的注入</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;Dao层public class UserDaoImpl implements UserDao&#123;private String username;private int age;public void setUsername(String username)&#123;this.username &#x3D; username;&#125;public void setAge(int age)&#123;this.age &#x3D; age;&#125;public void printUser()&#123;System.out.println(username);System.out.println(age);&#125;&#125;&#x2F;&#x2F;applicationContext.xml&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;张三&quot;&#x2F;&gt;&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-集合的注入（set方式）"><a href="#2-集合的注入（set方式）" class="headerlink" title="(2)集合的注入（set方式）"></a>(2)集合的注入（set方式）</h4><h5 id="样例：List、map、properties的注入"><a href="#样例：List、map、properties的注入" class="headerlink" title="样例：List、map、properties的注入"></a>样例：List、map、properties的注入</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;Dao层public class UserDaoImpl implements UserDao&#123;private List&lt;String&gt; strList;private Map&lt;String,User&gt; userMap;private Properties properties;public void setStrList(List&lt;String&gt; strList)&#123;this.strList &#x3D; strList;&#125;public void setUserMap(Map&lt;String,User&gt; userMap)&#123;this.userMap &#x3D; userMap;&#125;public void setProperties(Properties properties)&#123;this.properties &#x3D; properties;&#125;public void printAll()&#123;System.out.println(strList);System.out.println(userMap);System.out.println(properties);&#125;&#125;&#x2F;&#x2F;applicationContext.xml&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;property name&#x3D;&quot;strList&quot;&gt;&lt;List&gt;&lt;value&gt;hello&lt;&#x2F;value&gt;&lt;value&gt;world&lt;&#x2F;value&gt;&lt;&#x2F;List&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;userMap&quot;&gt;&lt;map&gt;&#x2F;&#x2F;key随便指定，ref注入的对象一定要在容器中&lt;entry key&#x3D;&quot;u1&quot; value-ref&#x3D;&quot;user1&quot;&gt;&lt;&#x2F;entry&gt;&lt;&#x2F;map&gt;&lt;&#x2F;property&gt;&lt;property name&#x3D;&quot;properties&quot;&gt;&lt;props&gt;&#x2F;&#x2F;key随便指定&lt;prop key&#x3D;&quot;p1&quot;&gt;ppp1&lt;&#x2F;prop&gt;&lt;prop key&#x3D;&quot;p2&quot;&gt;ppp2&lt;&#x2F;prop&gt;&lt;&#x2F;props&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&#x2F;&#x2F;用于演示ref引用使用&lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;com.itheima.domain.User&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-Spring中xml文件的分模块开发"><a href="#8-Spring中xml文件的分模块开发" class="headerlink" title="8. Spring中xml文件的分模块开发"></a>8. Spring中xml文件的分模块开发</h3><p>​    项目中的不同xml模块需要拆分，此时要在主配置文件引入这些模块，<code>需要使用import标签进行加载</code></p><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token keyword">import</span> <span class="token namespace">resource</span><span class="token operator">=</span><span class="token string">"applicationContext-xxx.xml"</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    resource属性值为要引入的Spring配置文件的位置</p><p>​    当主文件加载时，分文件也会被加载</p><h5 id="样例图示："><a href="#样例图示：" class="headerlink" title="样例图示："></a>样例图示：</h5><p><a href="https://imgse.com/i/ppLLaXq"><img src="https://s1.ax1x.com/2023/04/11/ppLLaXq.png" alt="xml文件的分模块开发"></a></p><h3 id="9-Spring相关API"><a href="#9-Spring相关API" class="headerlink" title="9. Spring相关API"></a>9. Spring相关API</h3><h4 id="1-ApplicationContext接口与它的实现类：用于获得Spring容器对象"><a href="#1-ApplicationContext接口与它的实现类：用于获得Spring容器对象" class="headerlink" title="(1)ApplicationContext接口与它的实现类：用于获得Spring容器对象"></a>(1)ApplicationContext接口与它的实现类：用于获得Spring容器对象</h4><p>​    applicationContext：接口类型，可以通过其来接Spring容器对象</p><p>​    </p><h5 id="ApplicationContext的实现类：获取Spring容器对象的三种方式"><a href="#ApplicationContext的实现类：获取Spring容器对象的三种方式" class="headerlink" title="ApplicationContext的实现类：获取Spring容器对象的三种方式"></a>ApplicationContext的实现类：获取Spring容器对象的三种方式</h5><p>​    1.ClassPathXmlApplicationContext(“参数为resource文件夹的xml文件路径”)：它是从类的根路径下加载配置文件（常用）</p><p>​    2.FileSystemXmlApplicationContext(“参数为xml文件在电脑中的磁盘路径”)：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置</p><p>​    3.AnnotationConfigApplicationContext：当使用注解配置容器对象时，需要使用此类来创建spring容器，它用来读取注解</p><h4 id="2-getBean-方法"><a href="#2-getBean-方法" class="headerlink" title="(2)getBean()方法"></a>(2)getBean()方法</h4><p>​    getBean()有两个常用的API，一个是按id在spring容器中找，还要一个是按类型在spring容器中找</p><p>​    官方文档见下图：</p><p><a href="https://imgse.com/i/ppLjplj"><img src="https://s1.ax1x.com/2023/04/11/ppLjplj.png" alt="getBean()的API"></a></p><h5 id="第一个API："><a href="#第一个API：" class="headerlink" title="第一个API："></a>第一个API：</h5><blockquote><p>app.getBean(“id”)</p></blockquote><p>​    传递的参数是xml文件中设置的id值，其允许spring容器中出现相同类型的bean因为可以用id进行区分</p><h5 id="第二个API"><a href="#第二个API" class="headerlink" title="第二个API"></a>第二个API</h5><blockquote><p>app.getBean(Class)</p></blockquote><p>​    传递的参数是字节码对象类型(xxxx.class)，其只允许spring容器中有一种类型的bean</p><h5 id="两种相同效果的代码编写图示："><a href="#两种相同效果的代码编写图示：" class="headerlink" title="两种相同效果的代码编写图示："></a>两种相同效果的代码编写图示：</h5><p><a href="https://imgse.com/i/ppLjXuR"><img src="https://s1.ax1x.com/2023/04/11/ppLjXuR.png" alt="两种写法相同实现的比对"></a></p><p>​    这个UserService是接口类，等于是获得接口类的反射</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构05</title>
      <link href="/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8405/"/>
      <url>/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8405/</url>
      
        <content type="html"><![CDATA[<h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><h4 id="1-队列的概念"><a href="#1-队列的概念" class="headerlink" title="1. 队列的概念"></a>1. 队列的概念</h4><p>​    一种可以实现“先进先出”的存储结构，不能在中间插入，只能在一端入，另一端出，入的那端不能出，出的那端不能入</p><h4 id="2-队列的分类"><a href="#2-队列的分类" class="headerlink" title="2.队列的分类"></a>2.队列的分类</h4><ul><li><p>链式队列    –用链表实现</p></li><li><p>数组队列    –用动态数组实现、</p><p>​    使用数组来实现队列通常都必须是循环队列</p></li></ul><p>​    规定：在队首(front)删除元素，在队尾(rear)加入元素，定义两个变量：front指向队首的第一个元素，rear指向队尾元素的下一个元素</p><p>​    图示如下：</p><p><a href="https://imgse.com/i/z8QyZR"><img src="https://s1.ax1x.com/2022/11/23/z8QyZR.png" alt="z8QyZR.png"></a></p><p>​    注意：错开设置是为了方便对队列进行操作，就像链表pHead指向第一个元素的前一个不存储数据的头结点，pTail指向最后一个结点一样</p><h4 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h4><p><strong>(1). 使用数组来实现队列为什么必须为循环队列</strong></p><p>​     当插入元素或者删除元素时，front和rear都是向后移动，此时前面的数组空间都无法使用即被浪费了，所以需要使用循环队列来减少空间浪费</p><p>​    当front或rear指向最后一个元素，且还要再往后移时，此时需要将其指向第一个元素，这样的设计就是一个循环队列</p><p><strong>(2).循环队列需要几个参数来确定，以及参数的含义</strong></p><p>​    需要两个参数来确定：front、rear</p><p>​    这两个参数不同场合有不同的含义</p><ol><li><p>队列初始化</p><p>front和rear的值都是0</p></li><li><p>队列非空</p><p>front代表队列的第一个元素</p><p>rear代表队列的最后一个有效元素的下一个元素</p></li><li><p>队列空</p><p>front和rear的值相等，但不一定就是为0</p></li></ol><p><strong>(3).循环队列入队的伪算法</strong></p><ol><li><p>将值存入rear所指向的位置</p></li><li><p>rear = (rear + 1)%数组的长度</p></li></ol><p><strong>(4).循环队列出队的伪算法</strong></p><p>​    front = (front + 1)%数组长度</p><p><strong>(5).循环队列判断队列为空的伪算法</strong></p><p>​    如果front与rear的值相等，则该队列就一定为空</p><p><strong>(6).循环队列判断队列为满的伪算法</strong></p><p>​    <strong>两种方法：</strong></p><p>​    1. 设定一个len变量来记录数组中有效数据的长度，当达到数组长度时，则拒绝继续添加</p><p>​    <strong>2. 设定：数组中有n个元素，若已经放了n-1个元素，那么数组就已经满了(一般使用第二种方法)</strong></p><p>​    <strong>第二种方法的判断条件</strong></p><p>​    如果<code>front == (rear + 1)%数组长度</code>，则队列已满</p><h4 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h4><ol><li><p>队列的定义以及初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//结构体定义队列</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Queue</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pBase<span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">;</span>    <span class="token keyword">int</span> rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>QUEUE<span class="token punctuation">,</span><span class="token operator">*</span>PQUEUE<span class="token punctuation">;</span><span class="token comment">//队列的初始化</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//函数声明</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//函数体</span>    pQ<span class="token operator">-></span>pBase <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pQ<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pQ<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p>队满的判断，以及队列的入队操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//判断队列是否为满</span>bool <span class="token function">full_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">full_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pQ<span class="token operator">-></span>front <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pQ<span class="token operator">-></span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//入队操作</span>bool <span class="token function">en_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">en_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">full_queue</span><span class="token punctuation">(</span>pQ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pQ<span class="token operator">-></span>pBase<span class="token punctuation">[</span>pQ<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    pQ<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>pQ<span class="token operator">-></span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="3"><li><p>队列的遍历操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">traverse_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">traverse_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pQ<span class="token operator">-></span>front<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>pQ<span class="token operator">-></span>rear<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>pQ<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">6</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="4"><li><p>队列判断为空以及出队操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">empty_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">empty_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pQ<span class="token operator">-></span>front<span class="token operator">==</span>pQ<span class="token operator">-></span>rear<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">out_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">out_queue</span><span class="token punctuation">(</span>PQUEUE pQ<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty_queue</span><span class="token punctuation">(</span>pQ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">*</span>val <span class="token operator">=</span> pQ<span class="token operator">-></span>pBase<span class="token punctuation">[</span>pQ<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    pQ<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token punctuation">(</span>pQ<span class="token operator">-></span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="5"><li><p>mian函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QUEUE Q<span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">en_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"true\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">;</span>    <span class="token function">en_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">en_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">en_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">en_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">en_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">en_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">out_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nok,the num is %d"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="5-队列的具体应用"><a href="#5-队列的具体应用" class="headerlink" title="5. 队列的具体应用"></a>5. 队列的具体应用</h4><p>​    所有和时间有关的操作都有队列的影子</p><p>​    比如：像操作系统里有等待队列，线程有阻塞队列</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL复习03</title>
      <link href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A003/"/>
      <url>/2022/11/21/MySQL%E5%A4%8D%E4%B9%A003/</url>
      
        <content type="html"><![CDATA[<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h4 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="1. 多表关系"></a>1. 多表关系</h4><p>​    在数据库表结构设计时，一般各个表结构之间存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><p>​    <strong>一对多(多对一)</strong></p><p>​    案例：部门与员工的关系</p><p>​    关系：一个部门对应多个员工，一个员工对应一个部门</p><p>​    实现：在多的一方建立外键。指向一的一方的主键</p><p><a href="https://imgse.com/i/zVAki4"><img src="https://s1.ax1x.com/2022/11/15/zVAki4.png" alt="zVAki4.png"></a></p><p>​    <strong>多对多</strong></p><p>​    案例：学生与课程的关系</p><p>​    关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p><p>​    实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><p><a href="https://imgse.com/i/zVAEW9"><img src="https://s1.ax1x.com/2022/11/15/zVAEW9.png" alt="zVAEW9.png"></a></p><p>​    <strong>一对一</strong></p><p>​    案例：用户与用户详情的关系</p><p>​    关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中，以提升操作效率</p><p>​    实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><p><a href="https://imgse.com/i/zVEvD0"><img src="https://s1.ax1x.com/2022/11/15/zVEvD0.png" alt="zVEvD0.png"></a></p><h4 id="2-多表查询概述"><a href="#2-多表查询概述" class="headerlink" title="2. 多表查询概述"></a>2. 多表查询概述</h4><p>​    指从多张表中查询数据</p><pre><code> 笛卡尔积</code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp<span class="token punctuation">,</span>dept<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    笛卡尔积：两个集合，A集合和B集合的所有组合情况(在多表查询时，需要消除无效的笛卡尔积)</p><p>​    通过where语句可以消除无效的笛卡尔积，但不满足where的数据也会被消除掉</p><p>​    多表查询的分类</p><ul><li>连接查询<ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li>子查询</li></ul><h4 id="3-内连接"><a href="#3-内连接" class="headerlink" title="3. 内连接"></a>3. 内连接</h4><p>​    内连接查询的是两张表的交集部分</p><p>​    内连接查询语法</p><ul><li><p>隐式内连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span><span class="token punctuation">,</span>表<span class="token number">2</span> <span class="token keyword">WHERE</span> 条件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>显示内连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token punctuation">[</span><span class="token keyword">INNER</span><span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 连接条件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> 筛选条件<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​    范例：内连接的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 表结构：emp,dept</span><span class="token comment">-- 连接条件：emp.dept_id = dept.id</span><span class="token comment">-- 查询每一个员工的姓名，以及关联的部门的名称(隐式内连接实现)</span><span class="token keyword">SELECT</span> emp<span class="token punctuation">.</span>name<span class="token punctuation">,</span>dept<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">WHERE</span> emp<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> dept_id<span class="token punctuation">;</span><span class="token comment">//如果表名太长可以起别名，但起别名之后WHERE后面的使用字段必须要用别名来引用，不可以用表原名引用</span><span class="token comment">-- 查询每一个员工的姓名。及关联的部门的名称(显示内连接实现)</span><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>name<span class="token punctuation">,</span> d<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> emp e <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dept d <span class="token keyword">on</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment">//INNER关键字是可以省略的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：隐式和显式只是语法不同，查询结果是相同的</p><h4 id="4-外连接"><a href="#4-外连接" class="headerlink" title="4. 外连接"></a>4. 外连接</h4><p>​    外连接查询语法</p><ul><li><p>左外连接：查询左表(表1)所有数据，以及两张表交集部分数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token keyword">LEFT</span> <span class="token punctuation">[</span><span class="token keyword">OUTER</span><span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> 条件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>右外连接：查询右表(表2)所有数据，以及两张表交集部分数据</p><pre class="line-numbers language-none"><code class="language-none">SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​    范例：外连接的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 表结构：emp,dept</span><span class="token comment">-- 连接条件：emp.dept_id = dept.id</span><span class="token comment">-- 1.查询emp表的所有数据，和对应的部门信息(左外连接)</span><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>d<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> emp e <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> dept d <span class="token keyword">ON</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment">//OUTER关键字可以省略</span><span class="token comment">-- 2.查询dept表的所有数据，和对应的员工信息(右外连接)</span><span class="token keyword">SELECT</span> d<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> emp e <span class="token keyword">RIGHT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> dept d <span class="token keyword">ON</span> e<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：一般开发中左外连接用的多，因为右外连接可以转化为左外连接</p><h4 id="4-自连接"><a href="#4-自连接" class="headerlink" title="4. 自连接"></a>4. 自连接</h4><p>​    自连接查询语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表A 别名A <span class="token keyword">JOIN</span> 表A 别名B <span class="token keyword">ON</span> 条件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    自连接可以是内连接也可以是外连接</p><p>​    范例：自连接的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 表结构：emp</span><span class="token comment">-- 1.查询员工及其所属领导的名字</span><span class="token keyword">SELECT</span> a<span class="token punctuation">.</span>name<span class="token punctuation">,</span>b<span class="token punctuation">.</span>name <span class="token keyword">FROM</span> emp a<span class="token punctuation">,</span> emp b <span class="token keyword">WHERE</span> a<span class="token punctuation">.</span>managerid <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token comment">-- 2.查询所有员工及其领导的名字，如果员工没有领导，也需要查询出来</span><span class="token keyword">SELECT</span> a<span class="token punctuation">.</span>name <span class="token string">'员工'</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>name <span class="token string">'领导'</span> <span class="token keyword">FROM</span> emp a <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> emp b <span class="token keyword">ON</span> a<span class="token punctuation">.</span>managerid <span class="token operator">=</span> b<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-联合查询"><a href="#5-联合查询" class="headerlink" title="5. 联合查询"></a>5. 联合查询</h4><p>​    联合查询是将多次查询的结果合并起来，形成一个新的查询结果集</p><p>​    联合查询的语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表A<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UNION</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span><span class="token punctuation">]</span><span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表B<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</p><p>​    范例：联合查询的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 1.将薪资低于5000的员工和年龄大于50岁的员工全部查询出来</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> salary <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> age <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    联合查询将这两次查询的结果合并在一起显示</p><p>​    <strong>注意：<code>UNION ALL</code>会将查到的全部数据直接合并在一起，<code>UNION</code>会对合并之后的数据去重</strong></p><h4 id="6-子查询概念"><a href="#6-子查询概念" class="headerlink" title="6. 子查询概念"></a>6. 子查询概念</h4><p>​    SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询</p><p>​    子查询的语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> <span class="token keyword">column</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    注意：子查询外部的语句可以是INSERT、UPDATE、DELETE、SELECT的任意一个</p><p>​    根据子查询结果的不同，将子查询分类为：</p><ul><li>标量子查询(子查询结果为单个值)</li><li>列子查询(子查询结果为一列)</li><li>行子查询(子查询结果为一行)</li><li>表子查询(子查询结果为多行多列)</li></ul><p>​    根据子查询的位置，将子查询分类为：</p><ul><li>WHERE之后</li><li>FROM之后</li><li>SELECT之后</li></ul><h4 id="7-标量子查询"><a href="#7-标量子查询" class="headerlink" title="7. 标量子查询"></a>7. 标量子查询</h4><p>​    子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询</p><p>​    常见的操作符：<code>=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></p><p>​    范例：标量子查询的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 1.查询“销售部”的所有员工信息</span><span class="token comment">-- a.查询“销售部”部门ID</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'销售部'</span><span class="token punctuation">;</span><span class="token comment">-- b.根据销售部部门ID，查询员工信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">--通过子查询将a与b写为一条语句</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'销售部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-列子查询"><a href="#8-列子查询" class="headerlink" title="8. 列子查询"></a>8. 列子查询</h4><p>​    子查询返回的结果是一列(即多行)，这种子查询称为列子查询</p><p>​    常用操作符：IN、NOT IN、ANY、SOME、ALL</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">在指定的集合范围之内，多选一</td></tr><tr><td align="center">NOT IN</td><td align="center">不在指定的集合范围之内</td></tr><tr><td align="center">ANY</td><td align="center">子查询返回列表中，有任意一个满足即可</td></tr><tr><td align="center">SOME</td><td align="center">与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td align="center">ALL</td><td align="center">子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>​    范例：列子查询的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 1.查询“销售部”和“市场部”的所有员工信息</span><span class="token comment">-- a.查询“销售部”和“市场部”的部门ID</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'销售部'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'市场部'</span><span class="token punctuation">;</span><span class="token comment">-- b.根据部门ID查询员工信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 将a,b写为一条语句</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'销售部'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'市场部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 2.查询比财务部所有人工资都高的员工信息</span><span class="token comment">-- a.查询财务部所有人员的工资</span><span class="token keyword">SELECT</span> salary <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> name <span class="token operator">=</span><span class="token string">'财务部'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- b.比财务部所有人工资都高的员工信息,与a结合</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> salary <span class="token operator">></span> <span class="token keyword">ALL</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> salary <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> name <span class="token operator">=</span><span class="token string">'财务部'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 3.查询比研发部任意一个人工资高的员工信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> salary <span class="token operator">></span> <span class="token keyword">ANY</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> salary <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> dept_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> name <span class="token operator">=</span><span class="token string">'研发部'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-行子查询"><a href="#9-行子查询" class="headerlink" title="9. 行子查询"></a>9. 行子查询</h4><p>​    子查询返回的结果是一行(即多列)，这种子查询称为行子查询</p><p>​    常用的操作符：=、&lt;&gt;、IN、NOT IN</p><p>​    范例：行子查询的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 1.查询与“张三”的薪资及直属领导相同的员工信息</span><span class="token comment">-- a.张无忌的薪资及直属领导</span><span class="token keyword">SELECT</span> salary<span class="token punctuation">,</span>managerid <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'张无忌'</span><span class="token punctuation">;</span><span class="token comment">-- b.查询与“张无忌”的薪资及直属领导相同的员工信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>salary<span class="token punctuation">,</span>managerid<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 将a,b写为一条语句</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>salary<span class="token punctuation">,</span>managerid<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> salary<span class="token punctuation">,</span>managerid <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'张无忌'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-表子查询"><a href="#10-表子查询" class="headerlink" title="10. 表子查询"></a>10. 表子查询</h4><p>​    子查询返回的结果是多行多列，这种子查询称为表子查询，一般放在FROM之后，把查询结果作为一张临时表在和其他表联合查询，也会放在WHERE后面使用IN来完成查找</p><p>​    常用操作符：IN</p><p>​    范例：表子查询的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 1.查询与“张三”，“李四”的职位和薪资相同的员工信息</span><span class="token comment">-- a.查询“张三”，“李四”的职位和薪资</span><span class="token keyword">SELECT</span> job<span class="token punctuation">,</span>salary <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'张三'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'李四'</span><span class="token punctuation">;</span><span class="token comment">-- b.查询与“张三”，“李四”的职位和薪资相同的员工信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>job<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> job<span class="token punctuation">,</span>salary <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'张三'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 2.查询入职日期是“2006-01-01”之后的员工信息，及其部门信息</span><span class="token comment">-- a.入职日期是“2006-01-01”之后的员工信息</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> entrydate<span class="token operator">></span><span class="token string">'2006-01-01'</span><span class="token punctuation">;</span><span class="token comment">-- b.查询这部分员工对应的部门信息，因为如果部门为空也要查询出来，所以要用到左外连接</span><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>d<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp <span class="token keyword">WHERE</span> entrydate<span class="token operator">></span><span class="token string">'2006-01-01'</span><span class="token punctuation">)</span> e <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> dept d <span class="token keyword">ON</span> e<span class="token punctuation">.</span>dept_id<span class="token operator">=</span>d<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL复习02</title>
      <link href="/2022/11/21/MySQL%E5%A4%8D%E4%B9%A002/"/>
      <url>/2022/11/21/MySQL%E5%A4%8D%E4%B9%A002/</url>
      
        <content type="html"><![CDATA[<h2 id="函数与约束"><a href="#函数与约束" class="headerlink" title="函数与约束"></a>函数与约束</h2><h4 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h4><p>​    MySQL中内置了很多字符串函数，常见的如下表：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">concat(S1,S2,…,Sn)</td><td align="center">字符串拼接，将(S1,S2,…,Sn)拼接为一个字符串</td></tr><tr><td align="center">lower(str)</td><td align="center">将字符串str全部转为小写</td></tr><tr><td align="center">upper(str)</td><td align="center">将字符串str全部转为大写</td></tr><tr><td align="center">lpad(str,n,pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td align="center">rpad(str,n,pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td align="center">trim(str)</td><td align="center">去掉字符串头部和尾部空格</td></tr><tr><td align="center">substring(str,start,len)</td><td align="center">返回从字符串str从start位置起的len长度的字符串，<strong>索引值是从1开始</strong></td></tr></tbody></table><p>​    <strong>注意：str可以传类型是字符串的列名</strong></p><p>​    范例：字符串函数的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- concat</span><span class="token keyword">SELECT</span> concat<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--lower</span><span class="token keyword">SELECT</span> lower<span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--upper</span><span class="token keyword">SELECT</span> upper<span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--lpad</span><span class="token keyword">SELECT</span> lpad<span class="token punctuation">(</span><span class="token string">'01'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--rpad</span><span class="token keyword">SELECT</span> rpad<span class="token punctuation">(</span><span class="token string">'01'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--trim</span><span class="token keyword">SELECT</span> trim<span class="token punctuation">(</span><span class="token string">' hello world '</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--substring</span><span class="token keyword">SELECT</span> substring<span class="token punctuation">(</span><span class="token string">'12345'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//索引值从1开始</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h4><p>​    常见的数值函数如下表：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">ceil(x)</td><td align="center">向上取整</td></tr><tr><td align="center">floor(x)</td><td align="center">向下取整</td></tr><tr><td align="center">mod(x,y)</td><td align="center">返回x/y的模</td></tr><tr><td align="center">rand()</td><td align="center">返回0~1内的随机数</td></tr><tr><td align="center">round(x,y)</td><td align="center">得参数x的整体进行四舍五入的值，保留y位小数</td></tr></tbody></table><p>​    范例：数值函数的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ceil</span><span class="token keyword">SELECT</span> ceil<span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果2</span><span class="token comment">-- floor</span>SELSECT floor<span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span> <span class="token comment">//结果1</span><span class="token comment">-- mod</span>SELSET <span class="token function">mod</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//3除4的余数，结果3</span><span class="token comment">--rand</span><span class="token keyword">SELECT</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//0~1随机数</span><span class="token comment">--round</span><span class="token keyword">SELECT</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token number">2.345</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结果2.35</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：生成的数字可以作为字符串参与上面字符串函数中</p><h4 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h4><p>​    常见日期函数如下：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">curdate()</td><td align="center">返回当前日期</td></tr><tr><td align="center">curtime()</td><td align="center">返回当前时间</td></tr><tr><td align="center">now()</td><td align="center">返回当前日期和时间，<strong>即返回的是date类型</strong></td></tr><tr><td align="center">year(date)</td><td align="center">获取指定date的年份</td></tr><tr><td align="center">month(date)</td><td align="center">获取指定date的月份</td></tr><tr><td align="center">day(date)</td><td align="center">获取指定date的日期</td></tr><tr><td align="center">date_add(date,interval expr type)</td><td align="center">在指定日期下增加一个时间间隔，返回该时间值</td></tr><tr><td align="center">datediff(date1,date2)</td><td align="center">返回起始时间date1和结束时间date2之间的天数，结果为date1-date2</td></tr></tbody></table><p>​    范例：日期函数的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- curdate</span><span class="token keyword">SELECT</span> curdate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果2022-11-14</span><span class="token comment">-- curtime</span><span class="token keyword">SELECT</span> curtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果9:29:15</span><span class="token comment">-- now</span><span class="token keyword">SELECT</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果2022-11-14 9:29:54</span><span class="token comment">-- year</span><span class="token keyword">SELECT</span> <span class="token keyword">year</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结果2022</span><span class="token comment">-- month</span><span class="token keyword">SELECT</span> <span class="token keyword">month</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果11</span><span class="token comment">-- day</span><span class="token keyword">SELECT</span> <span class="token keyword">day</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果14</span><span class="token comment">--date_add</span><span class="token keyword">SELECT</span> date_add<span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">INTERVAL</span> <span class="token number">10</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果2022-11-24 10:05:31</span><span class="token comment">-- datediff</span><span class="token keyword">SELECT</span> datediff<span class="token punctuation">(</span><span class="token string">'2022-12-01'</span><span class="token punctuation">,</span><span class="token string">'2022-11-1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 结果<span class="token number">30</span>，注意如果前小后大则值为负数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4. 流程函数"></a>4. 流程函数</h4><p>​    流程函数在SQL语句中实现条件筛选，从而提高语句的效率</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">if(value,t,f)</td><td align="center">如果value为true，则返回true否则返回f</td></tr><tr><td align="center">ifnull(value1,value2)</td><td align="center">判定第一个参数是否为空，即如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="center">case [表中字段] when [val] then [res1]…else [default] end</td><td align="center">如果val1与表中数据判断为true返回res1,…(可以写多个判断的)否则返回default默认值</td></tr><tr><td align="center">case when [表中字段]比较运算 then [res1]…else [default] end</td><td align="center">如果不是具体的而是范围，使用该语法</td></tr></tbody></table><p>​    范例：流程控制函数的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- if</span><span class="token keyword">SELECT</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token string">'ok'</span><span class="token punctuation">,</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果ok</span><span class="token comment">--ifnull</span><span class="token keyword">SELECT</span> ifnull<span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//结果error</span><span class="token comment">-- case when then else end</span><span class="token comment">-- 需求：查询员工表emp中员工姓名和工作地址(北京/上海--->一线城市，其他--->二线城市)</span><span class="token keyword">SELECT</span>name<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">case</span> workaddress <span class="token keyword">when</span> <span class="token string">'北京'</span> <span class="token keyword">then</span> <span class="token string">'一线城市'</span> <span class="token keyword">when</span> <span class="token string">'上海'</span> <span class="token keyword">then</span> <span class="token string">'一线城市'</span> <span class="token keyword">else</span> <span class="token string">'二线城市'</span> <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">'工作地址'</span><span class="token keyword">FROM</span> emp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-约束"><a href="#5-约束" class="headerlink" title="5. 约束"></a>5. 约束</h4><p>​    约束是作用于表中字段上的规则，用于限制存储在表中的数据</p><p>​    约束的目的是保证数据库中数据的正确、有效性和完整性</p><p>​    约束的分类</p><table><thead><tr><th align="center">约束</th><th align="center">描述</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">非空约束</td><td align="center">限制该字段的数据不能为null</td><td align="center">NOT NULL</td></tr><tr><td align="center">唯一约束</td><td align="center">保证该字段的所有数据都是唯一、不重复的</td><td align="center">UNIQUE</td></tr><tr><td align="center">主键约束</td><td align="center">主键是一行数据的唯一标识，要求非空且唯一</td><td align="center">PRIMARY KEY</td></tr><tr><td align="center">默认约束</td><td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="center">DEFAULT</td></tr><tr><td align="center">检查约束</td><td align="center">保证字段值满足某一条件</td><td align="center">CHECK</td></tr><tr><td align="center">外键约束</td><td align="center">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td align="center">FOREIGN KEY</td></tr></tbody></table><p>​    注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束</p><p>​    范例：约束的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">;</span>name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">;</span>age <span class="token keyword">INT</span> <span class="token keyword">CHECK</span><span class="token punctuation">(</span>age<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> age<span class="token operator">&lt;=</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>statues <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1'</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token keyword">COMMENT</span> <span class="token string">'用户表'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-外键约束"><a href="#6-外键约束" class="headerlink" title="6.外键约束"></a>6.外键约束</h4><p>​    概念：用来让两张表的数据之间建立连接，保证数据的一致性和完整性</p><p>​    一般把设立外键的表叫做子表，而让该外键为主键的表叫主表</p><p><a href="https://imgse.com/i/zEiZ1x"><img src="https://s1.ax1x.com/2022/11/15/zEiZ1x.png" alt="zEiZ1x.png"></a></p><p>​    设置外键后，当要删除主表的数据时，要判定该数据在子表中是否存在关联关系，如果存在则拒绝删除操作</p><p>​    外键约束的语法：</p><ul><li><p>添加外键</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//建表时直接创建</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>字段名 数据类型<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token keyword">CONSTRAINT</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>外键名称<span class="token punctuation">]</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>外键字段名<span class="token punctuation">)</span> REFRENCES 主表<span class="token punctuation">(</span>主表列名<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//表建立后修改外键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> 外键名称 <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>外键字段名<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> 主表名<span class="token punctuation">(</span>主表列名<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除外键</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> 外键名称<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​    范例：外键的操作</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//增加外键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> emp <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> fk_emp_dept_id <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> dept<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除外键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> emp <span class="token keyword">DROP</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> fk_emp_dept_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    外键约束：删除和更新行为</p><table><thead><tr><th align="center">行为</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NO ACTION</td><td align="center">当主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新，<strong>外键约束的默认行为</strong></td></tr><tr><td align="center">RESTRICT</td><td align="center">与NO ACTION一致</td></tr><tr><td align="center">CASCADE(级联)</td><td align="center">当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在从表中的记录</td></tr><tr><td align="center">SET NULL</td><td align="center">当在主表中删除对应记录时，首先检查该记录是否对应外键，如果有则设置从表中该外键值为null(此时需要设计时外键允许取null)</td></tr><tr><td align="center">SET DEFAULT</td><td align="center">主表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)</td></tr></tbody></table><p>​    语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> 外键名称 <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>外键字段名<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> 主表名<span class="token punctuation">(</span>主表列名<span class="token punctuation">)</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CASCADE</span> <span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">CASCADE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <code>ON UPDATE</code>：表示更新时怎么操作</p><p>​    <code>ON DELETE</code>：表示删除时怎么操作</p><p>​    前面一段与外键设置时语法相同</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构04</title>
      <link href="/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404/"/>
      <url>/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8404/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1. 栈的定义"></a>1. 栈的定义</h4><p>​    一种可以实现“先进后出”的存储结构<br>​    栈类似于箱子</p><h4 id="2-栈的分类"><a href="#2-栈的分类" class="headerlink" title="2. 栈的分类"></a>2. 栈的分类</h4><p>​    栈可以分为静态栈和动态栈</p><p>​    静态栈：通过数组实现</p><p>​    动态栈：通过链表实现</p><p>​    动态栈使用的更多</p><h4 id="3-栈可以实现的操作"><a href="#3-栈可以实现的操作" class="headerlink" title="3. 栈可以实现的操作"></a>3. 栈可以实现的操作</h4><p>​    1. 入栈(压栈)</p><p>​    2. 出栈</p><h4 id="4-动态栈的伪算法"><a href="#4-动态栈的伪算法" class="headerlink" title="4. 动态栈的伪算法"></a>4. 动态栈的伪算法</h4><ol><li><p>动态栈的实现</p><p>动态栈通过链表来实现，栈中的每一个元素通过一个结点来表示，要实现栈还需要声明一个栈顶和栈底，初始化栈时，会将栈顶和栈底指向同一个空的头结点，要向栈存入数据，则先新生成一个结点，再**将该新结点的指针域指向栈顶指向的结点(考虑到出栈时要删除，所以新指向旧)**，最后将栈顶移动到新结点上</p></li></ol><ol start="2"><li>注意：动态栈属于链表栈，不存在满的问题</li></ol><ol start="3"><li><p>压栈操作图示</p><p><img src="https://s1.ax1x.com/2022/11/10/z9SQFe.png" alt="z9SQFe.png"></p></li></ol><ol start="4"><li><p>栈的遍历</p><p>栈的遍历由于栈是先进后出，所以需要通过栈顶确定指针p，通过指针p来自上向下进行操作，只要p指向的元素不是栈底，则可以对栈一直输出</p></li></ol><ol start="5"><li><p>判断栈是否为空</p><p>当栈顶和栈底相等，则栈为空</p></li></ol><ol start="6"><li><p>出栈</p><p>当栈中元素为空时，则出栈失败；不为空则将一指针p指向栈顶指向的元素，栈顶元素指向该元素的下一个元素，此时释放掉p指针指向的结点就行</p></li></ol><ol start="7"><li><p>栈的清空</p><p>将栈内有效元素全部清空，只保留框架，实现需要定义指针p和q，p指向栈顶元素，q为NULL，如果p没有指向栈底，则q指向p的下一个元素，当将p指向元素释放后p在移动到q上，只要p指向的不是栈底则一直循环执行该算法，循环结束后应将栈顶指向栈底</p></li></ol><h4 id="5-动态栈的算法"><a href="#5-动态栈的算法" class="headerlink" title="5. 动态栈的算法"></a>5. 动态栈的算法</h4><ol><li><p>算法-栈的定义、栈的初始化、压栈、遍历栈</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//定义栈中的每一个结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> pNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>NODE<span class="token punctuation">,</span><span class="token operator">*</span>PNODE<span class="token punctuation">;</span><span class="token comment">//定义栈</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Stack</span><span class="token punctuation">&#123;</span>    PNODE pTop<span class="token punctuation">;</span>    PNODE pBottom<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>STACK<span class="token punctuation">,</span><span class="token operator">*</span>PSTACK<span class="token punctuation">;</span><span class="token comment">//函数声明</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    STACK st<span class="token punctuation">;</span>    <span class="token comment">//定义栈</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//栈的初始化</span>    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//压栈</span>    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write_stack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//遍历栈</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//栈的初始化</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    pSt<span class="token operator">-></span>pTop <span class="token operator">=</span> <span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>pSt<span class="token operator">-></span>pTop<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pSt<span class="token operator">-></span>pBottom <span class="token operator">=</span> pSt<span class="token operator">-></span>pTop<span class="token punctuation">;</span>    <span class="token comment">//指针域置为空</span>    pSt<span class="token operator">-></span>pTop<span class="token operator">-></span>pNext <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//压栈</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    PNODE p <span class="token operator">=</span> <span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>data <span class="token operator">=</span> num<span class="token punctuation">;</span>    p<span class="token operator">-></span>pNext <span class="token operator">=</span> pSt<span class="token operator">-></span>pTop<span class="token punctuation">;</span>    pSt<span class="token operator">-></span>pTop <span class="token operator">=</span>p<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//遍历</span><span class="token keyword">void</span> <span class="token function">write_stack</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    PNODE p <span class="token operator">=</span> pSt<span class="token operator">-></span>pTop<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pSt<span class="token operator">-></span>pBottom<span class="token operator">!=</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>算法-栈是否为空的判断、出栈</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span> <span class="token comment">//bool类型需要声明的头文件</span></span><span class="token comment">//判断栈是否为空</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>PSTACK pST<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//函数声明</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//函数体</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pSt<span class="token operator">-></span>pTop<span class="token operator">==</span>pSt<span class="token operator">-></span>pBottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//出栈，并返回出栈的值</span>bool <span class="token function">pop</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//函数声明</span>bool <span class="token function">pop</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//函数体</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>pSt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    PNODE p <span class="token operator">=</span> pSt<span class="token operator">-></span>pTop<span class="token punctuation">;</span>    pSt<span class="token operator">-></span>pTop <span class="token operator">=</span> pSt<span class="token operator">-></span>pTop<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token operator">*</span>val <span class="token operator">=</span> p<span class="token operator">-></span>data<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>算法-栈的清空</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//函数声明</span><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span>PSTACK pSt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//函数体</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>pSt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    PNODE p <span class="token operator">=</span> pSt<span class="token operator">-></span>pTop<span class="token punctuation">;</span>    PNODE q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span>pSt<span class="token operator">-></span>pBottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        q <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pSt<span class="token operator">-></span>pTop <span class="token operator">=</span> pSt<span class="token operator">-></span>pBottom<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="6-栈的应用"><a href="#6-栈的应用" class="headerlink" title="6. 栈的应用"></a>6. 栈的应用</h4><p>​    1. 函数调用<br>​    2. 中断<br>​    3. 表达式求值<br>​    4. 内存分配<br>​    5. 缓冲处理<br>​    6. 走迷宫</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL01-SQL基础语法</title>
      <link href="/2022/10/31/SQL01-SQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/10/31/SQL01-SQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL基础语法"><a href="#SQL基础语法" class="headerlink" title="SQL基础语法"></a>SQL基础语法</h2><p>​    <strong>SQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准</strong></p><p>​    关系型数据库：用表结构存储数据的叫关系型数据库</p><h3 id="1-SQL简介"><a href="#1-SQL简介" class="headerlink" title="1. SQL简介"></a>1. SQL简介</h3><h4 id="1-SQL通用语法"><a href="#1-SQL通用语法" class="headerlink" title="(1)SQL通用语法"></a>(1)SQL通用语法</h4><ol><li>SQL语句可以单行书写或多行书写，以分号结尾</li><li>MySQL数据库的SQL语句不区分大小写</li><li>注释：<ul><li>单行注释：<code>--</code>注释内容或<code>#</code>注释内容(MySQL特有)</li><li>多行注释：<code>/*</code>注释内容<code>*/</code></li></ul></li></ol><h4 id="2-SQL分类"><a href="#2-SQL分类" class="headerlink" title="(2)SQL分类"></a>(2)SQL分类</h4><table><thead><tr><th align="center">分类</th><th align="center">全称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="center">Data Definition Language</td><td align="center">数据定义语言，用来定义数据库对象(数据库，表，字段)</td></tr><tr><td align="center">DML</td><td align="center">Data Manipulation Language</td><td align="center">数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td align="center">Data Query Language</td><td align="center">数据查询语言，用来查询数据库中表的记录</td></tr><tr><td align="center">DCL</td><td align="center">Data Control Language</td><td align="center">数据控制语言，用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table><h3 id="2-DDL-建库语言"><a href="#2-DDL-建库语言" class="headerlink" title="2. DDL(建库语言)"></a>2. DDL(建库语言)</h3><h4 id="1-DDL-数据库操作-命令行"><a href="#1-DDL-数据库操作-命令行" class="headerlink" title="(1)DDL-数据库操作(命令行)"></a>(1)DDL-数据库操作(命令行)</h4><ol><li><p>查询所有数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">database</span> <span class="token punctuation">[</span><span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span><span class="token punctuation">]</span> 数据库名 <span class="token punctuation">[</span>defailt <span class="token keyword">charset</span> 字符集<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">collate</span> 排序规则<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：一般不推荐设置字符集为<code>utf8</code>，因为其只占三个字节，而有些特殊字符是占四个字节的，所以推荐使用utf8mb4，它是支持四个字节的</p></li><li><p>删除数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token punctuation">[</span><span class="token keyword">if</span> <span class="token keyword">exists</span><span class="token punctuation">]</span> 数据库名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>进入/切换数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> 数据库名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询当前数据库</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="2-DDL-表操作-命令行"><a href="#2-DDL-表操作-命令行" class="headerlink" title="(2)DDL-表操作(命令行)"></a>(2)DDL-表操作(命令行)</h4><ol><li><p>查询当前数据库所有表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//前提是要先进入到数据库</span><span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询表结构(表的字段设置，类型等信息)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">desc</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询指定表的建表语句</p><pre class="line-numbers language-none"><code class="language-none">show create table 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>表的创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> 表名<span class="token punctuation">(</span>字段<span class="token number">1</span> 字段<span class="token number">1</span>类型 <span class="token punctuation">[</span><span class="token keyword">comment</span> <span class="token string">'注释'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>字段<span class="token number">2</span> 字段<span class="token number">2</span>类型 <span class="token punctuation">[</span><span class="token keyword">comment</span> <span class="token string">'注释'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>字段n 字段n类型 <span class="token punctuation">[</span><span class="token keyword">comment</span> <span class="token string">'注释'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">comment</span> <span class="token string">'表注释'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>向表结构中添加字段</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">add</span> 字段名 类型<span class="token punctuation">(</span>长度<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">comment</span> 注释<span class="token punctuation">]</span> <span class="token punctuation">[</span>约束<span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改表中某字段的数据类型</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">modify</span> 字段名 新的数据类型<span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>同时修改字段名和字段类型</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 change 旧字段名 新字段名 类型<span class="token punctuation">(</span>长度<span class="token punctuation">)</span>  <span class="token punctuation">[</span><span class="token keyword">comment</span> 注释<span class="token punctuation">]</span> <span class="token punctuation">[</span>约束<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除字段</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">drop</span> 字段名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改表名</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">rename</span> <span class="token keyword">to</span> 新表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token punctuation">[</span><span class="token keyword">if</span> <span class="token keyword">exists</span><span class="token punctuation">]</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="3-DDL-数据类型"><a href="#3-DDL-数据类型" class="headerlink" title="(3)DDL-数据类型"></a>(3)DDL-数据类型</h4><p>​    MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型</p><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">smallint</td><td align="center">2 bytes</td><td align="center">大整数值</td></tr><tr><td align="center">int</td><td align="center">4 bytes</td><td align="center">大整数值</td></tr><tr><td align="center">float</td><td align="center">4 bytes</td><td align="center">单精度浮点数值</td></tr><tr><td align="center">double</td><td align="center">8 bytes</td><td align="center">双精度浮点数值</td></tr><tr><td align="center">decimal</td><td align="center">使用时需要指定精度(总长)和标度(小数尾数)</td><td align="center">小数值</td></tr></tbody></table><ol><li><p>可以设置类型是否为无符号</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">age <span class="token keyword">int</span> unsigne<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>可以指定设置的范围</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">score <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//长度为4，小数部分为1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">0~255 bytes</td><td align="center">定长字符串</td></tr><tr><td align="center">varchar</td><td align="center">0~65535 bytes</td><td align="center">变长字符串</td></tr></tbody></table><p>​    定长与变长的区别：</p><ul><li>CHAR：存入数据不管多大占用的空间都是那么多，其性能上要好</li><li>VARCHAR：根据你存储的内容去计算需要占用的空间</li></ul><h5 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h5><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">1000-01-01至9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="center">time</td><td align="center">-838:59:59至838:59:59</td><td align="center">HH:MM:SS</td><td align="center">时间值</td></tr><tr><td align="center">datetime</td><td align="center">1000-01-01 00:00:00至9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间值</td></tr></tbody></table><h3 id="3-DML-数据更改"><a href="#3-DML-数据更改" class="headerlink" title="3. DML(数据更改)"></a>3. DML(数据更改)</h3><h4 id="1-DML-增加数据"><a href="#1-DML-增加数据" class="headerlink" title="(1)DML-增加数据"></a>(1)DML-增加数据</h4><ol><li><p>给指定字段添加数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> 表名<span class="token punctuation">(</span>字段名<span class="token number">1</span><span class="token punctuation">,</span>字段名<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span>值<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>给全部字段添加数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> 表名 <span class="token keyword">values</span><span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span>值<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注意：值应当与字段一一对应</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>​    <strong>注意：插入字符串和日期型数据应当包含在引号中</strong>，如果要添加多条数据，数据之间用<code>,</code>分隔</p><h4 id="2-DML-修改和删除数据"><a href="#2-DML-修改和删除数据" class="headerlink" title="(2)DML-修改和删除数据"></a>(2)DML-修改和删除数据</h4><ol><li><p>修改数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> 表名 <span class="token keyword">set</span> 字段名<span class="token number">1</span><span class="token operator">=</span>值<span class="token number">1</span><span class="token punctuation">,</span>字段名<span class="token number">2</span><span class="token operator">=</span>值<span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token keyword">where</span> 条件<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：如果没有写<code>where</code>条件，则会修改整张表的所有数据，<code>set</code>后面为一条记录的多个字段</p></li><li><p>删除数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">delete</span> <span class="token keyword">from</span> 表名 <span class="token punctuation">[</span><span class="token keyword">where</span> 条件<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：DELETE语句删除的是整条记录，而不是某一字段的值，且如果没有写<code>WHERE</code>条件，则会删除整张表的所有数据</p></li></ol><h3 id="4-DQL-数据查询"><a href="#4-DQL-数据查询" class="headerlink" title="4. DQL(数据查询)"></a>4. DQL(数据查询)</h3><p>​    在日常的项目中查询的频次要远高于增删改的频次</p><p>​    <strong>DQL语法：（语法顺序）</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//编写顺序</span><span class="token keyword">select</span>字段列表<span class="token keyword">from</span>表名列表<span class="token keyword">where</span>条件列表<span class="token keyword">group</span> <span class="token keyword">by</span>分组字段列表<span class="token keyword">having</span>分组后条件列表<span class="token keyword">order</span> <span class="token keyword">by</span>排序字段列表<span class="token keyword">limit</span>分页参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>DQL执行顺序</strong></p><pre class="line-numbers language-none"><code class="language-none">1.from2.where3.group by4.select5.having6.order by7.limit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-DQL-基本查询"><a href="#1-DQL-基本查询" class="headerlink" title="(1)DQL-基本查询"></a>(1)DQL-基本查询</h4><ol><li>查询字段</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//查询某些字段</span>selete 字段<span class="token number">1</span><span class="token punctuation">,</span>字段<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span><span class="token comment">//查询所有字段</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>设置别名</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> 字段<span class="token number">1</span><span class="token punctuation">[</span><span class="token keyword">as</span> <span class="token string">'别名1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>字段<span class="token number">2</span><span class="token punctuation">[</span><span class="token keyword">as</span> <span class="token string">'别名2'</span><span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：设置别名时，<code>AS</code>是可以省略的，<strong>设置别名后查询到的列会显示别名</strong></p><ol start="3"><li>对查询到的结果去除重复记录</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> 字段列表 <span class="token keyword">from</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-DQL-条件查询"><a href="#2-DQL-条件查询" class="headerlink" title="(2)DQL-条件查询"></a>(2)DQL-条件查询</h4><ol><li>语法</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">selete 字段列表 <span class="token keyword">from</span> 表名 <span class="token keyword">where</span> 条件列表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>条件</li></ol><table><thead><tr><th align="center">比较运算符(单个条件比较)</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;=、&gt; 、&lt;、&lt;=、=</td><td align="center">大于等于、大于、小于、小于等于、等于</td></tr><tr><td align="center">&lt;&gt;、!=</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN…AND</td><td align="center">在某个范围之内，between后面跟的是小值，and后面是大值</td></tr><tr><td align="center">IN(…)</td><td align="center">列表中满足某1项就可以查询到该条记录</td></tr><tr><td align="center">LIKE ‘占位符’</td><td align="center">模糊匹配(_匹配单个字符，%匹配任意个字符)</td></tr><tr><td align="center">IS (NOT) NULL</td><td align="center">某字段(不)为空</td></tr></tbody></table><hr><table><thead><tr><th align="center">逻辑运算符(用于将多个条件组装起来)</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">and 或 &amp;&amp;</td><td align="center">并且(多个条件同时成立)</td></tr><tr><td align="center">or 或 ||</td><td align="center">或者(多个条件任意一个成立)</td></tr><tr><td align="center">not 或 !</td><td align="center">非(不是)</td></tr></tbody></table><h4 id="3-DQL-分组查询-将已经查询好的记录分组排列"><a href="#3-DQL-分组查询-将已经查询好的记录分组排列" class="headerlink" title="(3)DQL-分组查询(将已经查询好的记录分组排列)"></a>(3)DQL-分组查询(将已经查询好的记录分组排列)</h4><p>​    <strong><code>GROUP BY</code> 语句是在 SQL 查询中用于对查询结果进行分组，它不会改变查询的总记录数，只是对查询结果中的数据进行分组</strong>，并允许你在每个组上执行聚合操作（比如 <code>COUNT()</code>、<code>SUM()</code>、<code>AVG()</code> 等</p><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>​    <strong>group by是对该列内容相同的字段分成一组，放同一个组之后若直接遇到select，则将分组内的第一行进行输出，其他的行被丢弃</strong></p><p>​    <a href="https://imgse.com/i/pALtsq1"><img src="https://s21.ax1x.com/2024/12/17/pALtsq1.png" alt="sql题"></a></p><h5 id="书本语法"><a href="#书本语法" class="headerlink" title="书本语法"></a>书本语法</h5><ol><li><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">     <span class="token keyword">select</span> 字段列表 <span class="token keyword">from</span> 表名 <span class="token punctuation">[</span><span class="token keyword">where</span> 条件<span class="token punctuation">]</span> <span class="token keyword">group</span> <span class="token keyword">by</span> 分组字段名 <span class="token punctuation">[</span><span class="token keyword">having</span> 分组后过滤条件<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>where和having的区别</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件则不参与分组，而having是分组之后对结果进行过滤</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以</li></ul></li><li><p>执行顺序：where&gt;聚合函数&gt;having</p></li><li><p>分组之后查询的字段一般为聚合函数和进行分组的字段，查询其他字段无任何意义</p></li></ol><h4 id="4-DQL补充-聚合函数-在分组查询中使用"><a href="#4-DQL补充-聚合函数-在分组查询中使用" class="headerlink" title="(4)DQL补充-聚合函数(在分组查询中使用)"></a>(4)DQL补充-聚合函数(在分组查询中使用)</h4><h5 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h5><p>​    <strong><code>COUNT(1)</code> 是一个常见的聚合函数，表示对查询结果中每一行进行计数</strong>，<code>COUNT(1)</code> 和 <code>COUNT(*)</code> 的行为在大多数数据库中是一样的，都是统计符合条件的行数</p><p>​    <a href="https://imgse.com/i/pALffW4"><img src="https://s21.ax1x.com/2024/12/18/pALffW4.png" alt="聚合函数和分组查询"></a></p><p>​    </p><h5 id="书本语法-1"><a href="#书本语法-1" class="headerlink" title="书本语法"></a>书本语法</h5><ol><li><p>聚合函数的概念：将一列数据作为一个整体进行纵向计算</p></li><li><p>常见聚合函数</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table></li><li><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> 聚合函数<span class="token punctuation">(</span>字段列表<span class="token punctuation">)</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：null值不参与所有聚合函数运算</p></li></ol><h4 id="5-DQL-排序查询"><a href="#5-DQL-排序查询" class="headerlink" title="(5)DQL-排序查询"></a>(5)DQL-排序查询</h4><ol><li><p>语法</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> 字段列表 <span class="token keyword">from</span> 表名 <span class="token keyword">order</span> <span class="token keyword">by</span> 字段<span class="token number">1</span> 排序方式<span class="token number">1</span><span class="token punctuation">,</span> 字段<span class="token number">2</span> 排序方式<span class="token number">2</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>排序方式</p><ul><li>asc：升序(默认值)</li><li>desc：降序</li></ul></li><li><p>多字段排序时，第一个字段值相同时才会根据第二个字段排序</p></li></ol><h4 id="6-DQL-分页查询"><a href="#6-DQL-分页查询" class="headerlink" title="(6)DQL-分页查询"></a>(6)DQL-分页查询</h4><ol><li><p>语法</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> 字段列表 <span class="token keyword">from</span> 表名 <span class="token keyword">limit</span> 起始索引<span class="token punctuation">,</span>查询记录数<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p> 起始索引从0开始，起始索引 = (要查询页码-1) <code>*</code> 每页显示记录数</p></li><li><p> 分页查询在不同数据库中语法不一样，在MySQL中是LIMIT</p></li><li><p> 如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10</p></li></ol><h3 id="5-DCL-SQL开发人员对其操作比较少"><a href="#5-DCL-SQL开发人员对其操作比较少" class="headerlink" title="5. DCL(SQL开发人员对其操作比较少)"></a>5. DCL(SQL开发人员对其操作比较少)</h3><h4 id="1-DCL-用户控制"><a href="#1-DCL-用户控制" class="headerlink" title="(1)DCL-用户控制"></a>(1)DCL-用户控制</h4><ol><li><p>查询用户</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> mysql<span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>创建用户</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//主机名约束了用户可以访问的数据库，设置为%可以访问所有数据库</span><span class="token keyword">create</span> <span class="token keyword">user</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'密码'</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改用户密码</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">user</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span> identified <span class="token keyword">with</span> mysql_native_password <span class="token keyword">by</span> <span class="token string">'新密码'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除用户</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">user</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="2-DCL-权限控制"><a href="#2-DCL-权限控制" class="headerlink" title="(2)DCL-权限控制"></a>(2)DCL-权限控制</h4><ol><li><p>查询权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> grants <span class="token keyword">for</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>授予权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">//如果是所有数据库以及所有表则写*.*,设置多个权限用,隔开</span><span class="token keyword">grant</span> 授权列表 <span class="token keyword">on</span> 数据库名<span class="token punctuation">.</span>表名 <span class="token keyword">to</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>撤销权限</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">revoke</span> 权限列表 <span class="token keyword">on</span> 数据库名<span class="token punctuation">.</span>表名 <span class="token keyword">from</span> <span class="token string">'用户名'</span><span class="token variable">@'主机名'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><code>2024.12.17(已校验)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构03</title>
      <link href="/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/"/>
      <url>/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="1-typedef"><a href="#1-typedef" class="headerlink" title="1. typedef"></a>1. typedef</h4><p>​    C语言允许为一个数据类型起一个新的别名，使用typedef关键字来进行定义</p><p>​    typedef 的用法一般为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span>  oldName  newName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    注意：一般新名字全部字母大写</p><p>​    范例：为结构体起一个别名</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sid<span class="token punctuation">;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ST<span class="token punctuation">,</span><span class="token operator">*</span>PST<span class="token punctuation">;</span><span class="token comment">//ST等价于struct Student, PST等价于struct Student *</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ST st<span class="token punctuation">;</span>    st<span class="token punctuation">.</span>sid <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>st<span class="token punctuation">.</span>sid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-链表-离散存储"><a href="#2-链表-离散存储" class="headerlink" title="2. 链表(离散存储)"></a>2. 链表(离散存储)</h4><p><strong>链表的定义：</strong></p><p>​    ​    1. n个结点离散分配，<br>​    ​    2. 彼此通过指针相连<br>​    ​    3. 每个结点只有一个前驱结点，每个结点只有一个后续结点<br>​    ​    4. 首结点没有前驱结点，尾结点没有后续结点</p><p><strong>专业术语：</strong></p><ul><li>首结点：第一个存了有效数据的结点</li><li>尾结点：最后一个存了有效数据的结点，尾结点的指针域为空</li><li>头结点：第一个有效结点(首结点)之前的结点，方便我们对链表算法进行操作，里面不包含有效数据和数组长度，但头结点的数据类型和首结点的数据类型一样</li><li>头指针：指向头结点的指针变量，存放了头结点的地址</li><li>尾指针：指向尾结点的指针变量</li></ul><p><strong>如果希望通过一个函数来对链表进行处理，至少需要接受链表的哪些参数：</strong></p><p>​    只需要一个参数：头指针</p><p>​    通过头指针可以推算出链表的其他所有信息</p><h4 id="3-链表结点数据类型的表示"><a href="#3-链表结点数据类型的表示" class="headerlink" title="3. 链表结点数据类型的表示"></a>3. 链表结点数据类型的表示</h4><p>​    一个结点可以分为两个部分：数据域和指针域</p><p>​    指针域中的指针指向了一个完整的结点</p><p>​    范例：结点的定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> data<span class="token punctuation">;</span>  <span class="token comment">//数据域</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> pNext<span class="token punctuation">;</span> <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span>NODE<span class="token punctuation">,</span><span class="token operator">*</span>PNODE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-链表的分类"><a href="#4-链表的分类" class="headerlink" title="4. 链表的分类"></a>4. 链表的分类</h4><ul><li>单链表：每个结点的指针域只能指向后面结点</li><li>双链表：每一个结点有两个指针域</li><li>循环链表：能通过任何一个结点找到其他所有的结点</li><li>非循环链表：尾结点为null</li></ul><p>​    </p><h4 id="5-链表的伪算法"><a href="#5-链表的伪算法" class="headerlink" title="5. 链表的伪算法"></a>5. 链表的伪算法</h4><ol><li><p>非循环单链表：将q结点插入到p结点后面</p><p><a href="https://imgse.com/i/xRglh8"><img src="https://s1.ax1x.com/2022/10/25/xRglh8.png" alt="xRglh8.png"></a></p></li></ol><p>​    伪算法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第一种方式</span>r <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>p<span class="token operator">-></span>pNext <span class="token operator">=</span> q<span class="token punctuation">;</span>q<span class="token operator">-></span>pNext <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token comment">//第二种方式</span>q<span class="token operator">-></span>pNext <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>p<span class="token operator">-></span>pNext <span class="token operator">=</span> q<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>非循环单链表：将p结点后面的那个结点删除</p><p><a href="https://imgse.com/i/xR2PDs"><img src="https://s1.ax1x.com/2022/10/25/xR2PDs.png" alt="xR2PDs.png"></a></p></li></ol><p>​    伪算法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//注意:由于直接连会导致中间那个结点找不到从而导致内存的浪费,所以要先存起来,最后也要进行释放</span>r <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>p<span class="token operator">-></span>pNext <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token operator">-></span>pNext<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><h4 id="6-链表的算法"><a href="#6-链表的算法" class="headerlink" title="6. 链表的算法"></a>6. 链表的算法</h4><ol><li><p><strong>算法–链表的创建以及链表的遍历</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token comment">//定义链表</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">count</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> number<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">count</span> <span class="token operator">*</span> pNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>NODE<span class="token punctuation">,</span><span class="token operator">*</span> PNODE<span class="token punctuation">;</span><span class="token comment">//函数声明</span>PNODE <span class="token function">count_create</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">count_write</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//设置头指针</span>    PNODE pHead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pHead <span class="token operator">=</span> <span class="token function">count_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个非循环单链表，并返回头结点地址</span>    <span class="token function">count_write</span><span class="token punctuation">(</span>pHead<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//遍历打印出来</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>PNODE <span class="token function">count_create</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp<span class="token punctuation">;</span> <span class="token comment">//临时存放用户输入的数据</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span> <span class="token comment">//存放有效结点的个数</span>    <span class="token comment">//设置头指针指向头结点，头结点不存放任何有效数据</span>    PNODE pHead <span class="token operator">=</span> <span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//头结点的指针域设为NULL，防止后面没有结点</span>    pHead<span class="token operator">-></span>pNext <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pHead<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//链表的尾指针，用来挂每一个新生成的链表结点</span>    PNODE pTail <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input number :"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The %d number:"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        PNODE new_Node <span class="token operator">=</span> <span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> new_Node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//新生成结点的指针域设置为NULL</span>        new_Node<span class="token operator">-></span>pNext <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">//新生成的结点的数据域设置值</span>        new_Node<span class="token operator">-></span>number <span class="token operator">=</span>tmp<span class="token punctuation">;</span>        <span class="token comment">//将新生成的结点挂在尾指针上</span>        pTail<span class="token operator">-></span>pNext <span class="token operator">=</span> new_Node<span class="token punctuation">;</span>        <span class="token comment">//将尾指针指向新生成的新结点</span>        pTail <span class="token operator">=</span> new_Node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> pHead<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">count_write</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    PNODE pTail <span class="token operator">=</span> pHead<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">!=</span>pTail<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token punctuation">,</span>pTail<span class="token operator">-></span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将指针向后移</span>        pTail <span class="token operator">=</span> pTail<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p><strong>算法–链表的是否为空的判断和求链表长度</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//判断是否为空的函数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span>  <span class="token comment">//C语言使用bool类型需要导入的头文件</span></span>bool <span class="token function">is_empty</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数声明</span>bool <span class="token function">is_empty</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//函数体</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pHead<span class="token operator">-></span>pNext<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求链表长度</span><span class="token keyword">int</span> <span class="token function">count_len</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数声明</span><span class="token keyword">int</span> <span class="token function">count_len</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//函数体</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    PNODE p <span class="token operator">=</span> pHead<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token operator">++</span>len<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="3"><li><p><strong>算法–链表的冒泡排序</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//冒泡排序</span><span class="token keyword">void</span> <span class="token function">count_sort</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数声明</span><span class="token keyword">void</span> <span class="token function">count_sort</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//函数体</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>tmp<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">count_len</span><span class="token punctuation">(</span>pHead<span class="token punctuation">)</span><span class="token punctuation">;</span>    PNODE p <span class="token operator">=</span> pHead<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        PNODE q <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>number<span class="token operator">></span>q<span class="token operator">-></span>number<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                tmp <span class="token operator">=</span> p<span class="token operator">-></span>number<span class="token punctuation">;</span>                p<span class="token operator">-></span>number <span class="token operator">=</span> q<span class="token operator">-></span>number<span class="token punctuation">;</span>                q<span class="token operator">-></span>number <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            q <span class="token operator">=</span> q<span class="token operator">-></span>pNext<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="4"><li><p><strong>算法–链表的插入元素和删除元素</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//链表的插入算法</span>bool <span class="token function">count_insert</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span> <span class="token keyword">int</span> pos <span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数声明 pos表示在有效结点第pos个增加结点</span>bool <span class="token function">count_insert</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span> <span class="token keyword">int</span> pos <span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//函数体</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    PNODE p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>        <span class="token comment">//一定要判空，否则程序有bug</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    PNODE pNew <span class="token operator">=</span> <span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pNew<span class="token operator">-></span>number <span class="token operator">=</span> val<span class="token punctuation">;</span>    pNew<span class="token operator">-></span>pNext <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    p<span class="token operator">-></span>pNext <span class="token operator">=</span> pNew<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//链表的删除算法</span>bool <span class="token function">count_delete</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span> <span class="token keyword">int</span> pos <span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数声明，pos表示删除有效结点的第pos个</span>bool <span class="token function">count_delete</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span> <span class="token keyword">int</span> pos <span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    PNODE p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>pos <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pNext<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> false<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pNext<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    PNODE tmp <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token operator">*</span>val <span class="token operator">=</span> tmp<span class="token operator">-></span>number<span class="token punctuation">;</span>    <span class="token comment">//将p指针指向下下个结点</span>    p<span class="token operator">-></span>pNext <span class="token operator">=</span> p<span class="token operator">-></span>pNext<span class="token operator">-></span>pNext<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE05</title>
      <link href="/2022/10/31/JavaEE05/"/>
      <url>/2022/10/31/JavaEE05/</url>
      
        <content type="html"><![CDATA[<h2 id="request内置对象详解"><a href="#request内置对象详解" class="headerlink" title="request内置对象详解"></a>request内置对象详解</h2><h4 id="1-request内置对象的作用"><a href="#1-request内置对象的作用" class="headerlink" title="1. request内置对象的作用"></a>1. request内置对象的作用</h4><p>​    在JSP之中，request内置对象的主要工作就是服务器端接收客户端发送来的请求参数。</p><h4 id="2-request对象的继承结构"><a href="#2-request对象的继承结构" class="headerlink" title="2. request对象的继承结构"></a>2. request对象的继承结构</h4><p>​    request属于<code>javax.servlet.http.HttpServletRequest</code>接口的对象</p><table><thead><tr><th>继承结构</th><th>说明</th></tr></thead><tbody><tr><td>public interface HttpServletRequest extends ServletRequest</td><td>扩展ServletRequest接口以提供HTTP servlet的请求信息</td></tr></tbody></table><p>​    注意：HttpServletRequest是继承<code>javax.servlet.ServletRequest</code>接口，但是ServletRequest接口只有一个子接口，不写成一个的原因是HttpServletRequest子接口是专门为了处理HTTP协议而提供的，而ServletRequest接口是负责所有相关协议的公共接口，以后可能还会有新的协议，新的协议要开发只需要让新的协议继续继承ServletRequest接口即可。</p><p>​    <strong>注意：如果以后要进行方法查询一定要两个接口一起看(从子接口开始找)，且所有提供接收参数的方法都在ServletRequest父接口提供</strong></p><h4 id="3-request内置对象解决传递参数乱码"><a href="#3-request内置对象解决传递参数乱码" class="headerlink" title="3. request内置对象解决传递参数乱码"></a>3. request内置对象解决传递参数乱码</h4><p>​    在使用form表单时，如果输入中文在提交后会变为中文乱码</p><p>​    在乱码问题的解决上需要考虑两种情况</p><ul><li><p>POST提交请求(表单上使用)：可以直接使用ServletRequest父接口定义的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public void setCharacterEncoding(String env) throws UnsupportedEncodingException</td><td align="center">方法</td><td align="center">设置String env来重写此请求正文中使用的字符编码的名称。必须在使用getReader()读取请求参数或输入之前调用此方法。否则，它没有效果。</td></tr></tbody></table></li><li><p>GET提交请求(直接输入访问路径或者表单)：</p><p>Tomcat8以下的默认编码格式是<strong>ISO-8859-1</strong>，此时接收后需要进行编码的转换，以上就不用转了</p><p>如果是getParameter()方法其返回值为一个字符串，在String类中提供有改变字符串编码的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public byte[] getBytes(String charsetName) throws UnsupportedEncodingException</td><td align="center">方法</td><td align="center">使用给定的字符集将此字符串编码为一个字节序列，并将结果存储到一个新的字节数组中。</td></tr><tr><td align="center">public String(byte[] bytes, String charsetName) throws UnsupportedEncodingException</td><td align="center">构造方法</td><td align="center">通过使用指定的字符集对指定的字节数组进行解码，构造新的String</td></tr></tbody></table><p>注意：<code>charsetName</code>表示要设置的字符集</p><p>将字符编码转换为<code>UTF-8</code>后再将字符数组使用上述构造方法设置为<code>UTF-8</code>转成String类型输出即可在页面正常显示</p></li></ul><p>​    在HttpServletRequest接口里面有一个方法，此方法可以判断出当前的请求模式</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String getMethod()</td><td align="center">方法</td><td align="center">返回用于发出此请求的HTTP方法的名称，例如GET、POST或PUT。</td></tr></tbody></table><h4 id="4-POST与GET请求的区别"><a href="#4-POST与GET请求的区别" class="headerlink" title="4. POST与GET请求的区别"></a>4. POST与GET请求的区别</h4><ul><li>POST请求：主要用在表单上，处理路径只是提交路径其不会改变</li><li>GET请求：只要是用户直接进行页面访问，那么请求类型一定就是GET请求，表单上也可以使用GET请求，但是GET请求会将所有的请求参数都附加到表单访问路径上，所以不能够传递过多的内容，一般只能够传递4K~5K的内容</li></ul><p>​    注意：由于GET请求传递内容有限，所以一般使用POST请求</p><h4 id="5-request对象接收请求参数"><a href="#5-request对象接收请求参数" class="headerlink" title="5. request对象接收请求参数"></a>5. request对象接收请求参数</h4><p>​    <strong>request内置对象接收参数的来源</strong></p><ul><li><p>第一种来源：表单提交</p></li><li><p>第二种来源：标签指令传递(<code>&lt;jsp:include&gt;</code>、<code>&lt;jsp:forward&gt;</code>)</p></li><li><p>第三种来源：地址重写</p><p>地址重写的基本结构：<code>xxxxxx.jsp?参数名称=内容&amp;参数名称=内容...</code></p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;如以下代码为向inpuut.jsp页面传递了两个参数&lt;a href&#x3D;&quot;input.jsp?msg&#x3D;hello&amp;mid&#x3D;30&quot;&gt;访问&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>地址重写相当于GET请求</p></li></ul><p>​    <strong>隐藏域</strong></p><p>​    在表单中有一种表单类型为隐藏域(其会跟着表单一起提交，但是其内容不能够由用户输入且用户无法看见隐藏域)</p><blockquote><input type="hidden" name ="name" value="lxs"></blockquote><p>​    注意：一般隐藏域属于辅助的信息内容，一般都是固定好的</p><p>​    <strong>request内置对象的父类中提供有两个接收参数的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public <strong>String</strong> getParameter(String name)</td><td align="center">方法</td><td align="center">以String形式返回请求参数的值，如果该参数不存在，则返回null。只有在确定参数只有一个值时，才应使用此方法。如果参数可能有多个值，请使用getParameterValues()</td></tr><tr><td align="center">public <strong>String[]</strong> getParameterValues(String name)</td><td align="center">方法</td><td align="center">返回包含给定请求参数的所有值的String对象数组，如果该参数不存在，则返回null。</td></tr></tbody></table><p>​    注意：getParameter只能接收一个内容，而getParameterValues可以接收一组内容</p><p>​    request内置对象提供返回全部请求参数名称的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>public Enumeration&lt;String&gt; getParameterNames()</code></td><td align="center">方法</td><td align="center">返回包含此请求中包含的参数名称的String对象的枚举。如果请求没有参数，该方法将返回空Enumeration。</td></tr></tbody></table><p>​    注意：通过这个方法就可以获得传递参数的名字，而通过传递参数的名字就可以获取到值</p><p>​    <strong>补充：Enumeration类(接口)</strong></p><p>​    Enumeration接口是Iterator迭代器的“古老版本”，从JDK 1.0开始，Enumeration接口就已经存在了(Iterator从JDK 1.2才出现)</p><p>​    Enumeration接口的方法介绍</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">boolean hasMoreElements()</td><td align="center">方法</td><td align="center">这是检测Enumeration 对象是否还有元素，有则返回true,否则false</td></tr><tr><td align="center">E nextElement()</td><td align="center">方法</td><td align="center">如果Enumeration对象还有元素，该方法得到下一个元素</td></tr></tbody></table><p>​    </p><p>​    范例：动态的接收参数</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;发送方 form.jsp文件&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;form action&#x3D;&quot;request.jsp&quot; method&#x3D;&quot;post&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;text1&quot; &#x2F;&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;**box&quot; value&#x3D;&quot;1&quot;&gt;1&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;**box&quot; value&#x3D;&quot;2&quot;&gt;2&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;**box&quot; value&#x3D;&quot;3&quot;&gt;3&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;**box&quot; value&#x3D;&quot;4&quot;&gt;4&lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit1&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;&lt;&#x2F;form&gt;&#x2F;&#x2F;接收方 request.jsp文件&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;取得属性request.setCharacterEncoding(&quot;UTF-8&quot;);Enumeration&lt;String&gt; e &#x3D; request.getParameterNames();while(e.hasMoreElements())&#123;String s &#x3D; e.nextElement();if(s.startsWith(&quot;**&quot;))&#123;String[] str &#x3D; request.getParameterValues(s);%&gt;&lt;h3&gt;&lt;%&#x3D;Arrays.toString(str)%&gt;&lt;&#x2F;h3&gt;&lt;%&#125;else&#123;%&gt;&lt;h4&gt;&lt;%&#x3D;request.getParameter(s)%&gt;&lt;&#x2F;h4&gt;&lt;%&#125;&#125;%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：为了区分接收的一个参数是对应一个值还是多个值，对多个值参数在设置<code>name</code>属性时一般在前面加<code>**</code>，如<code>**XXXX</code>，用作区分</p><h4 id="6-通过request对象实现资源定位"><a href="#6-通过request对象实现资源定位" class="headerlink" title="6. 通过request对象实现资源定位"></a>6. 通过request对象实现资源定位</h4><p>​    在request对象中还有一个重要的操作方法：取得路径名称(该方法在<code>javax.servlet.http.HttpServletRequest</code>中定义)</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String getContextPath()</td><td align="center">方法</td><td align="center">取得上下文路径</td></tr></tbody></table><p>​    getContextPath()取得的是整个虚拟目录的映射路径，在之前Tomcat的<code>conf/server.xml</code>中设置添加了<code>&lt;Context path = &quot;/lxs&quot; docBase = &quot;D:\lxsweb&quot; /&gt;</code>，getContextPath()方法取得的是<code>/lxs</code></p><p>​    通过取得整个虚拟目录的映射路径，我们可以实现资源定位。在实际开发中，我们会导入img、css、js，此时文件通常是使用传统<code>../</code>、<code>/</code>的形式进行引用，但此时如果代码文件发生移动，那么其的路径会发生变化则需要重写配置<code>../</code>、<code>/</code>。而使用getContextPath()可以解决这个问题。</p><p>​    范例：1.输出项目根路径，2.实现资源定位</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;test.jsp与images同级&#x2F;&#x2F;新建文件夹images，导入图片文件img_1.jpg&#x2F;&#x2F;编写文件test.jsp文件&lt;%@page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%String contextpath &#x3D; request.getContextPath();%&gt;&#x2F;&#x2F;输出项目根路径&lt;h1&gt;&lt;%&#x3D;contextpath%&gt;&lt;&#x2F;h1&gt;&#x2F;&#x2F;实现资源定位&lt;img src&#x3D;&quot;&lt;%&#x3D;contextpath%&gt;&#x2F;images&#x2F;img_1.jpg&quot; height&#x3D;&quot;40%&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：此时不管test.jsp放在什么位置，图片都可以正常的显示出来，<strong>在实际开发中都会使用这种方式来引用资源</strong></p><h4 id="7-通过request对象取得基础信息"><a href="#7-通过request对象取得基础信息" class="headerlink" title="7. 通过request对象取得基础信息"></a>7. 通过request对象取得基础信息</h4><p>​    在<code>javax.servlet.http.HttpServletRequest</code>接口的父接口<code>javax.servlet.ServletRequest</code>中提供有取得其他基本信息的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String getRemoteAddr()</td><td align="center">方法</td><td align="center">返回发送请求的客户端或最后一个代理的IP地址</td></tr><tr><td align="center">public String getScheme()</td><td align="center">方法</td><td align="center">返回用于发出此请求的协议名称，例如http、https或ftp</td></tr><tr><td align="center">public String getServerName()</td><td align="center">方法</td><td align="center">返回请求发送到的服务器的主机名</td></tr><tr><td align="center">public int getServerPort()</td><td align="center">方法</td><td align="center">返回请求发送到的端口号</td></tr></tbody></table><p>​    范例：上述方法的使用以及获取项目的基本路径</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;编写文件path.jsp&lt;%@page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%String ip &#x3D; request.getRemoteAddr();String scheme &#x3D; request.getScheme();String name &#x3D; request.getServerName();int port &#x3D; request.getServerPort();%&gt;&lt;h3&gt;ip地址：&lt;%&#x3D;ip%&gt;&lt;&#x2F;h3&gt;&lt;h3&gt;协议：&lt;%&#x3D;scheme%&gt;&lt;&#x2F;h3&gt;&lt;h3&gt;主机名：&lt;%&#x3D;name%&gt;&lt;&#x2F;h3&gt;&lt;h3&gt;端口号：&lt;%&#x3D;port%&gt;&lt;&#x2F;h3&gt;&lt;%String path &#x3D; request.getScheme()+&quot;:&#x2F;&#x2F;&quot;+ request.getServerName()+&quot;:&quot;+request.getServerPort()+request.getContextPath();%&gt;&lt;h1&gt;访问路径：&lt;%&#x3D;path%&gt;&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>####8. getAttribute()和getParameter()的区别</p><p>​    1、getAttribute是返回(object)对象,getParameter返回字符串。</p><p>​    2、getAttribute可以返回格式化任意类型，getParameter只能返回字符串</p><p>​    3、与getAttribute()方法对应的有setAttribute()方法，但是没有与getParameter()相对的setParameter()</p><p>​    4、request.getAttribute获取的是服务器设置的数据，request.getParameter获取的是客户端比如浏览器的数据(获取http提交过来的数据)</p><p>​    5、getParameter方法就是服务器端接受客户端传递过来的数据时使用；getAttribute方法是在服务器端内部使用，数据通过getParameter获取进来之后，在另一个页面还想继续使用这个数据就要把这个数据通过setAttribute保存起来，想用时再用getAttribute取出来即可使用<br>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaEE04</title>
      <link href="/2022/10/09/javaEE04/"/>
      <url>/2022/10/09/javaEE04/</url>
      
        <content type="html"><![CDATA[<h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><h4 id="1-内置对象的概念"><a href="#1-内置对象的概念" class="headerlink" title="1. 内置对象的概念"></a>1. 内置对象的概念</h4><p>​    在Java程序中给了你一个类，要使用他用户需要创建一个对象，而<strong>内置对象指的是不需要用户自己创建的对象</strong>(即不需要用户自己手工进行对象实例化)。而是由WEB容器在它启动时默认创建好的对象，用户可以直接拿来使用</p><h4 id="2-内置对象"><a href="#2-内置对象" class="headerlink" title="2. 内置对象"></a>2. 内置对象</h4><p>​    当前主要学习JSP中提供的九个内置对象</p><table><thead><tr><th align="center">序号</th><th align="center">对象名称</th><th align="center">JavaEEAPI路径</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">pageContext</td><td align="center">javax.servlet.jsp.PageContext</td><td align="center">页面的上下文操作</td></tr><tr><td align="center">2</td><td align="center">request</td><td align="center">javax.servlet.http.HttpServletRequest</td><td align="center">服务器端接收客户端请求内容</td></tr><tr><td align="center">3</td><td align="center">response</td><td align="center">javax.servlet.http.HttpServletResponse</td><td align="center">服务器端回应客户端的请求操作</td></tr><tr><td align="center">4</td><td align="center">session</td><td align="center">javax.servlet.http.HttpSession</td><td align="center">描述每一个用户(登录)的信息</td></tr><tr><td align="center">5</td><td align="center">application</td><td align="center">javax.servlet.ServletContext</td><td align="center">描述整个当前项目的上下文</td></tr><tr><td align="center">6</td><td align="center">config</td><td align="center">javax.servlet.ServletConfig</td><td align="center">取得默认的配置信息</td></tr><tr><td align="center">7</td><td align="center">out</td><td align="center">javax.servlet.jsp.Writer</td><td align="center">进行输出，一般不用</td></tr><tr><td align="center">8</td><td align="center">page</td><td align="center">javax.lang.Object</td><td align="center">每一个页面都属于Object子类(一般不用)</td></tr><tr><td align="center">9</td><td align="center">exception</td><td align="center">java.lang.Throwable</td><td align="center">默认情况下，所有的异常都可以由容器处理，处理方式为输出错误信息并结束程序运行</td></tr></tbody></table><p>​    通过JavaEEAPI路径可以查询到每个对象有的方法</p><p>​    <strong>注意：在这九个内置对象中，前五个内置对象是精华需要重点了解学习</strong>，但要学好JSP开发，以上内置对象需要全部记住</p><h4 id="3-四种属性范围"><a href="#3-四种属性范围" class="headerlink" title="3. 四种属性范围"></a>3. 四种属性范围</h4><p>​    四种属性范围是整个JavaWeb的核心概念，如果不清楚四种属性范围，就无法更好的理解MVC，也无法进行有效的程序开发，以及后面理解Struts、SpringMVC等概念</p><p>​    <strong>属性范围的概念</strong></p><p>​    在任何一个Web项目中都会存在多个页面，如果一个对象需要跨越多个页面后依然可以被使用，这被称为属性的保存范围，在JSP中对属性的操作提供如下三个方法。</p><ol><li><p><strong>设置属性：<code>public void setAttribute(String name,Object value)</code></strong></p><p>属性名要String类型且不允许重复(重复就会覆盖)，value是Object类型意味着可以报存所有的Java类型</p></li><li><p><strong>取得属性：<code>public Object getAttribute(String name)</code></strong></p></li><li><p><strong>删除属性：<code>public void removeAttribute(String name)</code></strong></p></li></ol><p>​    在JSP里面一共有四个对象具备以上的三个方法：pageContext、request、session、application</p><p>​    四种属性范围刚好也是对应了这四个对象</p><h4 id="4-page属性范围-pageContext"><a href="#4-page属性范围-pageContext" class="headerlink" title="4. page属性范围(pageContext)"></a>4. page属性范围(pageContext)</h4><p>​    <strong>page属性范围：对象只能够在当前的JSP页面中使用</strong></p><p>​    注意：page属性范围不是只使用page对象操作，事实上没有这个对象，我们是使用pageContext对象完成</p><p>​    范例：通过pageContext设置本页面属性</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;编写文件page.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;设置属性pageContext.setAttribute(&quot;name&quot;,&quot;LXS&quot;);pageContext.setAttribute(&quot;this_time&quot;,new Date());%&gt;&lt;%&#x2F;&#x2F;取得属性String tname &#x3D; (String) pageContext.getAttribute(&quot;name&quot;);Date this_time &#x3D; (Date) pageContext.getAttribute(&quot;this_time&quot;);%&gt;&lt;h1&gt;姓名：&lt;%&#x3D;tname%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;时刻：&lt;%&#x3D;this_time%&gt;&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：pageContext的属性作用范围只在当前页面，如果发生跳转(不管是服务器跳转还是客户端跳转)那么pageContext所设置的属性的值不会保留到其他页面</p><h4 id="5-request属性范围-request"><a href="#5-request属性范围-request" class="headerlink" title="5. request属性范围(request)"></a>5. request属性范围(request)</h4><p>​    如果想在执行服务器跳转后依然可以取得设置的属性内容，则可以采用request属性范围</p><p>​    范例：使用request对象来传递服务器跳转的值</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;编写文件request_a.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;设置属性request.setAttribute(&quot;name&quot;,&quot;LXS&quot;);request.setAttribute(&quot;this_time&quot;,new Date());%&gt;&#x2F;&#x2F;服务器端跳转&lt;jsp:forward page&#x3D;&quot;request.jsp&quot;&#x2F;&gt;&#x2F;&#x2F;编写文件request_b.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;取得属性String tname &#x3D; (String) request.getAttribute(&quot;name&quot;);Date this_time &#x3D; (Date) request.getAttribute(&quot;this_time&quot;);%&gt;&lt;h1&gt;姓名：&lt;%&#x3D;tname%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;时刻：&lt;%&#x3D;this_time%&gt;&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：只有是服务器端跳转无论跳转几次，request设置的属性可以一直被保留下来</p><p>​    <strong>注意：服务器端跳转与客户端跳转的最大使用区别：服务器端跳转可以传递request属性，而客户端跳转不能传递request属性</strong></p><h4 id="6-session属性范围-session"><a href="#6-session属性范围-session" class="headerlink" title="6. session属性范围(session)"></a>6. session属性范围(session)</h4><p>​    如果不想受到跳转的类型限制，则可以继续扩大属性的保存范围，使用session范围，只要设置了一个session属性，那所有与之相关联的所有页面都可以访问。</p><p>​    范例：session对象的使用</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;编写文件session_a.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;设置属性session.setAttribute(&quot;name&quot;,&quot;LXS&quot;);session.setAttribute(&quot;this_time&quot;,new Date());%&gt;&#x2F;&#x2F;客户端跳转&lt;a href&#x3D;&quot;session_b&quot;&gt;跳转&lt;&#x2F;a&gt;&#x2F;&#x2F;编写文件session_b.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;取得属性String tname &#x3D; (String) session.getAttribute(&quot;name&quot;);Date this_time &#x3D; (Date) session.getAttribute(&quot;this_time&quot;);%&gt;&lt;h1&gt;姓名：&lt;%&#x3D;tname%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;时刻：&lt;%&#x3D;this_time%&gt;&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：虽然session属性范围可以包括所有的跳转页面，但如果关闭浏览器再次访问，session设置的属性会失效</p><p>​    <strong>session最简单的概念为用于客户端描述一个个用户的信息，每个用户的信息彼此独立</strong></p><h4 id="7-application属性范围-application"><a href="#7-application属性范围-application" class="headerlink" title="7. application属性范围(application)"></a>7. application属性范围(application)</h4><p>​    如果需要在浏览器关闭后，再次打开依然可以访问到我们设置的属性，那么需要将属性范围设置为application范围</p><p>​    范例：application对象的使用</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;编写文件application_a.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;设置属性application.setAttribute(&quot;name&quot;,&quot;LXS&quot;);application.setAttribute(&quot;this_time&quot;,new Date());%&gt;&#x2F;&#x2F;编写文件application_b.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;取得属性String tname &#x3D; (String) application.getAttribute(&quot;name&quot;);Date this_time &#x3D; (Date) application.getAttribute(&quot;this_time&quot;);%&gt;&lt;h1&gt;姓名：&lt;%&#x3D;tname%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;时刻：&lt;%&#x3D;this_time%&gt;&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：上述代码并没有写跳转语句，但当打开<code>application_a.jsp</code>再打开<code>application_b.jsp</code>，依然可以访问到设置的属性</p><p>​    <strong>注意：只要设置了此属性，那么意味着属性保存在服务器上，所有的用户都可以访问到，与是否关闭浏览器无关，但如果关闭服务器，则该设置的属性失效，即如果服务器不关闭，该设置的属性将一直存在</strong></p><h4 id="8-四种属性范围总结"><a href="#8-四种属性范围总结" class="headerlink" title="8. 四种属性范围总结"></a>8. 四种属性范围总结</h4><p>​    保存范围越大的属性，实际上占用的资源时间长，所以对于属性范围的选择几乎不会选择application范围(保存时间过长会占用服务器资源使得服务器性能下降)，剩下三种都会有使用到</p><h4 id="9-pageContext对象的进阶"><a href="#9-pageContext对象的进阶" class="headerlink" title="9. pageContext对象的进阶"></a>9. pageContext对象的进阶</h4><p>​    pageContext对象实际上可以设置上面的四种属性范围，在pageContext对应的类(<code>javax.servlet.jsp.PageContext</code>)的父类(<code>javax.servlet.jsp.JspContext</code>)中提供了另外一组<strong>重载</strong>的属性操作方法</p><ul><li><p><strong>设置属性：<code>public abstract void setAttribute(String name,Object value,int scope)</code></strong></p></li><li><p><strong>取得属性：<code>public abstract Object getAttribute(String name,int scope)</code></strong></p></li></ul><ul><li>**删除属性：<code>public abstract void removeAttribute(String name,int scope)**</code></li></ul><p>​    对于重载方法中的scope参数取值都在PageContext类里面定义</p><table><thead><tr><th align="center">scope在PageContext类中的定义</th><th align="center">类型</th><th align="center">对应数值</th></tr></thead><tbody><tr><td align="center">public static final int PAGE_SCOPE</td><td align="center">静态常量</td><td align="center">1</td></tr><tr><td align="center">public static final int REQUEST_SCOPE</td><td align="center">静态常量</td><td align="center">2</td></tr><tr><td align="center">public static final int SESSION_SCOPE</td><td align="center">静态常量</td><td align="center">3</td></tr><tr><td align="center">public static final int APPLICATION_SCOPE</td><td align="center">静态常量</td><td align="center">4</td></tr></tbody></table><p>​    范例pageContext对应方法的进阶使用</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;编写文件pageContext_a.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;设置属性pageContext.setAttribute(&quot;name&quot;,&quot;LXS&quot;,4);pageContext.setAttribute(&quot;this_time&quot;,new Date(),4);%&gt;&#x2F;&#x2F;编写文件pageContext_b.jsp&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;%&#x2F;&#x2F;取得属性String tname &#x3D; (String) application.getAttribute(&quot;name&quot;);Date this_time &#x3D; (Date) application.getAttribute(&quot;this_time&quot;);%&gt;&lt;h1&gt;姓名：&lt;%&#x3D;tname%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;时刻：&lt;%&#x3D;this_time%&gt;&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    pageContext是一个功能强大的对象，但是这个对象只能够在JSP中使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaEE03</title>
      <link href="/2022/10/09/javaEE03/"/>
      <url>/2022/10/09/javaEE03/</url>
      
        <content type="html"><![CDATA[<h2 id="web项目编写"><a href="#web项目编写" class="headerlink" title="web项目编写"></a>web项目编写</h2><h4 id="1-Idea对Javaweb的项目创建"><a href="#1-Idea对Javaweb的项目创建" class="headerlink" title="1. Idea对Javaweb的项目创建"></a>1. Idea对Javaweb的项目创建</h4><pre><code>   1. 点击新建项目，选择`Java Enterprise`，更改项目名称，将项目模板改为`Web 应用程序`，将应用程序服务器改为自己下载的Tomcat路径，下面都不用动，点`next`   2. 这里的第三方框架暂时都是用不上，只需要在已添加项中有`Servlet`就行   3. 点击完成Javaweb项目就创建完成</code></pre><p>​    <strong>项目结构的概述</strong></p><pre><code>   1. .idea不用管他，在src中编写文件   2. 在java文件夹中编写java代码   3. 在resources文件夹中放置配置文件   4. 在webapp中放jsp文件   5. 需要的包要在pom.xml中声明</code></pre><p>​    <strong>欢迎页与列表</strong></p><p>​    在项目新建后即可运行，点击运行可以运行项目自动生成的jsp欢迎页面，但在学习过程中需要列表来显示所有页面，此时可以通过修改Tomcat中的<code>conf/web.xml</code>文件的<code>welcome-file-list</code>来更改</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">//web.xml文件里的默认设置；名叫index的页面作为主页，这几个页面(不一定只有三个)都有的话显示优先级为从上到下<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.htm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    可以把这串设置复制到自己项目的xml文件中，然后自己修改首次登录页面(如果项目中没有设置默认是使用Tomcat提供的xml中的设置)，<strong>如果项目中没有名叫这几个的页面，则显示列表</strong></p><h4 id="2-Javaweb的jdbc连接"><a href="#2-Javaweb的jdbc连接" class="headerlink" title="2. Javaweb的jdbc连接"></a>2. Javaweb的jdbc连接</h4><p>​    使用jsp来引入jdbc，<strong>此时mysql的驱动程序应当复制一份到Tomcat的<code>lib</code>目录下</strong></p><blockquote><p>C:\Program Files\Apache Software Foundation\Tomcat 8.5_Tomcat8new\lib</p></blockquote><p>​    否则会出现错误：数据库无法找到</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">javax.servlet.ServletException: java.lang.ClassNotFoundException: com.mysql.jdbc.Driver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    还有一种情况是url书写时发生错误，如端口号写错，则提示错误：数据库连接异常</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">javax.servlet.ServletException: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    另外，在JSP中写JDBC没有对异常有强制处理，一旦出错就是报500，因为默认情况下，所有的异常都可以由容器处理，处理方式为输出错误信息并结束程序运行</p><h4 id="3-数据检查"><a href="#3-数据检查" class="headerlink" title="3. 数据检查"></a>3. 数据检查</h4><p>​    在系统开发当中，数据的安全性检查分为两个部分</p><ul><li><p>服务器的验证：由JSP文件负责验证</p></li><li><p>客户端验证：由JavaScript完成</p></li></ul><p>​    <strong>任何一个健壮的系统这两个验证都需要编写，即两端都要编写验证</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java16</title>
      <link href="/2022/09/20/Java16/"/>
      <url>/2022/09/20/Java16/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h4 id="1-JDBC的概念"><a href="#1-JDBC的概念" class="headerlink" title="1. JDBC的概念"></a>1. JDBC的概念</h4><p>​    JDBC是使用Java语言操作关系型数据库的一套API，JDBC保证了使用同一套Java代码可以操作不同的关系型数据库</p><p>​    JDBC的本质就是一套标准接口，每一种关系型数据库需要自己定义实现类(洋气的名字叫驱动)</p><p><a href="https://imgse.com/i/vqbZBq"><img src="https://s1.ax1x.com/2022/09/09/vqbZBq.png" alt="vqbZBq.png"></a></p><h4 id="2-MySql数据库"><a href="#2-MySql数据库" class="headerlink" title="2. MySql数据库"></a>2. MySql数据库</h4><p>​    <strong>(1).MySql数据库的介绍与安装</strong></p><p>​    用于小型的项目的数据存储，大型项目(几百万的数据)需要使用Oracle数据库</p><p>​    MySql数据库一般还是使用老版本的，新版本的不稳定</p><p>​    一般配置MySql的监听端口为3306，编码方式设置为utf8</p><p>​    <strong>(2).MySql数据库的使用</strong></p><pre><code> 1. 在命令行输入mysql 2. 连接mysql数据库：mysql -u用户名 -p密码 3. 新建数据库：CREATE DATABASE Student SET UTF8; 4. 查看所有数据库：SHOW DATABASE 5. 使用数据库：USE Student 6. 创建表：CREATE TABLE Tom(建表sql语句);   7. 分页操作：查询语句后空格接`LIMIT 0,5`，表示显示查询1-5行的数据</code></pre><p>​    <strong>(3).MySql数据库的JDBC连接</strong></p><p>​    要对MySQL进行开发则必须采用JDBC连接，JDBC连接需要先导入MySQL的驱动程序，此时需要将MySQL的驱动程序复制并加载到项目中</p><h4 id="3-JDBC快速入门"><a href="#3-JDBC快速入门" class="headerlink" title="3. JDBC快速入门"></a>3. JDBC快速入门</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>​    <strong>0. 创建工程，导入驱动jar包</strong></p><p>​    <strong>1. 注册驱动</strong></p><p>​    利用反射将类加载进内存</p>   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Drive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>2. 获取连接</strong></p>   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>3. 定义SQL语句</strong></p>   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> sql <span class="token operator">=</span>  <span class="token string">"update..."</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>4. 获取执行SQL对象</strong></p>   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>5. 执行SQL</strong></p>   <pre class="line-numbers language-java" data-language="java"><code class="language-java">stml<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>6. 处理返回结果</strong></p><p>​    <strong>7. 释放资源</strong></p><h5 id="范例：数据库的简单操作"><a href="#范例：数据库的简单操作" class="headerlink" title="范例：数据库的简单操作"></a>范例：数据库的简单操作</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token comment">//0.注册驱动</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1.获取连接</span><span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://127.0.0.1:3306/test"</span><span class="token punctuation">;</span><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span><span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>name<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2.定义sql语句</span><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"UPDATE user_table SET password =\"123456\" WHERE name = \"jack\""</span><span class="token punctuation">;</span><span class="token comment">//3.获取sql执行的对象：statement</span><span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4.执行sql：该方法返回的是影响的行数</span><span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5.处理结果</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6.释放资源</span>stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-DriverManager-驱动管理类"><a href="#4-DriverManager-驱动管理类" class="headerlink" title="4. DriverManager(驱动管理类)"></a>4. DriverManager(驱动管理类)</h4><p>​    DriveManager的作用</p><ol><li>注册驱动</li><li>获取数据库连接</li></ol><p>​    <strong>DriverManager的重要方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public <strong>static</strong> Connection getConnection(String url, String user, String password) throws SQLException</td><td align="center">方法</td><td align="center">尝试建立到给定数据库URL的连接，url为连接路径，语法jdbc:mysql://ip地址:端口号/数据库名称?参数键值对1&amp;参数键值对2，user为数据库用户名，password为数据库连接密码</td></tr><tr><td align="center">public <strong>static</strong> void registerDriver(Driver driver) throws SQLException</td><td align="center">方法</td><td align="center">向DriverManager注册给定的驱动程序。新加载的驱动程序类应该调用方法registerDriver，以使DriverManager知道它自己。如果驱动程序当前已注册，则不采取任何操作。</td></tr></tbody></table><p>​    <strong>注意：registerDriver在使用反射引用driver类时，其使用在driver类的静态块中，即只要引用driver类，则该类就会被加载</strong></p><p>​    在mysql5之后使用反射注册驱动的那段代码可以省略不写，因为在mysql提供的jar包中有该类的字符串，其会自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类</p><p>​    在url路径中，若连接的是本机mysql服务器且默认端口为3306，则可以简写为jdbc:mysql:///数据库名称?参数键值对1&amp;参数键值对2</p><p><strong>反射键值对：useSSL</strong></p><p>​    通过设置useSSL=false可以禁用安全连接方式，解决警告提示</p><h4 id="5-Connection-数据库连接类"><a href="#5-Connection-数据库连接类" class="headerlink" title="5. Connection(数据库连接类)"></a>5. Connection(数据库连接类)</h4><p>​    Connection的作用：</p><ol><li><p>获取执行SQL的对象</p><ol start="2"><li>管理事务</li></ol></li></ol><p>​    <strong>Connection提供的获取执行SQL对象的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Statement createStatement() throws SQLException</td><td align="center">方法</td><td align="center">创建用于向数据库发送SQL语句的Statement对象</td></tr><tr><td align="center">PreparedStatement prepareStatement(String sql) throws SQLException</td><td align="center">方法</td><td align="center">创建用于向数据库发送参数化SQL语句的PreparedStatement对象，<strong>其可以防止SQL注入</strong></td></tr></tbody></table><p>​    <strong>Connection提供的事务管理的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void setAutoCommit(boolean autoCommit) throws SQLException</td><td align="center">方法</td><td align="center">将此连接的自动提交模式设置为给定状态。如果连接处于自动提交模式，则其所有SQL语句将作为单个事务执行和提交。否则，它的SQL语句被分组到事务中，这些事务通过调用方法提交或方法回滚而终止。默认情况下，新连接处于自动提交模式。true为自动提交事务，false为手动提交事务</td></tr><tr><td align="center">void commit() throws SQLException</td><td align="center">方法</td><td align="center">提交操作：使自上次提交/回滚以来所做的所有更改永久化，并释放此连接对象当前持有的所有数据库锁。仅当禁用自动提交模式时，才应使用此方法。</td></tr><tr><td align="center">void rollback() throws SQLException</td><td align="center">方法</td><td align="center">回滚操作：撤消当前事务中所做的所有更改，并释放此连接对象当前持有的所有数据库锁。仅当禁用自动提交模式时，才应使用此方法。<strong>一般是在catch中对事务进行回滚</strong></td></tr></tbody></table><p>​    上述三个方法，可以使得对数据库的几个操作合在一起被事务接管，即发生成功则都成功，失败则都失败，若为自动提交模式，则每一次对数据库的操作看成为一个单独的操作。</p><p>​    <strong>Connection提供的释放资源的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void close() throws SQLException</td><td align="center">方法</td><td align="center">立即释放此Connection对象的数据库和JDBC资源，而不是等待它们自动释放。在已关闭的Connection对象上调用方法close是不行的。</td></tr></tbody></table><h4 id="6-Statement-SQL语句执行类"><a href="#6-Statement-SQL语句执行类" class="headerlink" title="6. Statement(SQL语句执行类)"></a>6. Statement(SQL语句执行类)</h4><p>​    Statement的作用</p><p>​    1. <strong>用于执行静态SQL语句并返回其生成的结果的对象。</strong>默认情况下，每个语句对象只能同时打开一个ResultSet对象。因此，如果一个ResultSet对象的读取与另一个对象的读取交错，则每个对象都必须由不同的语句对象生成。</p><p>​    Statement执行SQL语句的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">int executeUpdate(String sql) throws SQLException</td><td align="center">方法</td><td align="center">方法执行给定的SQL语句，该语句可以是INSERT、UPDATE或DELETE语句，也可以是不返回任何内容的SQL语句（如SQL DDL语句），返回值（1）SQL数据操作语言（DML）语句的行数，或（2）不返回的SQL语句，如某些DDL语句，返回值为0。<strong>注意：不能对PreparedStatement或CallableStatement调用此方法。</strong></td></tr><tr><td align="center">ResultSet executeQuery(String sql) throws SQLException</td><td align="center">方法</td><td align="center">执行要发送到数据库的sql语句，通常是静态sql SELECT语句，该语句返回单个ResultSet对象。<strong>注意：不能对PreparedStatement或CallableStatement调用此方法。</strong></td></tr></tbody></table><p>​    <strong>Statement提供的释放资源的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void close() throws SQLException</td><td align="center">方法</td><td align="center">立即释放此Statement对象的数据库和JDBC资源，而不是等到它自动关闭时再释放。通常，一用完资源就释放资源是一种好的做法，以避免占用数据库资源。对已关闭的Statement对象调用方法close没有效果。注意：关闭Statement对象时，其当前ResultSet对象（如果存在）也将关闭</td></tr></tbody></table><h4 id="7-ResultSet-结果集类"><a href="#7-ResultSet-结果集类" class="headerlink" title="7. ResultSet(结果集类)"></a>7. ResultSet(结果集类)</h4><p>​    ResultSet说明：</p><ol><li><p>表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。</p><ol start="2"><li>ResultSet对象保持指向其当前数据行的光标。最初，光标位于第一行之前。下一个方法将光标移动到下一行，因为当ResultSet对象中没有更多行时返回false，所以可以在while循环中使用它来迭代结果集。</li><li>默认的ResultSet对象是不可更新的，并且具有仅向前移动的光标。因此，只能从第一行到最后一行迭代一次。</li></ol></li></ol><p>​    ResultSet对查询结果查看的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">boolean next() throws SQLException</td><td align="center">方法</td><td align="center">将光标从当前位置向前移动一行。结果集光标最初位于第一行之前；对该方法的第一次调用接着使第一行成为当前行；第二次调用使第二行成为当前行，以此类推。当对下一个方法的调用返回false时即光标位于最后一行之后。任何需要当前行的ResultSet方法调用都将导致抛出SQLException。</td></tr><tr><td align="center">xxxx getXxxx(String columnLabel) throws SQLException</td><td align="center">方法</td><td align="center">获取当前ResultSet光标锁定行的名叫给定字符串的列名的值(Xxxx表示任何基本数据类型)</td></tr><tr><td align="center">xxxx getXxxx(int columnIndex) throws SQLException</td><td align="center">方法</td><td align="center">获取当前ResultSet光标锁定行的第给定索引号的列的值，为空返回null(Xxxx表示任何基本数据类型)，参数columnIndex-第一列为1，第二列为2以此类推</td></tr></tbody></table><p>​    注意：第二和第三个方法的获取值要与数据库表中定义的值保持一致</p><p>​    一般可以将查询结果多个数据封装成一个对象然后再将对象放在集合类中，这样只需将集合对象给页面，页面就可以展示数据。</p><p>​    <strong>ResultSet提供的释放资源的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void close() throws SQLException</td><td align="center">方法</td><td align="center">立即释放此ResultSet对象的数据库和JDBC资源，对已关闭的ResultSet对象调用方法close是不行的。</td></tr></tbody></table><h4 id="8-SQL注入"><a href="#8-SQL注入" class="headerlink" title="8. SQL注入"></a>8. SQL注入</h4><p>​    <strong>SQL注入是通过对输入进行操作来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法</strong></p><p>​    在密码框输入如下代码<code>&#39;or &#39;1&#39; = &#39;1</code></p><p>​    显示登录成功</p><p>​    原因：再写登录判断的SQL语句为<code>select * from user where username=&#39;&quot;+name+&quot;&#39; and password = &#39;&quot;+pwd+&quot;&#39;;</code></p><p>​    此时由于是拼字符串，传值<code>name</code>和<code>pwd</code>此时SQL语句变为了<code>select * from user where username=&#39;ron&#39; and password =&#39;&#39; or &#39;1&#39; = &#39;1&#39;</code>，由于<code>and</code>比<code>or</code>先执行，此时SQL语句变成了恒等式。</p><h4 id="9-PreparedStatement"><a href="#9-PreparedStatement" class="headerlink" title="9. PreparedStatement"></a>9. PreparedStatement</h4><p>​    public interface <strong>PreparedStatement</strong> extends Statement</p><p>​    作用：预编译SQL语句的对象，这样做可以预防SQL注入的问题</p><h5 id="PreparedStatement的使用"><a href="#PreparedStatement的使用" class="headerlink" title="PreparedStatement的使用"></a>PreparedStatement的使用</h5><ol><li><p>通过Connection获取PreparedStatement对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//SQL语句中的参数值，使用？占位符替代</span><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from user where username = ? and password = ?"</span><span class="token punctuation">;</span><span class="token comment">//通过Connection对象获取，并传入对应的sql语句</span><span class="token class-name">PreparedStatement</span> pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">preparedStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>设置参数值</p><p> 通过PreparedStatement对象提供的方法设置<code>？</code>的参数：<code>setXxxx(参数1，参数2)</code>：给<code>？</code>赋值</p><ul><li>Xxxx：数据类型</li><li>参数：<ul><li>参数1：<code>？</code>的位置编号，从1开始</li><li>参数2：<code>？</code>的值</li></ul></li></ul></li><li><p>通过PreparedStatement对象继承父类Statement的空参方法执行SQL</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意：不需要在传递sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h5 id="preparedStatement上述操作涉及方法的详细文档"><a href="#preparedStatement上述操作涉及方法的详细文档" class="headerlink" title="preparedStatement上述操作涉及方法的详细文档"></a>preparedStatement上述操作涉及方法的详细文档</h5><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">PreparedStatement  prepareStatement(String sql) throws SQLException</td><td align="center">方法</td><td align="center">创建用于向数据库发送参数化SQL语句的PreparedStatement对象。</td></tr><tr><td align="center">void setXxxx(int parameterIndex, Xxxx y) throws SQLException</td><td align="center">方法</td><td align="center">将SQL语句中<code>？</code>对应的值进行用y替换，parameterIndex指第几个<code>？</code>，计数从1开始</td></tr><tr><td align="center">int executeUpdate() throws SQLException</td><td align="center">方法</td><td align="center">在此PreparedStatement对象中执行SQL语句，该对象必须是SQL数据操作语言（DML）语句，如INSERT、UPDATE或DELETE；或不返回任何内容的SQL语句，如DDL语句。返回值：（1）SQL数据操作语言（DML）语句的行数，或（2）不返回任何内容的SQL语句的行计数</td></tr><tr><td align="center">ResultSet executeQuery() throws SQLException</td><td align="center">方法</td><td align="center">在此PreparedStatement对象中执行SQL查询，并返回查询生成的ResultSet对象。</td></tr></tbody></table><h5 id="PreparedStatement防止SQL注入的原因"><a href="#PreparedStatement防止SQL注入的原因" class="headerlink" title="PreparedStatement防止SQL注入的原因"></a>PreparedStatement防止SQL注入的原因</h5><p>​    如再将这段代码放入<code>&#39;or &#39;1&#39; = &#39;1</code>密码部分进行SQL注入，此时，会将这段字符串进行转义变为<code>\&#39;or \&#39;1\&#39; = \&#39;1</code>，此时就解决了SQL注入的问题</p><h5 id="PreparedStatement的预编译功能"><a href="#PreparedStatement的预编译功能" class="headerlink" title="PreparedStatement的预编译功能"></a>PreparedStatement的预编译功能</h5><ol><li><p>在获取PreparedStatement对象时，就已经将sql语句发送给mysql服务器进行检查编译</p><ol start="2"><li>如果将SQL语句的字符串每一次都是写死，那么每一次执行时都需要先检查再编译最后执行，而使用<code>？</code>替代后，同一个SQL模板传不同参数的SQL语句可以只检查和编译一次，之后只需要执行SQL就好</li><li>预编译可以使得性能更高。</li></ol></li></ol><p>​    <strong>注意：PreparedStatement的预编译功能是默认关闭的，<em>预编译功能的开启：<code>useServerPrepStmts=true</code>;这段代码属于反射键值对</em></strong></p><h5 id="PreparedStatement使用完后也需要对占用资源进行释放"><a href="#PreparedStatement使用完后也需要对占用资源进行释放" class="headerlink" title="PreparedStatement使用完后也需要对占用资源进行释放"></a>PreparedStatement使用完后也需要对占用资源进行释放</h5><h4 id="10-JDBC资源的释放"><a href="#10-JDBC资源的释放" class="headerlink" title="10. JDBC资源的释放"></a>10. JDBC资源的释放</h4><p>​    <strong>JDBC程序执行结束后，需要将与数据库进行交互的对象释放掉，通常是ResultSet,Statement,Connection</strong>。这几个对象中尤其是Connection对象是非常稀有的<br>​    将资源释放的代码一般写入到finally的代码块中。</p><p>​    <strong>注意：PreparedStatement是继承了Statement的，其继承了close方法，其也需要去手动释放</strong></p><h4 id="11-数据库连接池"><a href="#11-数据库连接池" class="headerlink" title="11. 数据库连接池"></a>11. 数据库连接池</h4><p>​    数据库连接池是个容器，负责分配管理数据库的连接</p><p>​    它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p><p>​    释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p><h5 id="数据库连接池的实现-Interface-DataSource"><a href="#数据库连接池的实现-Interface-DataSource" class="headerlink" title="数据库连接池的实现(Interface DataSource)"></a>数据库连接池的实现(Interface DataSource)</h5><p>​    Java官方提供的数据库连接池标准接口，由第三方来实现该接口</p><p>​    常用的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li><strong>Druid</strong>：阿里巴巴开发，目前学习这个</li></ul><p>​    <strong>该类中常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Connection getConnection() throws SQLException</td><td align="center">方法</td><td align="center">尝试与此DataSource对象表示的数据源建立连接。</td></tr></tbody></table><h5 id="Driud使用步骤"><a href="#Driud使用步骤" class="headerlink" title="Driud使用步骤"></a>Driud使用步骤</h5><ol><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ol><p>​    范例：Druid的使用</p><ol><li><p>配置文件的定义druid.properties</p><pre class="line-numbers language-none"><code class="language-none">driverClassName&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称username&#x3D;rootpassword&#x3D;1234# 初始化连接数量initialSize&#x3D;5# 最大连接数maxActive&#x3D;10# 最大等待时间maxWait&#x3D;3000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p>java代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token comment">//加载配置文件</span><span class="token class-name">Properties</span> prop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>prop<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"配置文件绝对路径"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取连接池对象</span><span class="token class-name">DataSource</span> dataSource <span class="token operator">=</span> <span class="token class-name">DruidDataSourceFactory</span><span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取数据库连接Connection</span><span class="token class-name">Connection</span> connection <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端08</title>
      <link href="/2022/04/05/%E5%89%8D%E7%AB%AF08/"/>
      <url>/2022/04/05/%E5%89%8D%E7%AB%AF08/</url>
      
        <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h4 id="1-事件"><a href="#1-事件" class="headerlink" title="1. 事件"></a>1. 事件</h4><p>​    事件处理是整个JavaScript的核心操作</p><p>​    在页面上任何的操作都可能被称为事件源，而对每一个事件可以自定义处理操作，例如页面加载，鼠标移动等都被称为事件源</p><p>​    在JavaScript中，事件都是以<code>onXXX</code>的形式命名的</p><p>​    最基础的静态事件即在HTML标签中声明需要该事件并定义事件名要加小括号和分号，如<code>XXXX();</code>，而后在JavaScript中定义与事件名相同的函数</p><p>​    <strong>Javascript是基于对象的编程语言，所有的对象都在元素上，即每一个元素都属于一个JavaScript的对象</strong></p><h4 id="2-页面加载事件与页面卸载事件"><a href="#2-页面加载事件与页面卸载事件" class="headerlink" title="2. 页面加载事件与页面卸载事件"></a>2. 页面加载事件与页面卸载事件</h4><p>​    注意：这两个事件只能够在<code>&lt;body&gt;</code> 元素中进行处理</p><h5 id="1-页面加载事件：onload"><a href="#1-页面加载事件：onload" class="headerlink" title="(1). 页面加载事件：onload"></a>(1). 页面加载事件：onload</h5><p>​    页面加载完成后执行的动作</p><p>​    页面加载时，大致可以分为以下几个步骤：</p><p>​        1. 开始解析HTML文档结构</p><p>​        2. 加载外部样式表及JavaScript脚本</p><p>​        3. 解析执行JavaScript脚本</p><p>​        4. DOM树渲染完成</p><p>​        5. 加载未完成的外部资源（如 图片）</p><p>​        6. 页面加载成功</p><p>​    范例：<code>onload</code> 的基础使用</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">function</span> <span class="token function">loadHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"欢迎来到测试页面"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loadHandle();<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：在使用HTML标签中要加多个事件，则在<code>;</code>继续加就可以了</p><h5 id="2-页面卸载事件：onunload"><a href="#2-页面卸载事件：onunload" class="headerlink" title="(2). 页面卸载事件：onunload"></a>(2). 页面卸载事件：onunload</h5><p>​    onunload 事件在用户退出页面时发生</p><p>​    范例：使用onunload事件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">function</span> <span class="token function">unloadHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"再见"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onunload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>unloadHandle();<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：这个代码为实现，应该是浏览器的问题</p><h4 id="3-鼠标事件"><a href="#3-鼠标事件" class="headerlink" title="3. 鼠标事件"></a>3. 鼠标事件</h4><table><thead><tr><th align="center"><strong>事件类型</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">click</td><td align="center">单击鼠标左键时发生，如果右键也按下则不会发生。当用户的焦点在按钮上，并按了回车键时，同样会触发事件</td></tr><tr><td align="center">dblclick</td><td align="center">双击鼠标左键时发生，如果右键也按下则不会发生</td></tr><tr><td align="center">mousedown</td><td align="center">单击任意一个鼠标按钮时发生</td></tr><tr><td align="center">mouseout</td><td align="center">鼠标指针位于元素上，且将要移出元素的边界时发生</td></tr><tr><td align="center">mouseover</td><td align="center">鼠标指针移入元素时触发</td></tr><tr><td align="center">mouseup</td><td align="center">松开任意一个鼠标按钮时发生</td></tr><tr><td align="center">mousemove</td><td align="center">鼠标在某个元素上移动时发生</td></tr></tbody></table><p>​    范例：使用单击点击事件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    提升：鼠标经过表格变色</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">.table1</span><span class="token punctuation">&#123;</span>                <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>                <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>                <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>                <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>                <span class="token property">background-color</span><span class="token punctuation">:</span> #f2f2f2<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>            <span class="token selector">td</span><span class="token punctuation">&#123;</span>                <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">function</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                obj<span class="token punctuation">.</span>bgColor <span class="token operator">=</span> color<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>table1<span class="token punctuation">"</span></span> <span class="token attr-name">cellpadding</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10px<span class="token punctuation">"</span></span> <span class="token attr-name">cellspacing</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0px<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">onmousemove</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>change(this,<span class="token punctuation">'</span>white<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>姓名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>年龄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>性别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">onmousemove</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>change(this,<span class="token punctuation">'</span>white<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">onmousemove</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>change(this,<span class="token punctuation">'</span>white<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>李四<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：bgcolor是HTML，bgColor是JavaScript</strong></p><h4 id="4-动态设置事件"><a href="#4-动态设置事件" class="headerlink" title="4. 动态设置事件"></a>4. 动态设置事件</h4><p>​    在JavaScript中，事件的绑定除了在元素上使用<code>onXXX</code> 静态的定义之外，还可以动态的设置</p><h5 id="1-动态设置事件的全过程"><a href="#1-动态设置事件的全过程" class="headerlink" title="(1).动态设置事件的全过程"></a>(1).动态设置事件的全过程</h5><p>​    范例：使用onload在页面加载时对事件进行处理</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"事件触发！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//window为JS的内置对象</span>            window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//匿名函数</span>                <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：所有的动态设置的事件都可以在onload里面进行动态配置，但此时需要取得明确的元素对象，可以使用<code>document.getElementById(元素ID)</code> 的操作方式取得元素对象，此时该方式应该写在onload里面</strong></p><p>​    注意：id是整个JavaScript的操作核心所在，必须存在</p><p>​    <strong>然后通过使用<code>元素ID赋予的变量.addEventListener(事件类型，处理函数名称，触发时机)</code> 对该元素进行动态配置事件，<em>事件类型要加双引号，处理函数名称后面不需要括号，触发时机一般设置为false表示在事件的触发过程进行处理，阻止事件冒泡</em>，其也要写在onload里面</strong></p><p>​    动态设置操作事件的好处在于HTML代码不会和JavaScript代码混合在一起</p><h5 id="2-范例：图片的轮转"><a href="#2-范例：图片的轮转" class="headerlink" title="(2).范例：图片的轮转"></a>(2).范例：图片的轮转</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">img</span><span class="token punctuation">&#123;</span>                <span class="token property">width</span><span class="token punctuation">:</span> 598px<span class="token punctuation">;</span>                <span class="token property">padding</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>                <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token selector">div</span><span class="token punctuation">&#123;</span>                <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token selector">button</span><span class="token punctuation">&#123;</span>                <span class="token property">margin-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">var</span> imges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">"img/01.jpg"</span><span class="token punctuation">,</span><span class="token string">"img/02.jpg"</span><span class="token punctuation">,</span><span class="token string">"img/03.jpg"</span><span class="token punctuation">,</span><span class="token string">"img/04.jpg"</span><span class="token punctuation">,</span><span class="token string">"img/05.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//匿名函数</span>                <span class="token keyword">var</span> pic <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"pic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> next <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"next"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> up <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"up"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                next<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">>=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                     pic<span class="token punctuation">.</span>src <span class="token operator">=</span> imges<span class="token punctuation">[</span><span class="token operator">++</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span>               up<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        index <span class="token operator">=</span> imges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    pic<span class="token punctuation">.</span>src <span class="token operator">=</span> imges<span class="token punctuation">[</span><span class="token operator">--</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pic<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img/01.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>上一张<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>next<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>下一张<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-innerHTML"><a href="#5-innerHTML" class="headerlink" title="5. innerHTML"></a>5. innerHTML</h4><p>​    JavaScript可使用<code>document.getElementById(id).innerHTML = “新内容”</code>来修改id元素内的HTML内容</p><p>​    范例：使用innerHTML</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">           <span class="token keyword">function</span> <span class="token function">clickb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"修改后的内容"</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>初始内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clickb();<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击修改内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>innerHTML和document.write的区别</strong></p><pre><code>1. document.write：是直接写入到页面的内容流，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致网页内容全部被重写 2. innerHTML：是DOM页面元素的一个属性，代表该元素的html内容。（获取div里面的内容 ，修改内容）你可以精确到某一个具体的元素来进行更改，其不会导致页面全部重绘</code></pre><h4 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h4><p>​    在JavaScript中，Date对象用来表示日期和时间</p><p>​    范例：获取时间</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">           <span class="token keyword">var</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    在JavaScript中，提供<code>setTimeout(函数，时间-毫秒)</code>函数，该函数是指在指定时间后执行一次指定函数，常用作定时器</p><p>​    范例：实现页面时钟</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> date<span class="token punctuation">;</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//过一秒执行该函数</span>        <span class="token punctuation">&#125;</span>        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：此时JavaScript代码放在body后面，如果放前面就无法显示</p><p>​    <strong>JavaScript放在head和放在body后的区别</strong></p><pre><code>1. 放在head中：需调用才执行的脚本或事件触发执行的脚本放在HTML的head部分中。当你把脚本放在head部分中时，可以保证脚本在任何调用之前被加载 2. 放在body后：当页面被加载时立即执行的脚本放在HTML的body部分。放在body部分的脚本通常被用来生成页面的内容。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数补充</title>
      <link href="/2022/03/28/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/"/>
      <url>/2022/03/28/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言中实现数据结构的常用函数"><a href="#C语言中实现数据结构的常用函数" class="headerlink" title="C语言中实现数据结构的常用函数"></a>C语言中实现数据结构的常用函数</h2><h4 id="1-malloc-函数"><a href="#1-malloc-函数" class="headerlink" title="1. malloc()函数"></a>1. malloc()函数</h4><p>​    头文件：#include &lt;malloc.h&gt; 或 #include &lt;alloc.h&gt; (注意：alloc.h 与 malloc.h 的内容是完全一致的)</p><p>​    功能：分配长度为num_bytes字节的内存块</p><p>​    说明：如果分配成功则返回指向被分配内存的指针，<strong>否则返回空指针NULL</strong></p><p>​    当内存不再使用时，应使用free()函数将内存块释放</p><h4 id="2-exit-函数"><a href="#2-exit-函数" class="headerlink" title="2. exit()函数"></a>2. exit()函数</h4><p>​    所在头文件：stdlib.h<br>​    功 能: 关闭所有文件，终止正在执行的进程。<br>​    exit(1)表示异常退出.这个1是返回给操作系统的。<br>​    exit(x)（x不为0）都表示异常退出<br>​    exit(0)表示正常退出<br>​    exit()的参数会被传递给一些操作系统，包括UNIX,Linux,和MS DOS，以供其他程序使用</p><p>​    <em>注意：return是函数的退出(返回)；exit是进程的退出，return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束</em></p><h4 id="3-return-函数的使用"><a href="#3-return-函数的使用" class="headerlink" title="3. return()函数的使用"></a>3. return()函数的使用</h4><p>​    即使返回值为void的时，最好可以写为</p><pre class="line-numbers language-none"><code class="language-none">return;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    可以有效的告诉别人这个函数已经结束了，不写的话可能别人不知道你的函数已经终止了</p><p>​    <strong>注意：如果函数需要有两个或多个返回值，需要使用指针来帮助存储</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构02</title>
      <link href="/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/"/>
      <url>/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/</url>
      
        <content type="html"><![CDATA[<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h4 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="1. 线性结构"></a>1. 线性结构</h4><p>​    把所有的结点(类似数组的元素，逻辑上独立的个体)用一根线穿起来</p><p>​    <strong>分类</strong></p><ul><li>连续存储【数组】</li><li>离散存储【链表】</li></ul><p>​    <strong>应用</strong></p><ul><li>栈</li><li>队列</li></ul><h4 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h4><p>​    元素类型相同，大小相等</p><p>​    数组的优缺点： </p><h4 id="3-实现动态数组以及其相关操作函数"><a href="#3-实现动态数组以及其相关操作函数" class="headerlink" title="3. 实现动态数组以及其相关操作函数"></a>3. 实现动态数组以及其相关操作函数</h4><h5 id="1-动态数组的基础设置"><a href="#1-动态数组的基础设置" class="headerlink" title="(1). 动态数组的基础设置"></a>(1). 动态数组的基础设置</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> <span class="token comment">//包含了exit()函数</span></span><span class="token keyword">struct</span> <span class="token class-name">Arr</span><span class="token punctuation">&#123;</span><span class="token comment">//设定数组的数据类型</span>    <span class="token keyword">int</span> <span class="token operator">*</span> pBase<span class="token punctuation">;</span><span class="token comment">//存储数组第一个元素的地址</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment">//数组所能容纳的最大元素的个数</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span><span class="token comment">//当前数组有效元素的个数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span> arr<span class="token punctuation">;</span><span class="token comment">//定义数组指针，未初始化</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-动态数组的初始化函数"><a href="#2-动态数组的初始化函数" class="headerlink" title="(2). 动态数组的初始化函数"></a>(2). 动态数组的初始化函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">init_arr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//传需要初始化的数组的指针和需要创建的大小</span>    <span class="token punctuation">(</span><span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">.</span>pBase <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"动态内存分配失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        pArr<span class="token operator">-></span>len <span class="token operator">=</span> length<span class="token punctuation">;</span>        pArr<span class="token operator">-></span>cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-动态数组的输出函数"><a href="#3-动态数组的输出函数" class="headerlink" title="(3). 动态数组的输出函数"></a>(3). 动态数组的输出函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">show_arr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数组为空\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>pArr<span class="token operator">-></span>cnt <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-动态数组是否为空的判断函数"><a href="#4-动态数组是否为空的判断函数" class="headerlink" title="(4). 动态数组是否为空的判断函数"></a>(4). 动态数组是否为空的判断函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span> pArr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> pArr<span class="token operator">-></span>cnt<span class="token punctuation">)</span>        <span class="token keyword">return</span> ture<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-向动态数组中追加元素的函数"><a href="#5-向动态数组中追加元素的函数" class="headerlink" title="(5). 向动态数组中追加元素的函数"></a>(5). 向动态数组中追加元素的函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">append_arr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span> pArr<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//满返回false</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_full</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment">//不满时追加</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>pArr<span class="token operator">-></span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token punctuation">(</span>pArr<span class="token operator">-></span>cnt<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-动态数组是否为满的判断函数"><a href="#6-动态数组是否为满的判断函数" class="headerlink" title="(6). 动态数组是否为满的判断函数"></a>(6). 动态数组是否为满的判断函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">is_full</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span> pArr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pArr<span class="token operator">-></span>cnt <span class="token operator">==</span> pArr<span class="token operator">-></span>len<span class="token punctuation">)</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7-向动态数组中特定位置插入元素的函数"><a href="#7-向动态数组中特定位置插入元素的函数" class="headerlink" title="(7). 向动态数组中特定位置插入元素的函数"></a>(7). 向动态数组中特定位置插入元素的函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">insert_arr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span><span class="token operator">*</span> pArr<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//指定pos的值从1开始</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_full</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> pos<span class="token operator">></span>pArr<span class="token operator">-></span>cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment">//这个for循环是健壮的，如果满了是不会执行的</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>pArr<span class="token operator">-></span>cnt<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">>=</span>pos<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">(</span>pArr<span class="token operator">-></span>cnt<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-从动态数组某个位置删除元素并返回的函数"><a href="#8-从动态数组某个位置删除元素并返回的函数" class="headerlink" title="(8).从动态数组某个位置删除元素并返回的函数"></a>(8).从动态数组某个位置删除元素并返回的函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">delete_arr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span> pArr <span class="token punctuation">,</span> <span class="token keyword">int</span> pos <span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span> pVal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> pos<span class="token operator">></span>pArr<span class="token operator">-></span>cnt<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token operator">*</span>pVal <span class="token operator">=</span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>pos <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>pArr<span class="token operator">-></span>cnt <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pArr<span class="token operator">-></span>cnt<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9-把动态数组倒置的函数"><a href="#9-把动态数组倒置的函数" class="headerlink" title="(9). 把动态数组倒置的函数"></a>(9). 把动态数组倒置的函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inversion_arr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span> pArr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> pArr<span class="token operator">-></span>cnt<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        tmp <span class="token operator">=</span> pArr<span class="token operator">-></span>pBAse<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token operator">++</span>i<span class="token punctuation">;</span>        <span class="token operator">--</span>j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="10-对动态数组进行排序的函数"><a href="#10-对动态数组进行排序的函数" class="headerlink" title="(10). 对动态数组进行排序的函数"></a>(10). 对动态数组进行排序的函数</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第一个先和所有的比，比完之后留下最小的数，然后再比第二个以此类推</span><span class="token keyword">void</span> <span class="token function">sort_arr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span> pArr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>t<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>pArr<span class="token operator">-></span>cnt <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">;</span> j<span class="token operator">&lt;</span>pArr<span class="token operator">-></span>cnt <span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                t <span class="token operator">=</span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                pArr<span class="token operator">-></span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-可以自行扩展的函数"><a href="#4-可以自行扩展的函数" class="headerlink" title="4. 可以自行扩展的函数"></a>4. 可以自行扩展的函数</h4><ul><li>查找数组中是否含有某元素（find_val_arr()）</li><li>删除数组中所有的元素（deleteAll()）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端07</title>
      <link href="/2022/03/24/%E5%89%8D%E7%AB%AF07/"/>
      <url>/2022/03/24/%E5%89%8D%E7%AB%AF07/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><h4 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1. JavaScript简介"></a>1. JavaScript简介</h4><p>​    <strong>JavaScript是一种基于对象的编程语言，所有的对象已经由浏览器提供好了</strong>；而Java是属于面向对象语言，面向对象语言是强调类的设计</p><p>​    JavaScript和Java没有本质关系，JavaScript的前身称为LiveScript，后来由于Java在浏览器技术端的发展，后来更名为JavaScript，最新的叫法称为EcmaScript</p><p>​    后来发展超出了JavaScript的预期，它后期开始模拟面向对象编程，可以进行服务器端编程(即Node.js)</p><h4 id="2-JavaScript的使用"><a href="#2-JavaScript的使用" class="headerlink" title="2. JavaScript的使用"></a>2. JavaScript的使用</h4><p>​    JavaScript的基础语法和Java很相似，JavaScript是嵌入在HTML语法之中的编程语言，可以使用”<code>&lt;script&gt;</code> “标记内进行使用，这样就可以实现动态页面的操作效果(前台页面)</p><p>​    范例：第一个JavaScript小程序</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">//新建一个html文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>JavaScript<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//弹框hello world</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：<code>type=&quot;text/javascript&quot;</code>此处表示的是使用JavaScript脚本语言，而也可以更换为VBScript、ColdFusion脚本语言，具体看你所要使用的脚本语言</p><h4 id="3-JavaScript文件的导入"><a href="#3-JavaScript文件的导入" class="headerlink" title="3. JavaScript文件的导入"></a>3. JavaScript文件的导入</h4><p>​    JavaScript可以嵌入到HTML文件中使用，但是实际开发过程中，JS的代码是很多的，如果将JS代码写在HTML页面中，就会非常难以维护</p><p>​    所以可以单独建立一个<code>*.js</code>的文件，将JavaScript代码写入，然后再将需要的<code>*.js</code>文件进行导入</p><p>​    范例：通过src属性导入js文件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">//导入js文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>JavaScript<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/demo.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-JavaScript基础语法"><a href="#4-JavaScript基础语法" class="headerlink" title="4. JavaScript基础语法"></a>4. JavaScript基础语法</h4><p>​    JavaScript语法上和Java语法非常类似，除了一些关键字不同之外几乎没什么区别</p><h5 id="1-document-write-方法"><a href="#1-document-write-方法" class="headerlink" title="(1).document.write()方法"></a>(1).<code>document.write()</code>方法</h5><p>​    JavaScript里使用“<code>document.write()</code>”，其可以输出HTML代码；其语法上的使用等同于Java的“<code>system.out.println()</code>”</p><p>​    “<code>document.write()</code>”可以控制HTML代码的输出(可以写标签)</p><p>​    范例：使用“<code>document.write()</code>”输出HTML</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>hello&lt;/h1>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    注意：使用js输出页面的话，代码会在原先HTML代码所写的页面之上，所以不会使用这类函数来实现内容输出，以前应该是用这个函数来调试的，现在被淘汰了，用的是下面这个</p><h5 id="2-console-log-方法"><a href="#2-console-log-方法" class="headerlink" title="(2). console.log()方法"></a>(2). <code>console.log()</code>方法</h5><p>​    实现信息的后台输出，通过使用这个方法可以对写的代码进行调试</p><p>​    范例：使用<code>console.log()</code>方法</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"这是后台输出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    在浏览器中，按下F12进入调试控制台，可以在console(控制台)那里看到输出</p><h4 id="5-定义变量"><a href="#5-定义变量" class="headerlink" title="5. 定义变量"></a>5. 定义变量</h4><p>​    在JavaScript中定义变量的格式没有太严格的要求，所有的变量只需要一个<code>var</code>关键字定义即可，至于变量的具体类型是根据为其赋值的结果来确定的</p><h5 id="1-typeof关键字"><a href="#1-typeof关键字" class="headerlink" title="(1). typeof关键字"></a>(1). typeof关键字</h5><p>​    在JavaScript中，对于未知的变量可以使用</p><blockquote><p>typeof 变量名</p></blockquote><p>​    来确定变量的类型，使用上面两种输出方法输出查看即可</p><h5 id="2-undefined类型"><a href="#2-undefined类型" class="headerlink" title="(2). undefined类型"></a>(2). <code>undefined</code>类型</h5><p>​    如果使用var但是不予给其赋值，那么它的类型就为<code>undefined</code>类型，这个类型是可以通过if语句判断的</p><h5 id="3-if-语句"><a href="#3-if-语句" class="headerlink" title="(3). if()语句"></a>(3). if()语句</h5><p>​    JavaScript的if语句中的判断内容不像Java那样严格，可以使用变量直接判断(和C语言类似)，如果变量类型为<code>undefined</code>，在if语句中为假</p><blockquote><p>if(num);  //其中num变量为undefined类型，判断结果为false</p></blockquote><h5 id="4-单引号和双引号同义"><a href="#4-单引号和双引号同义" class="headerlink" title="(4). 单引号和双引号同义"></a>(4). 单引号和双引号同义</h5><p>​    在JavaScript中，变量不管是用单引号赋值还是双引号进行赋值，获得变量的类型都为<code>String</code>类型；即单引号或双引号得到的都是字符串，<strong>JavaScript对于字符串的操作函数和Java是类似的操作</strong></p><p>​    范例：对字符串进行拆分</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"hello wold !"</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按空格拆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length <span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>"</span><span class="token operator">+</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"&lt;/h1>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    此时result的类型为object类型，拆出来的元素都为String类型</p><p>​    <strong>注意：JavaScript中的字符串比较只提供“==”这一种操作</strong></p><h5 id="5-while循环、switch等操作与Java的结构很类似"><a href="#5-while循环、switch等操作与Java的结构很类似" class="headerlink" title="(5). while循环、switch等操作与Java的结构很类似"></a>(5). while循环、switch等操作与Java的结构很类似</h5><h5 id="6-数组"><a href="#6-数组" class="headerlink" title="(6). 数组"></a>(6). 数组</h5><p>​    在JavaScript中的数组本身是以一个对象的形式出现，所以数组的创建需要使用关键字new完成</p><p>​    范例：定义数组</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">//数组的动态初始化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    ressult<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>//数组的静态初始化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：在JavaScript中的数组元素语法没有严格要求，其定义的数组长度上是没有限制的，其数组本身就为动态数组，而数组的元素可以是任意的</p><p>​    可以看到从数组的本质上来说，虽然和Java类似，但是要比Java的数组功能强大，只不过很少会出现这种要直接定义数组的操作</p><h5 id="7-全局变量"><a href="#7-全局变量" class="headerlink" title="(7).全局变量"></a>(7).全局变量</h5><p>​    在JavaScript中，定义变量时，可以不使用var进行定义，直接写，那这样弄出来的变量从语法上来说，属于全局变量(几乎没用)</p><h4 id="6-定义函数"><a href="#6-定义函数" class="headerlink" title="6. 定义函数"></a>6. 定义函数</h4><p>​    JavaScript中定义函数的基本语法</p><pre class="line-numbers language-none"><code class="language-none">function 参数名称(参数)&#123;&#x2F;&#x2F;不需要声明返回值类型return 返回值;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    注意：参数可以不写类型</p><p>​    范例：实现加法操作</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：在Java中对语法有严格限制，定义多少个参数，函数就只能引用几个参数，但JavaScript没有严格语法限制，</p><p>​    像当前程序如果只传一个参数，只能获得一个NaN(不是一个数字)</p><p>​    此时可以通过<code>函数名称.arguments</code>来修改程序，其表示取得函数的参数内容，返回一个数组，然后通过length，查看长度来修改</p><p>​    程序：修改当前程序</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>add<span class="token punctuation">.</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>    <span class="token keyword">return</span> <span class="token string">"不能完成的操作"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：此时程序拥有了健壮性，但真实情况不可能允许这样写代码，所以应该自己遵守语法严格，怎么定义怎么使用</p><h4 id="7-JavaScript的面向对象"><a href="#7-JavaScript的面向对象" class="headerlink" title="7. JavaScript的面向对象"></a>7. JavaScript的面向对象</h4><p>​    JavaScript原本是属于基于对象编程的语言，但后期人们希望JavaScript可以支持面向对象的编程，但其本身不是面向对象编程，于是就利用函数模拟面向对象编程</p><p>​    范例：类与对象的使用</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">function</span> <span class="token function">Book</span><span class="token punctuation">(</span><span class="token parameter">title<span class="token punctuation">,</span>price</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//类</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//prototype表示对原生功能的扩展</span>    <span class="token class-name">Book</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getInfo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>title<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">alert</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端06</title>
      <link href="/2022/02/28/%E5%89%8D%E7%AB%AF06/"/>
      <url>/2022/02/28/%E5%89%8D%E7%AB%AF06/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS3-0特性"><a href="#CSS3-0特性" class="headerlink" title="CSS3.0特性"></a>CSS3.0特性</h2><h4 id="1-背景图片大小设定-background-size"><a href="#1-背景图片大小设定-background-size" class="headerlink" title="1. 背景图片大小设定(background-size)"></a>1. 背景图片大小设定(background-size)</h4><p>​    通过使用<code>background-size</code> 来规定背景图片的尺寸</p><p>​    background-size要写在background-image后面，否则background-size不会生效</p><p>​    <code>background-size</code> 的值有：</p><ul><li>background-size：contain; //背景成比例，按照图片最大边进行适配，图片完全显示在盒子里，少的部分出现白边</li><li>background-size ：cover; // 背景图成比例，按照图片最小边进行适配，多余的裁切</li><li>background-size ：100px 100px; // 调整图片到指定大小；</li><li>background-size ：100%; 会按容器比例撑满，导致图片失真。</li></ul><h4 id="2-背景透明颜色-rgba"><a href="#2-背景透明颜色-rgba" class="headerlink" title="2. 背景透明颜色(rgba)"></a>2. 背景透明颜色(rgba)</h4><p>​    通过使用<code>rgba(xx,xx,xx,xx,xx)</code>来设置，其中前三项与<code>rgb(xx,xx,xx)</code>一样为红绿蓝三种原色，后面的一项规定了透明度(alpha)，alpha参数是介于<code>0.0(完全透明)~1.0(完全不透明之间)</code></p><h4 id="3-图像的透明-opacity"><a href="#3-图像的透明-opacity" class="headerlink" title="3. 图像的透明(opacity)"></a>3. 图像的透明(opacity)</h4><p>​    通过使用<code>opacity</code>参数来设定图像的透明度，<code>opacity</code>参数是介于<code>0.0(完全透明)~1.0(完全不透明之间)</code></p><p>​    opacity在使用上应用于使用该属性的盒子内部的前景色、后景色、图片等，往往造成误伤，很多时候我们需要背景色透明度，而使用opacity则会导致文字颜色跟随改变</p><p>​    <strong>注意：opacity会继承父元素的opacity属性,而RGBA设置的元素的后代不会继承该属性及属性值。</strong></p><h4 id="4-颜色的渐变"><a href="#4-颜色的渐变" class="headerlink" title="4. 颜色的渐变"></a>4. 颜色的渐变</h4><p>​    通过使用<code>background-image:linear-gradient(Cdeg,#A 20%,#B 90%)</code>来设置颜色渐变，由A颜色渐变到B颜色，C表示角度，未设置角度时，则默认未180deg(从上到下)，设置角度，则0deg为竖直向上，然后顺时针旋转.后面的百分号为前20%都为A颜色，而后渐变，到90%到最后全为B色，如果设置满了不会有渐变效果，即全为纯色，注意：可以设置多个颜色参与渐变</p><h4 id="5-个性边框"><a href="#5-个性边框" class="headerlink" title="5. 个性边框"></a>5. 个性边框</h4><h5 id="1-圆角-Border-radius"><a href="#1-圆角-Border-radius" class="headerlink" title="(1). 圆角(Border-radius)"></a>(1). 圆角(Border-radius)</h5><p>​    通过使用<code>Border-radius</code>属性来设置边框的圆角度，可以使用<code>px</code>、<code>%</code>、<code>em</code>来表示数值</p><ul><li><p>仅设置一个值</p><p>​    设置一个数值，即对元素的四个边角设置统一的圆角弧度</p><p>​    一般用作设置按钮或者获得圆形(<code>Border-radius</code>为正方形一半<code>px</code>值时即可获得)</p></li><li><p>设置四个方向的值</p><p>​    border-radius属性其实是border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius四个属性的简写模式</p><p>​    不同于padding和margin的“上、右、下、左”的顺序，border-radius采用的是左上角、右上角、右下角、左下角的顺序</p><p>​    通过设置四个数值可以更加精确获得需要的形状</p></li></ul><h5 id="2-阴影"><a href="#2-阴影" class="headerlink" title="(2). 阴影"></a>(2). 阴影</h5><p>​    在CSS3中，使用<code>box-shadow</code>来给方框添加阴影</p><p><strong>语法</strong></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">box-shadow</span><span class="token punctuation">:</span> offset-x offset-y blur spread color inset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数解释：</strong></p><ul><li>offset-x：必需，取值正负都可。offset-x水平阴影的位置。</li><li>offset-y：必需，取值正负都可。offset-y垂直阴影的位置。</li><li>blur:可选，只能取正值。blur-radius阴影模糊半径，0即无模糊效果，值越大阴影边缘越模糊。</li><li>spread：可选，取值正负都可。spread代表阴影的周长向四周扩展的尺寸，正值，阴影扩大，负值阴影缩小。</li><li>color:可选。阴影的颜色。如果不设置，浏览器会取默认颜色，通常是黑色，但各浏览器默认颜色有差异，建议不要省略。可以是rgb(250,0,0)，也可以是有透明值的rgba(250,0,0,0.5)。</li><li>inset:可选。关键字，将外部投影(默认outset)改为内部投影。inset 阴影在背景之上，内容之下</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端05</title>
      <link href="/2022/02/28/%E5%89%8D%E7%AB%AF05/"/>
      <url>/2022/02/28/%E5%89%8D%E7%AB%AF05/</url>
      
        <content type="html"><![CDATA[<h2 id="DIV-CSS布局"><a href="#DIV-CSS布局" class="headerlink" title="DIV+CSS布局"></a>DIV+CSS布局</h2><h4 id="1-块元素和行内元素的区别"><a href="#1-块元素和行内元素的区别" class="headerlink" title="1. 块元素和行内元素的区别"></a>1. 块元素和行内元素的区别</h4><p>​    块元素和行内元素本质上是html规范中的概念</p><ul><li><p>块(block)元素的特点</p><ul><li>总是在新行上开始</li><li>高度和行高以及外边距和内边距都可以控制</li><li>宽度缺省是它的容器的100%，除非设定一个宽度</li><li>它可以容纳行内元素和其他块元素</li></ul></li><li><p>行内(inline)元素的特点</p><ul><li>和其他元素都在一行上</li><li>高，行高以及外边距和内边距不可改变</li><li>宽度就是它的文字或图片的宽度，不可改变</li><li>行内元素只能容纳文本或者其他行内元素</li></ul></li></ul><p>​    <strong>注意：一般情况下，做布局使用块元素，在一行的内容使用行内元素</strong></p><h4 id="2-常见的块元素"><a href="#2-常见的块元素" class="headerlink" title="2. 常见的块元素"></a>2. 常见的块元素</h4><ul><li>div</li><li>dl</li><li>form</li><li>h1~h6</li><li>hr</li></ul><h4 id="4-CSS盒子模型"><a href="#4-CSS盒子模型" class="headerlink" title="4. CSS盒子模型"></a>4. CSS盒子模型</h4><p>​    盒子模型是CSS的基石之一，在HTML页面上的每一个元素都被浏览器看成是一个矩形的盒子，这个盒子由元素的内容、填充、边框、边界组成</p><p>​    网页就是由许多个盒子通过不同的排列方式堆积而成，早期是使用表格做布局，现在使用的是DIV+CSS布局</p><p>​    <strong>盒子模型示意图</strong></p><p><a href="https://imgtu.com/i/HDOcKs"><img src="https://s4.ax1x.com/2022/02/13/HDOcKs.png" alt="HDOcKs.png"></a></p><p>​    注意：默认情况下，盒子边框是无，背景色是透明，所以在默认情况下看不到盒子，</p><h4 id="5-盒子模型详细介绍"><a href="#5-盒子模型详细介绍" class="headerlink" title="5. 盒子模型详细介绍"></a>5. 盒子模型详细介绍</h4><p>​    标准盒子模型示意图</p><p><a href="https://imgtu.com/i/bmoaIe"><img src="https://s4.ax1x.com/2022/02/27/bmoaIe.png" alt="bmoaIe.png"></a></p><p>​    在盒子模型中，可以单独设定任何一个元素，也可以组合起来按照上、右、下、左的顺序进行设定</p><p>​    盒子模型的背景颜色范围为border里面</p><p>​    <strong>元素盒子大小的计算</strong></p><p>​    一个元素的实际宽度=左边界 + 左边框 + 左填充 + 内容宽度 + 右填充 + 右边框 + 右边界</p><p>​    一个元素的实际高度=上边界 + 上边框 + 上填充 + 内容高度 + 下填充 + 下边框 + 下边界</p><h4 id="6-CSS盒子嵌套"><a href="#6-CSS盒子嵌套" class="headerlink" title="6. CSS盒子嵌套"></a>6. CSS盒子嵌套</h4><p>​    两个盒子相互嵌套是用大盒子的content来包裹小盒子</p><p>​    在一个盒子中嵌套一个盒子，那么两个盒子边框之间的距离等于外面盒子的填充值 + 里面盒子的边界值</p><p>​    <strong>盒子模型的特性</strong></p><ul><li>边界值margin可为负，填充padding不可为负</li><li>边框border默认值为0，即不显示</li><li>盒子模型只能设置两类颜色：边框颜色和背景颜色</li></ul><p>​    <strong>盒子模型属性值的简写形式</strong></p><ul><li>给出一个属性值：表示上右下左设置的全部值都为它</li><li>给出两个属性值：前者表示上下边框的属性，后者表示左右边框的属性</li><li>给出三个属性值：前者表示上边框的属性，中间的数值表示左右边框的属性，后者表示下边框的属性</li><li>给出四个属性值：依次表示上右下左的属性</li></ul><h4 id="7-浏览器的默认值"><a href="#7-浏览器的默认值" class="headerlink" title="7. 浏览器的默认值"></a>7. 浏览器的默认值</h4><p>​    在浏览器中，本身默认会自己设置一定的margin值和padding值</p><p>​    要取消掉浏览器的默认值，则可以</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span><span class="token punctuation">&#123;</span><span class="token property">margin</span><span class="token punctuation">:</span>0px<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span>0px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    上段代码就是手工初始化CSS</p><h4 id="8-display属性和实例"><a href="#8-display属性和实例" class="headerlink" title="8. display属性和实例"></a>8. display属性和实例</h4><h5 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h5><p>​    行内元素在浏览器中只能得到一行高度的空间，行高由<code>line-height</code> 属性(像素或百分比为单位)决定，如果没有设置该属性，则为内容的默认高度</p><p>​    <strong>行高示意图</strong></p><p><a href="https://imgtu.com/i/bntJ6x"><img src="https://s4.ax1x.com/2022/02/27/bntJ6x.png" alt="bntJ6x.png"></a></p><p>​    注意：<code>background-color</code> 的范围只在<code>font-size</code>的区域</p><p>​    <code>#b3d4fc</code>这个颜色好看</p><h5 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h5><p>​    通过display属性可控制元素是以行内元素显示还是以块级元素显示，或者不显示，<strong>即对元素进行转换</strong></p><ul><li>display:block 当前元素以块级元素显示</li><li>display:inline 当前元素以行内元素显示</li><li>display:none 当前元素隐藏，浏览器会完全忽略这个元素(不是删除是不显示)，一般使用在下拉菜单中</li><li>display:inline-block 当前元素既可以控制宽高，又可以横向排列</li></ul><h4 id="9-浮动与浮动清除"><a href="#9-浮动与浮动清除" class="headerlink" title="9.浮动与浮动清除"></a>9.浮动与浮动清除</h4><p>​    浮动主要是排版使用，可以使得原本2D的网页设计变成3D</p><p>​     浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次</p><h5 id="浮动的设置-对于要浮动的盒子设置"><a href="#浮动的设置-对于要浮动的盒子设置" class="headerlink" title="浮动的设置(对于要浮动的盒子设置)"></a>浮动的设置(对于要浮动的盒子设置)</h5><p>​    CSS中使用<code>float</code> 属性来控制浮动，其默认值为<code>none</code> ，如果将<code>float</code> 属性设置为<code>left</code> 或者<code>right</code> ，元素就会向左侧或者右侧靠紧，同时盒子宽度不再伸展，没设置宽度时会根据盒子里面的内容来确定宽度</p><p>​    如果某块设置为浮动，那么其后面的块会自动补该块未浮动时的位置，但后面块的文字会被挤占</p><h5 id="浮动的清除-对于浮动盒子的下面盒子设置"><a href="#浮动的清除-对于浮动盒子的下面盒子设置" class="headerlink" title="浮动的清除(对于浮动盒子的下面盒子设置)"></a>浮动的清除(对于浮动盒子的下面盒子设置)</h5><p>​    CSS使用<code>clear</code> 属性来清除浮动(消除浮动对下面盒子的影响)，它的取值有<code>left</code>、<code>right</code>、<code>both</code>和<code>none</code>(默认值)，设置为left或者right表示该盒子的左边或右边不允许有浮动的对象，设置为both则表示两边都不允许有浮动对象，因此该盒子将会在浏览器中另起一行显示</p><h4 id="10-position属性的使用"><a href="#10-position属性的使用" class="headerlink" title="10. position属性的使用"></a>10. position属性的使用</h4><p>​    一般使用position属性来对盒子模型进行定位，一般不会使用margin来设置位置，因为margin只是指外边距</p><p>​    position属性修改元素位置后，对其他元素无影响</p><p>​    position属性常用的4个值</p><ul><li><p><strong>static</strong></p><p>​    static是position的默认属性值，忽略top、bottom、left、right</p></li><li><p><strong>relative</strong></p><p>​    relative表示相对定位，当 position 为 relative 的时候，如果设置了 left 、right、top、bottom 属性，它们会生效，发生偏移时的参照为 position 属性取 static 时盒子的位置</p></li><li><p><strong>absolute</strong></p><p>​    absolute表示绝对定位，当 position 为 absolute 的时候，元素会被移出正常文档流，并不为元素预留空间，元素相对于最近的非 static 定位祖先元素发生偏移，<strong>当元素没有非 static 定位祖先时，会相对 html 发生偏移</strong></p></li><li><p><strong>fixed</strong></p><p>​    fixed表示固定定位，当 position 为 fixed 的时候，元素会被移出正常文档流，并不为元素预留空间，元素相对于屏幕视口（viewport）的 位置来发生偏移, 元素的位置在屏幕滚动时不会改变</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端04</title>
      <link href="/2022/02/12/%E5%89%8D%E7%AB%AF04/"/>
      <url>/2022/02/12/%E5%89%8D%E7%AB%AF04/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><h4 id="1-CSS简介"><a href="#1-CSS简介" class="headerlink" title="1. CSS简介"></a>1. CSS简介</h4><p>​    CSS(层叠样式表)是由W3C的CSS工作组创建和维护的。它是一种不需要编译。可直接由浏览器执行的标记性语言，用于控制web页面的外观</p><p>​    通过使用CSS样式控制页面各元素的属性显示，可将页面的内容与表现形式进行分离</p><p>​    <strong>层叠样式表本质上也是文本，用<code>&#123;&#125;</code> 将样式内容括住，最后将所有的封装在一个文件里。页面引用这个文件即可</strong></p><p>​    HTML5和CSS3是同时制作发布的</p><h4 id="2-CSS的优势"><a href="#2-CSS的优势" class="headerlink" title="2. CSS的优势"></a>2. CSS的优势</h4><ul><li><p>避免使用多余的HTML代码，减少代码量</p><p>​    文本本身是通过字符来计算文件量，而**在之前对于页面的修饰会通过HTML标签自带的属性进行修饰(即HTML代码的处理方式，不属于CSS)**，此时代码量大，读的时候就会慢</p></li><li><p>缩短更新和维护的时间</p><p>​    不使用CSS可能有些样式要反复定义，需要更换时，可能非常复杂。而且采用样式表可以使得样式与页面相分离，在修改时，更加直观、防止出错</p></li><li><p>做出HTML实现不了的特效</p><p>​    CSS2很多功能HTML里面其实也有，但在CSS3以及之后HTML里的样式就不再更新了</p></li></ul><h4 id="3-认识-lt-div-gt-和-lt-span-gt-标签-双"><a href="#3-认识-lt-div-gt-和-lt-span-gt-标签-双" class="headerlink" title="3. 认识&lt;div&gt; 和&lt;span&gt; 标签(双)"></a>3. 认识<code>&lt;div&gt;</code> 和<code>&lt;span&gt;</code> 标签(双)</h4><p>​    <code>&lt;div&gt;</code> 和<code>&lt;span&gt;</code> 标签是属于HTML的标签，一般这两个标签都是配合样式表使用的，这<strong>两个标签可以理解为容器标签</strong>，早期时一般用Table来当容器</p><ul><li><p><code>&lt;div&gt;</code> 标签(双)：</p><p>​    用来为HTML文档内大块的内容提供结构和背景的元素，它为块元素，<code>&lt;div&gt;</code> 的起始标签和结束标签之间的所有内容都在该块中，<strong>一般在布局时使用</strong></p></li><li><p><code>&lt;span&gt;</code> 标签(双)：</p><p>​    用来组成HTML文档的行元素，<strong>一般放内容时使用，<code>div</code> 也可以作为放内容</strong></p></li></ul><p>​    <strong><code>&lt;div&gt;</code> 和<code>&lt;span&gt;</code> 在页面上的显示</strong></p><p>​    代码</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>内容1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>内容2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>内容1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>内容1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    结果(虚线是工具编译生成的，在浏览器显示时，不会进行显示)</p><p><a href="https://imgtu.com/i/7IOCXF"><img src="https://s4.ax1x.com/2022/01/24/7IOCXF.png" alt="7IOCXF.png"></a></p><h4 id="4-CSS样式语法"><a href="#4-CSS样式语法" class="headerlink" title="4. CSS样式语法"></a>4. CSS样式语法</h4><p>​    <a href="https://imgtu.com/i/7IjFiR"><img src="https://s4.ax1x.com/2022/01/24/7IjFiR.png" alt="7IjFiR.png"></a></p><ul><li>选择器(符)：用于选择文档中要应用样式的那些元素，该元素 </li></ul><h4 id="5-CSS样式表中的注释"><a href="#5-CSS样式表中的注释" class="headerlink" title="5. CSS样式表中的注释"></a>5. CSS样式表中的注释</h4><p>​    使用<code>/*  注释  */</code>包裹进行注释</p><h4 id="6-CSS样式的几种表达方式"><a href="#6-CSS样式的几种表达方式" class="headerlink" title="6. CSS样式的几种表达方式"></a>6. CSS样式的几种表达方式</h4><h5 id="1-内嵌样式-直接在页面的标签里加"><a href="#1-内嵌样式-直接在页面的标签里加" class="headerlink" title="(1). 内嵌样式(直接在页面的标签里加)"></a>(1). 内嵌样式(直接在页面的标签里加)</h5><p>​    将CSS样式与某HTML标签混合使用，这种方式可以简单的对某个元素单独定义样式</p><p>​    范例：内嵌样式的使用</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-family</span><span class="token punctuation">:</span><span class="token string">'微软雅黑'</span><span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span>14px<span class="token punctuation">;</span><span class="token property">color</span><span class="token punctuation">:</span>#F00</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>内嵌样式<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    注意：这种方式实际上与在HTML代码中直接定义属性类似，违反了之前避免使用不必要的HTML元素这个规则，<strong>一般使用这种方式写只是针对页面已经写好但部分需要修改时使用</strong></p><h5 id="2-内部样式表-在head部分加入"><a href="#2-内部样式表-在head部分加入" class="headerlink" title="(2). 内部样式表(在head部分加入)"></a>(2). 内部样式表(在head部分加入)</h5><p>​    在HTML页面head标签内进行定义，只能在定义了的页面进行调用，其他页面调用不了 </p><p>​    范例：内部样式表的使用</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;head&gt;&lt;style&gt; &#x2F;*有些会写&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;这是CSS4.0要求的，现在5.0可以不写*&#x2F;.font_size&#123;font-size:30px;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;font_size&quot;&gt;字体变大&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    只适合单页或者是要修改时使用，在修改时，直接修改css文件可能会造成重名，而使用这个方式可以很好的避免</p><p>​    注意：之所以使用会写<code>type=&quot;text/css&quot;</code>作为<code>&lt;style&gt;</code> ，是因为HTML的设计者当时认为还有可能会有其他样式，但现在并没有，所以直接写<code>&lt;style&gt;</code>不带属性也是可以的</p><h5 id="3-链入外部样式表-在head部分进行引用描述"><a href="#3-链入外部样式表-在head部分进行引用描述" class="headerlink" title="(3). 链入外部样式表(在head部分进行引用描述)"></a>(3). 链入外部样式表(在head部分进行引用描述)</h5><p>​    把所有的东西封装在一个样式表文件里，从外部引用这个样式表文件，当网页加载时会把所有的外部样式先加载到网页中再进行显示，网速再慢也不影响，推荐使用这个形式</p><p>​    范例：链入外部样式表</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    <strong><code>rel</code>属性和<code>type</code>属性是两个声明，<code>href</code>中的路径必须要对</strong></p><p>​    注意：写在样式表中的CSS的样式定义与上面的写法是一样的</p><p>​    在浏览器中有的可以设置文字的大小，所以一般在定义文字时用CSS限制文字大小，不然可能造成页面被浏览器弄失真</p><h5 id="4-导入外部样式表-在head部分进行引用"><a href="#4-导入外部样式表-在head部分进行引用" class="headerlink" title="(4). 导入外部样式表(在head部分进行引用)"></a>(4). 导入外部样式表(在head部分进行引用)</h5><p>​    导入样式类似于链入外部样式，都是利用外部CSS样式文件来改变页面的外部表现的，但与外部样式不同的是，需要在<code>&lt;style&gt;</code>和<code>&lt;/style&gt;</code> 标签中间利用”@import”关键字导入外部CSS文件，文件加载到网页时，先把HTML结构显示出来，再把外部的CSS加载到网页当中，当网速较慢是会先显示未经修饰的HTML页面造成阅读者不好的感觉</p><p>​    现在使用的非常少，这是早期样式表导入的语法</p><p>​    范例：导入外部样式表</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token atrule"><span class="token rule">@import</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>my.css<span class="token punctuation">)</span></span><span class="token punctuation">;</span></span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="5-样式表的优先级"><a href="#5-样式表的优先级" class="headerlink" title="(5). 样式表的优先级"></a>(5). 样式表的优先级</h5><p>​    内嵌样式 &gt; 内部样式表 &gt; 导入外部样式表</p><h4 id="7-CSS基本选择器-符"><a href="#7-CSS基本选择器-符" class="headerlink" title="7. CSS基本选择器(符)"></a>7. CSS基本选择器(符)</h4><p>​    <strong>注意：所写的一个样式可以被多个内容所引用且本身样式表是有继承性的，有优先级别</strong></p><h5 id="1-通配符选择器"><a href="#1-通配符选择器" class="headerlink" title="(1). 通配符选择器(*)"></a>(1). 通配符选择器(*)</h5><p>​    在编码时，用”*”表示通配选择器，其作用是定义页面所有元素的样式，不管是直接在<code>body</code>标签中敲还是放什么标签里</p><p>​    范例：定义页面中所有的元素样式</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">*</span><span class="token punctuation">&#123;</span><span class="token property">margin</span><span class="token punctuation">:</span>0px<span class="token punctuation">;</span><span class="token property">padding</span><span class="token punctuation">:</span>0px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="(2). 类选择器(.)"></a>(2). 类选择器(.)</h5><p>​    类选择器通过直接引用元素中类属性的值而产生效果，使用<code>.</code> 来标识一个类选择器，类名可以随意命名但最好根据元素用途来命名</p><p>​    类选择器的语法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;CSS中.选择器名称(A)&#123;&#x2F;&#x2F;样式&#125;&#x2F;&#x2F;HTML中&lt;要引用样式的标签名 class&#x3D;&quot;选择器名称(A)&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-ID选择器"><a href="#3-ID选择器" class="headerlink" title="(3). ID选择器(#)"></a>(3). ID选择器(#)</h5><p>​    使用<code>#</code> 来标识一个ID选择器，在HTML文档中，每一个标签都可以使用id=”选择器名称”的形式进行一个名称指派，这和类选择器相似，但需要注意的是，<strong>HTML文件中id是具有唯一性是不可以重复的</strong></p><p>​    <strong>一般在js脚本中都是认id名的</strong></p><h5 id="4-标签选择器"><a href="#4-标签选择器" class="headerlink" title="(4). 标签选择器"></a>(4). 标签选择器</h5><p>​    把HTML标签当作选择器的名称，所有被该标签包含的HTML标签都会改变样式</p><h5 id="5-群组选择器"><a href="#5-群组选择器" class="headerlink" title="(5). 群组选择器"></a>(5). 群组选择器</h5><p>​    名称之间用<code>,</code> 隔开</p><p>​    范例：让三个div宽高一样，颜色不同</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.a1,.a2,.a3</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span>300px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span>300px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token selector">a1</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token selector">a2</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token selector">a3</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span>yellow<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-伪类-里面的状态伪类"><a href="#8-伪类-里面的状态伪类" class="headerlink" title="8. 伪类(里面的状态伪类)"></a>8. 伪类(里面的状态伪类)</h4><p>​    同一个标签，根据其<strong>不同的状态，有不同的样式</strong>。这就叫做“伪类”，伪类用冒号来表示。</p><p>​    伪类选择器分为两种。</p><p>​    <strong>1. 静态伪类</strong>：只能用于**超链接<code>&lt;a&gt;</code> **的样式。如下：</p><ul><li><p><code>:link</code> 超链接点击之前</p></li><li><p><code>:visited</code> 链接被访问过之后</p><p>注意：以上两种样式，只能用于超链接，且要写的话应该一起写上。</p></li></ul><p>​    <strong>2. 动态伪类</strong>：针对<strong>所有标签</strong>都适用的样式。如下：</p><ul><li><code>:hover</code> “悬停”：鼠标放到标签上的时候</li><li><code>:active</code>    “激活”： 鼠标点击标签，但是不松手时。</li><li><code>:focus</code> 是某个标签获得焦点时的样式（比如某个输入框获得焦点）</li></ul><p>​    <strong>超链接的四种状态伪类</strong></p><p>​    a标签有4种伪类（即对应四种状态），要求背诵。如下：</p><ul><li><p><code>:link</code> “链接”：超链接点击之前</p></li><li><p><code>:visited</code> “访问过的”：链接被访问过之后</p></li><li><p><code>:hover</code>    “悬停”：鼠标放到标签上的时候</p></li><li><p><code>:active</code>    “激活”： 鼠标点击标签，但是不松手时。</p></li></ul><p>​    <strong>记住，在css中，这四种状态必须按照固定的顺序写：</strong></p><blockquote><p>a:link 、a:visited 、a:hover 、a:active</p></blockquote><p>​    如果不按照顺序，那么将失效</p><h4 id="9-CSS颜色写法"><a href="#9-CSS颜色写法" class="headerlink" title="9. CSS颜色写法"></a>9. CSS颜色写法</h4><p>​    在CSS中，颜色的表达有一下三种方式</p><ol><li>十六进制：如“#ff000”</li><li>RGB：如“rgb(255,0,0)”</li><li>颜色名称：如“red”</li></ol><p>​    <strong>注意：一般使用十六进制表示颜色这种方式居多</strong></p><h4 id="10-背景图像"><a href="#10-背景图像" class="headerlink" title="10. 背景图像"></a>10. 背景图像</h4><p>​    CSS关于背景图像的属性</p><ul><li><code>background-color: blue</code> 为元素设置背景颜色为蓝色</li><li><code>background-image:url(&quot;图像路径&quot;)</code> 设置背景图像</li><li><code>background-repeat:no-repeat</code> 设置背景图像为不重复，默认值为重复</li><li><code>background-attachment:fixed</code> 将图片滚动锁定为不跟随滚动</li><li><code>background-position:center</code> 将图像位置设置为居中</li></ul><h4 id="11-文本修饰"><a href="#11-文本修饰" class="headerlink" title="11. 文本修饰"></a>11. 文本修饰</h4><p>​    CSS关于文本修饰的属性</p><ul><li><code>color:blue</code> 设置文本颜色为蓝色</li><li><code>text-align:center</code> 设置文本位置为居中</li><li><code>text-decoration:line-through</code> 设置文本效果为加删除线，除了删除线外还有上划线、下划线和无文字效果(none，这个可以和超链接混合使用)</li><li><code>text-indent:50px</code> 设置文本缩进为50px，通常是将段落的首行缩进，允许缩进使用负值 </li></ul><h4 id="12-文字修饰"><a href="#12-文字修饰" class="headerlink" title="12. 文字修饰"></a>12. 文字修饰</h4><p>​    CSS关于文字修饰的属性</p><ul><li><code>font-family:字体种类</code> 它可以设置多种字体，但在浏览器显示时需要操作系统中本身有该字体，不然会从浏览器下载该字体，多个字体按顺序来优先显示</li><li><code>font-style:italic</code> 将文字样式设置为斜体，默认值为normal即正常显示</li><li><code>font-size:40px</code> 将文字设置为40像素大小，还要一个单位em 1em=16px</li><li><code>font-weight:bold</code> 将文字设置为加粗(bold=700)，默认值为normal即正常显示，还可以使用数字表示<code>100~900</code>之间</li></ul><h4 id="13-CSS列表-ul与ol-的设置"><a href="#13-CSS列表-ul与ol-的设置" class="headerlink" title="13. CSS列表(ul与ol)的设置"></a>13. CSS列表(ul与ol)的设置</h4><p>​    通过使用列表的CSS选择器对属性<code>list-style-type:XXXX</code>进行指定来对列表进行设置</p><p>​    常见属性值见下图</p><p><a href="https://imgtu.com/i/Huz8pj"><img src="https://s4.ax1x.com/2022/02/06/Huz8pj.png" alt="Huz8pj.png"></a></p><h4 id="14-CSS表格相关样式的设置"><a href="#14-CSS表格相关样式的设置" class="headerlink" title="14. CSS表格相关样式的设置"></a>14. CSS表格相关样式的设置</h4><p>​     设置表格边框的属性(有边框的容器都适用)</p><ul><li>border:2px solid blue; 放在table标签中为设置边框的外边框为2像素，实线，颜色为蓝色，放在td标签中，即为设置内边框样式</li><li>width:500px; 放在table标签中设置表格宽度为500像素</li><li>height:500px; 放在table标签中设置表格高度为500像素</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端03</title>
      <link href="/2022/01/21/%E5%89%8D%E7%AB%AF03/"/>
      <url>/2022/01/21/%E5%89%8D%E7%AB%AF03/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML表单的设计与使用"><a href="#HTML表单的设计与使用" class="headerlink" title="HTML表单的设计与使用"></a>HTML表单的设计与使用</h2><h4 id="1-表单的概念"><a href="#1-表单的概念" class="headerlink" title="1. 表单的概念"></a>1. 表单的概念</h4><p>​    表单在网页中主要负责数据采集功能，<strong>主要用于搜集不同类型的用户输入</strong>，是人和电脑相互交流的通道</p><p>​    <strong>一个表单由两个基本组成部分：表单标签和表单域，<em>注意：由开始和结束的表单标签来组成一个表单域，一个页面可以有多个表单区域(通过name属性进行区分，不要重名)，但两个表单之间不支持嵌套</em></strong></p><p>​    表单区域代码示例</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form1<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>register.html<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>//里面可以写表单内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>name属性：定义表单名字，由英文字母定义</li><li>action属性：指定表单提交后，提交的目的地</li><li>method属性：有post和get，post打包暗箱传输的数据，而get是通过地址栏传值，不写该属性默认值为get</li></ul><p>​    表单标签<code>&lt;form&gt;</code>(双) ：包含了处理表单数据所用CGI程序的URL以及数据提交到服务器的方法</p><p>​    <strong>下面所提到的标签必须包含在表单域中</strong></p><p>​    表单域：包含了<strong>文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框</strong>等</p><p>​    表单按钮(属于表单域)：包括**提交按钮、复位按钮和一般按钮(即什么功能都没有定义的空按钮，用户可以根据自己情况定义)**；用以将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作</p><h4 id="2-单行文本框-单"><a href="#2-单行文本框-单" class="headerlink" title="2. 单行文本框(单)"></a>2. 单行文本框(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为<code>text</code> </p><p>​    范例：定义一个文本框</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>name属性：指定输入框的名字，<strong>表单中每一个标签都有命名，不要有重名，接收时按名字来接收</strong>，使用英文字母自行定义，不可以为关键字</p></li><li><p>type属性：<strong>用于定义类型</strong>，单行文本输入框的type固定为text</p></li></ul><p>​    注意：未加修饰的文本框在不同的浏览器显示的效果是不一样的，如果要所有的浏览器看到同一个效果，则需要使用CSS对其进行修饰</p><h4 id="3-密码输入框-单"><a href="#3-密码输入框-单" class="headerlink" title="3. 密码输入框(单)"></a>3. 密码输入框(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为<code>password</code> </p><p>​    密码框和文本框的区别是在密码框输入时的东西都会被隐藏，但传值的时候还是可以看见</p><p>​    范例：定义一个密码框</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>name属性：指定密码框的名字，<strong>表单中每一个标签都有命名，不要有重名，接收时按名字来接收</strong>，使用英文字母自行定义，不可以为关键字</p></li><li><p>type属性：密码输入框的type固定为password</p></li></ul><p>​    <strong>注意：可以在表单中加入表格，使得各标签显示更加有序</strong></p><h4 id="4-单选框-单"><a href="#4-单选框-单" class="headerlink" title="4. 单选框(单)"></a>4. 单选框(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为<code>radio</code> </p><p>​    单选框一次只能选择一个选项，在单选框使用时，必须有两个以上的单选框标签，而且其name属性相同，每一个单选框构成一个选项</p><p>​    范例：性别选择的实现</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">男 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>女 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>name属性：name属性相同表示一组单选框</li><li>type属性：单选框的type固定为radio</li><li>value属性：单选框相对于用户来说只是提供选择，用户并没有往里面输入值，所以需要value属性来定义一个值，当发生传值时，将选中的单选框的value值传递出去，单选框传的值和页面显示的文字无关</li><li>checked属性：没有值，表示该选项默认为选中状态</li></ul><p>​    注意：文本框也有value属性，如果写了value属性，页面显示的就为value的默认值</p><h4 id="5-复选框-单"><a href="#5-复选框-单" class="headerlink" title="5. 复选框(单)"></a>5. 复选框(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为<code>checkbox</code> </p><p>​    复选框用于多选</p><p>​    范例：城市的选择</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">北京<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>上海<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>大连<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>name属性：name属性相同表示一组复选框</li><li>type属性：复选框的type固定为checkbox</li><li>value属性：复选框相对于用户来说也只是提供选择，用户并没有往里面输入值，所以需要value属性来定义一个值，当发生传值时，将选中的复选框的value值传递出去，复选框传的值和页面显示的文字无关</li><li>checked属性：没有值，表示该选项默认为选中状态</li></ul><h4 id="6-下拉单选框-双"><a href="#6-下拉单选框-双" class="headerlink" title="6. 下拉单选框(双)"></a>6. 下拉单选框(双)</h4><p>​    用<code>&lt;select&gt;</code> 包含<code>&lt;option&gt;</code> 标签来描述，没有type属性</p><p>​    下拉单选框一次只能选择一个选项，下拉单选框的本质还是单选，但其可以节省空间，可以选如年月日那种</p><p>​    范例：下拉单选框的使用</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>select<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>select<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>北京<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>上海<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>大连<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>select标签的属性<ul><li>name属性：指定下拉单选框的名字，使用英文字母自行定义</li></ul></li><li>option标签的属性<ul><li>value属性：指定该选项的值，传参过去时使用</li><li>selected属性：没有值，表示默认选中该选项</li></ul></li></ul><h4 id="7-多行文本输入框-双"><a href="#7-多行文本输入框-双" class="headerlink" title="7. 多行文本输入框(双)"></a>7. 多行文本输入框(双)</h4><p>​    用<code>&lt;textarea&gt;</code> 标签描述，没有type属性</p><p>​    多行文本输入框用于输入大量文字信息，用于像电子邮件、发帖的正文等</p><p>​    范例：多行文本输入框的实现</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>80<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>name属性：指定输入框的名字，用英文表示自行定义</li><li>rows属性：指定文本框的行数(20表示有20个字符那么长)</li><li>cols属性：指定文本框的列数(80表示有80个字符那么长)</li><li>默认值：在开始标签和结束标签中间写的东西都会作为默认值显示</li></ul><p>​    注意：现在一般不会这样使用cols属性和rows属性来确定多行文本输入框的大小</p><h4 id="8-文件上传-单"><a href="#8-文件上传-单" class="headerlink" title="8. 文件上传(单)"></a>8. 文件上传(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为file</p><p>​    用于把文件上传到服务器</p><p>​    范例：文件上传的前端部分</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>name属性：指定该文件上传接口的名字，用英文表示自行定义</li><li>type属性：提交按钮的type属性固定为file</li></ul><p>​    注意：此时只是为前台页面的上传，该上传并不具有文件上传的逻辑，要想真正实现上传专门去用程序去实现上传的组件，他只是前台的一个接口</p><h4 id="9-提交按钮-单"><a href="#9-提交按钮-单" class="headerlink" title="9. 提交按钮(单)"></a>9. 提交按钮(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为submit</p><p>​    <strong>用于将表单数据提交给<code>form</code> 标签中action属性指定的地址进行处理，即传出去了，但action的那个页面能否接收要看那个页面是怎么写的</strong></p><p>​    范例：实现提交按钮</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>注册<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>name属性：指定按钮名字，用英文字母自行定义</li><li>type属性：提交按钮的type属性固定为submit</li><li>value属性：指定按钮上显示的字</li></ul><h4 id="10-普通按钮-单"><a href="#10-普通按钮-单" class="headerlink" title="10. 普通按钮(单)"></a>10. 普通按钮(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为button</p><p>​    该按钮相当于空的按钮，需要自己使用脚本进行定义</p><h4 id="11-重置按钮-单"><a href="#11-重置按钮-单" class="headerlink" title="11. 重置按钮(单)"></a>11. 重置按钮(单)</h4><p>​    用<code>&lt;input&gt;</code> 标签描述，type属性为reset</p><p>​    用于清空表单已经填写的数据，把表单恢复初始化</p><p>​    范例：定义重置按钮</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>重填<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>name属性：指定按钮名字，用英文字母自行定义</li><li>type属性：重置按钮的type属性固定为reset</li><li>value属性：指定按钮上显示的字</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端02</title>
      <link href="/2022/01/16/%E5%89%8D%E7%AB%AF02/"/>
      <url>/2022/01/16/%E5%89%8D%E7%AB%AF02/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML的标签"><a href="#HTML的标签" class="headerlink" title="HTML的标签"></a>HTML的标签</h2><h4 id="1-标题标签-双"><a href="#1-标题标签-双" class="headerlink" title="1. 标题标签(双)"></a>1. 标题标签(双)</h4><p>​    标题是通过<code>&lt;h1&gt;</code> -<code>&lt;h6&gt;</code> 等标签进行定义的，其中<code>&lt;h1&gt;</code> 定义最大的标题，<code>&lt;h6&gt;</code> 定义最小的标题</p><p>​    注意：标题标签只能用于标题，<strong>不要为了产生粗体或大号的文本而使用标题，标题是为网页结构和内容编制的索引，搜索引擎会抓取标题当关键字</strong></p><h4 id="2-基本标签"><a href="#2-基本标签" class="headerlink" title="2. 基本标签"></a>2. 基本标签</h4><ul><li><p><strong>段落标签(双)</strong></p><p>段落是使用<code>&lt;p&gt;</code> 标签在HTML页面中创建段落</p></li><li><p><strong>水平线标签(单)</strong></p><p>水平线是使用<code>&lt;hr&gt;</code>标签在HTML页面中创建水平线</p></li><li><p><strong>换行标签(单)</strong></p><p>换行是使用<code>&lt;br&gt;</code>标签在HTML页面中创建换行符，<code>&lt;br /&gt;</code>是写XHTML时的一个严格语法，如果不是写XHTML，则HTML中都应该使用<code>&lt;br&gt;</code>，<strong>注意：在代码中敲多少回车都没有用，多个空白符当一个空格</strong></p></li><li><p><strong>空格标签(符)</strong></p><p>空格是使用<code>&amp;nbsp</code>标签在HTML页面中显示空格</p></li><li><p><strong>注释</strong></p><p>HTML使用<code>&lt;!-- --&gt;</code>期间的内容为注释，注释在页面不显示，代码中可显示</p></li><li><p><strong>加粗( 双)</strong></p><p>加粗是使用<code>&lt;b&gt;</code>标签对标签内的文本进行加粗</p></li></ul><h4 id="3-图像标签-单"><a href="#3-图像标签-单" class="headerlink" title="3. 图像标签(单)"></a>3. 图像标签(单)</h4><p>​    图像使用<code>&lt;img&gt;</code> 标签在HTML页面中创建图像</p><p>​    <strong><code>&lt;img&gt;</code> 标签常用的属性如下（加粗为必须要使用的属性）</strong>：</p><ul><li><p><strong><code>src</code>：设定要引用图像的路径，如果图像路径不正确会在web页面上显示损坏的图像</strong></p></li><li><p><code>alt</code>：为图像定义一串预备的可替换文本，在浏览器无法载入图像时，浏览器将显示这个替代性文本</p></li><li><p><code>width</code>：设定图像宽度，属性值为像素</p></li><li><p><code>height</code>：设定图像高度，属性值为像素</p><p>注意：一般不会采用width或者height这种形式对图像进行强制放缩，<strong>因为采用这种形式进行放缩，文件量是不变的，即大图像变小但是文件大小不变，此时会造成网页上有许多占用流量的图像，使得网页反馈速度变慢</strong></p></li></ul><h4 id="4-路径"><a href="#4-路径" class="headerlink" title="4. 路径"></a>4. 路径</h4><p>​    路径分为网络路径和硬盘物理路径，我们在网上使用的都是网络路径</p><p>​    <strong>网络路径分为绝对路径和相对路径</strong></p><ul><li>绝对路径：由根目录（/）开始写起的文件名或目录名称</li><li>相对路径：相对于目前路径的文件名写法</li></ul><p>​    <strong>路径的切换</strong></p><ul><li>同级别：直接写文件名</li><li>上一次级别：用<code>../</code> 文件名</li><li>下一次级别：用目录名<code>/</code> 文件名</li></ul><p>​    <strong>注意：在网页中只能使用<code>/</code>来分隔路径</strong>，不可以使用<code>\</code>，<code>\</code>是Windows操作系统分隔路径用的</p><h4 id="5-超级链接（双）"><a href="#5-超级链接（双）" class="headerlink" title="5. 超级链接（双）"></a>5. 超级链接（双）</h4><p>​    超链接使用<code>&lt;a&gt;</code> 标签在HTML页面中创建超链接，开始标签和结束标签之间的文字、图像被作为链接来显示</p><p>​    <code>&lt;a&gt;</code> 标签里的内容会成为web页面中可单击的文本，默认这是有下划线的，可以用CSS去除</p><p>​    <strong><code>&lt;a&gt;</code> 标签常用的属性如下（加粗为必须要使用的属性）：</strong></p><ul><li><p><strong><code>href</code>：用于定位需要链接的文档，里面写要跳转网页的路径，或者目标文件，事实上可以指向各种各样的资源</strong></p></li><li><p><code>target</code>：定义被链接的文档在何处显示</p><p>常用的两个值</p><ol><li><code>_self</code>：在本窗口打开链接，不设置target则此为默认值</li><li><code>_blank</code>：在一个新窗口打开链接</li></ol></li><li><p>title：定义鼠标停留在链接上提示信息</p></li></ul><h4 id="6-列表-双"><a href="#6-列表-双" class="headerlink" title="6. 列表(双)"></a>6. 列表(双)</h4><p>​    列表分为有序列表和无序列表</p><ul><li>无序列表：在HTML中使用<code>&lt;ul&gt;</code> 标签表示无序列表，每一个列表项使用<code>&lt;li&gt;</code> 表示</li></ul><ul><li><p>有序列表：在HTML中使用<code>&lt;ol&gt;</code> 标签表示有序列表，每一个列表项使用<code>&lt;li&gt;</code> 表示</p><p><strong>注意：不管是有序列表还是无序列表<code>&lt;li&gt;</code> 都是双标签，而且这三个标签都为块元素</strong></p></li></ul><ul><li><p>自定义列表：使用<code>&lt;dl&gt;</code> 、<code>&lt;dt&gt;</code> 、<code>&lt;dd&gt;</code> 来组成自定义列表</p><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;&lt;dt&gt;burma Shave Signs&lt;&#x2F;dt&gt;&lt;dd&gt;Road signs common&lt;&#x2F;dd&gt;&lt;dt&gt;Route&lt;&#x2F;dt&gt;&lt;dd&gt;Most famous&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览器显示效果</p><p><a href="https://imgtu.com/i/qpNZjS"><img src="https://s1.ax1x.com/2022/03/16/qpNZjS.png" alt="qpNZjS.png"></a></p></li></ul><p>​    </p><p>​    列表可以相互嵌套，但嵌套的标签需要放在<code>&lt;li&gt;</code> 里面</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>城市<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>北京<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>上海<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>广州<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>地方<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-表格-双"><a href="#7-表格-双" class="headerlink" title="7. 表格(双)"></a>7. 表格(双)</h4><p>​    表格一般主要用于展示数据，但在网页设计中，主要用于布局，做容器使用</p><p>​    表格的图示</p><p><a href="https://imgtu.com/i/7JdhZ9"><img src="https://s4.ax1x.com/2022/01/15/7JdhZ9.png" alt="7JdhZ9.png"></a></p><p>​    在HTML中使用<code>&lt;table&gt;</code> 标签来定义表格；<br>​    使用<code>&lt;tr&gt;</code> 标签表示表格的一行，<code>&lt;tr&gt;</code> 标签里面不可以直接放元素；<br>​    使用<code>&lt;td&gt;</code> 来表示表格的一列(必须在行标签中)，即单元格，<strong>在<code>&lt;td&gt;</code> 标签中可以包含文本、图片、列表、段落、水平线、表格等任何元素</strong>；<br>​    使用<code>&lt;th&gt;</code> 来表示表头，该标签可加可不加</p><p>​    <strong>注意：上述标签都为双标签</strong></p><p>​    <strong><code>&lt;table&gt;</code> 标签的常用属性</strong></p><ul><li><code>cellspacing</code> ：用来定义表格的间距(单元格边框与单元格边框之间的距离)，默认值为1px</li><li><code>cellpadding</code> ：用来定义表格的边距(内容与单元格边框之间的距离)</li><li><code>width</code> ：用来定义表格的宽度</li><li><code>height</code> ：用来定义表格的高度</li><li><code>border</code> ：用来定义表格的边框粗细</li></ul><p>注意：上述属性都是用像素(px)为单位，一般设计网页设定分辨率&lt;1000px，14寸笔记本分辨率为(1366<code>*</code> 768)px</p><ul><li><code>align</code> ：放在<code>&lt;table&gt;</code> 标签中用来定义表格在总页面中的水平对齐方式；放在<code>&lt;td&gt;</code> 标签中用来定义单元格中的内容在单元格中的位置，两个的默认值都为left</li></ul><h4 id="8-引用-双"><a href="#8-引用-双" class="headerlink" title="8. 引用(双)"></a>8. 引用(双)</h4><h5 id="1-lt-q-gt-标签表示的引用-本质上为行内元素"><a href="#1-lt-q-gt-标签表示的引用-本质上为行内元素" class="headerlink" title="(1).&lt;q&gt; 标签表示的引用(本质上为行内元素)"></a>(1).<code>&lt;q&gt;</code> 标签表示的引用(本质上为行内元素)</h5><p>​    当需要引用一段文字时可以使用<code>&lt;q&gt;</code> 标签来将该段文字被引用</p><p>​    在不同的浏览器中显示情况不同，有些浏览器会为被引用的文字添加双引号(该双引号在网页不会被选中)，而有些浏览器不会，所以在使用时需要自行调试</p><h5 id="2-lt-blockquote-gt-标签表示的引用-本质上为块元素"><a href="#2-lt-blockquote-gt-标签表示的引用-本质上为块元素" class="headerlink" title="(2).&lt;blockquote&gt; 标签表示的引用(本质上为块元素)"></a>(2).<code>&lt;blockquote&gt;</code> 标签表示的引用(本质上为块元素)</h5><p>​    当需要引用一段文字时可以使用<code>&lt;blockquote&gt;</code> 标签来将该段文字被引用</p><p>​    在浏览器中显示一块区域类似<code>&lt;p&gt;</code>但里面的放的文字会有所缩进(有些浏览器可能不会缩进)</p><h5 id="注意：两个标签表示的引用效果相同，只是一个是行内元素，另一个是块元素"><a href="#注意：两个标签表示的引用效果相同，只是一个是行内元素，另一个是块元素" class="headerlink" title="注意：两个标签表示的引用效果相同，只是一个是行内元素，另一个是块元素"></a>注意：两个标签表示的引用效果相同，只是一个是行内元素，另一个是块元素</h5><h4 id="9-特殊字符"><a href="#9-特殊字符" class="headerlink" title="9. 特殊字符"></a>9. 特殊字符</h4><p>​    在HTML中有些字符用于组成HTML页面，导致要输出其时无法正常显示，此时就需要使用HTML规定的特殊字符表示的方法</p><p>​    <strong>常用的特殊字符</strong></p><ol><li><code>&lt;</code>字符：<code>&amp;lt</code> </li><li><code>&gt;</code>字符：<code>&amp;gt</code> </li><li><code>&amp;</code>字符：<code>&amp;amp</code> </li></ol><h4 id="10-原样输出"><a href="#10-原样输出" class="headerlink" title="10. 原样输出"></a>10. 原样输出</h4><p>​    在HTML中使用<code>&lt;pre&gt;</code> 标签来告诉浏览器，标签中的内容按照你输入方式的原样显示文本</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span>helloworld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-代码显示-双"><a href="#11-代码显示-双" class="headerlink" title="11. 代码显示(双)"></a>11. 代码显示(双)</h4><p>​    在HTML中使用<code>&lt;code&gt;</code> 标签来显示计算机程序代码</p><h4 id="12-HTML其他标签"><a href="#12-HTML其他标签" class="headerlink" title="12. HTML其他标签"></a>12. HTML其他标签</h4><p>​    可以通过这个网址跳转查询</p><p>​    <a href="[HTML Reference (w3schools.com)](https://www.w3schools.com/tags/)">HTML标签大全</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端01</title>
      <link href="/2022/01/14/%E5%89%8D%E7%AB%AF01/"/>
      <url>/2022/01/14/%E5%89%8D%E7%AB%AF01/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><h4 id="1-互联网的起源"><a href="#1-互联网的起源" class="headerlink" title="1. 互联网的起源"></a>1. 互联网的起源</h4><p>​    互联网起源于美国，最先是为了服务军方，后面由几个大学不断研发。首先是局域网，几个城市的局域网相互连接变成城域网，几个城域网相互连接变成广域网，而由几个国家连接就为互联网(因特网)。</p><p>​    </p><h4 id="2-W3C组织"><a href="#2-W3C组织" class="headerlink" title="2. W3C组织"></a>2. W3C组织</h4><p>​    由万维网发明者蒂姆.伯纳斯.李创立，其创建的目的是为了防止互联网陷入割据，现在很多web标准和技术都是由他制定</p><h4 id="3-HTML的概念"><a href="#3-HTML的概念" class="headerlink" title="3. HTML的概念"></a>3. HTML的概念</h4><p>​    HTML：即超文本标记语言，是构成网页文档的主要语言<br>​    <strong>超：</strong>指的是规定好的关键字，不放浏览器是看不出效果的<br>​    <strong>文本：</strong>指的是类似像使用记事本写的都是文本文件<br>​    <strong>标记：</strong>指的是由&lt;&gt;组成的标记(标签)<br>​    <strong>语言：</strong>HTML是解释执行语言，只是翻译不做逻辑</p><p>​    HTML页面也被称为静态页面或者HTML文档，后缀为html、htm，<strong>由于是之前操作系统只支持三位扩展名，到现在都支持了</strong></p><p>​    HTML语言通过浏览器进行翻译</p><h4 id="4-HTML的补充说明"><a href="#4-HTML的补充说明" class="headerlink" title="4. HTML的补充说明"></a>4. HTML的补充说明</h4><p>​    HTML是有版本的，最新的是HTML5，HTML是向下兼容，而且有些旧的浏览器可能不兼容最新版的HTML版本</p><p>​    同一个页面在不同浏览器(内核不同)中看到效果可能不同，这也称为浏览器兼容性问题</p><h4 id="5-HTML标签"><a href="#5-HTML标签" class="headerlink" title="5. HTML标签"></a>5. HTML标签</h4><p>​    HTML标签由尖括号包围的关键字构成</p><p>​    **HTML标签有成对出现(双标签)**，其中第一个标签是开始标签，第二个标签是结束标签； **也有单个出现(单标签)**，所有的单标签都以/结束</p><h4 id="6-HTML属性"><a href="#6-HTML属性" class="headerlink" title="6. HTML属性"></a>6. HTML属性</h4><p>​     HTML标签可以拥有属性，属性提供了有关HTML元素的更多信息，<strong>属性需要写在开始标签中，一个标签可以有多个属性</strong></p><p>​    属性的结构为：名称 = “value”</p><h4 id="7-HTML页面的基本结构"><a href="#7-HTML页面的基本结构" class="headerlink" title="7. HTML页面的基本结构"></a>7. HTML页面的基本结构</h4><p>​    HTML页面的结构包括头部(Head)、主体(Body)两大部分；<strong>头部描述浏览器所需的信息，主体包含所要说明的具体内容</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>//文本描绘网页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        //头部信息在此设置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        //HTML文件正文<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    标签是可以嵌套的，但不可以随意嵌套，需要明白父子关系</p><p>​    <strong>HTML页面的命名尽量使用英文，不要使用中文</strong></p><h4 id="8-HTML5的声明方法"><a href="#8-HTML5的声明方法" class="headerlink" title="8. HTML5的声明方法"></a>8. HTML5的声明方法</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token name">doctype</span> <span class="token name">html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="9-第一个HTML页面"><a href="#9-第一个HTML页面" class="headerlink" title="9. 第一个HTML页面"></a>9. 第一个HTML页面</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token name">doctype</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>欢迎您<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>jvav<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-标签的属性"><a href="#10-标签的属性" class="headerlink" title="10. 标签的属性"></a>10. 标签的属性</h4><p>​    标签属性的作用是提供元素的一些额外信息</p><p>​    在HTML中属性的写法为：属性名=”属性值”</p><p>​    注意：属性名和属性值都必须为HTML文档规定合法的写法</p><h4 id="11-元素"><a href="#11-元素" class="headerlink" title="11. 元素"></a>11. 元素</h4><p>​    HTML中的元素由三个部分组成：开始标记 + 内容 + 结束标记（单标签为各例）</p><p>​    其中内容可以为包含其他标签</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>望江南-超然台作</title>
      <link href="/2021/12/08/%E6%9C%9B%E6%B1%9F%E5%8D%97-%E8%B6%85%E7%84%B6%E5%8F%B0%E4%BD%9C/"/>
      <url>/2021/12/08/%E6%9C%9B%E6%B1%9F%E5%8D%97-%E8%B6%85%E7%84%B6%E5%8F%B0%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="致21岁生日的诗"><a href="#致21岁生日的诗" class="headerlink" title="致21岁生日的诗"></a>致21岁生日的诗</h2><h4 id="望江南·超然台作"><a href="#望江南·超然台作" class="headerlink" title="望江南·超然台作"></a>望江南·超然台作</h4><p>宋     苏轼</p><p>春未老，风细柳斜斜</p><p>试上超然台上望，半壕春水一城花，烟雨暗千家</p><p>寒食后，酒醒却咨嗟</p><p>休对故人思故国，且将新火试新茶，诗酒趁年华</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBirthday-do2</title>
      <link href="/2021/12/08/MyBirthday-do2/"/>
      <url>/2021/12/08/MyBirthday-do2/</url>
      
        <content type="html"><![CDATA[<h2 id="送给自己生日的代码"><a href="#送给自己生日的代码" class="headerlink" title="送给自己生日的代码"></a>送给自己生日的代码</h2><h4 id="送给自己的话"><a href="#送给自己的话" class="headerlink" title="送给自己的话"></a>送给自己的话</h4><p>​    在新的一年，希望可以更加独立一些，就在本学期，我经历了低谷，感受到了许多–冷淡与不屑还有嘲讽。希望在新的一年里，可以自由控制自己的时间，而不是被时间撵着走，依靠自己的力量，完成许多看似不可能的事情，<strong>做自己的主人</strong></p><h4 id="生日代码-回望2021，致敬2022"><a href="#生日代码-回望2021，致敬2022" class="headerlink" title="生日代码(回望2021，致敬2022)"></a>生日代码(回望2021，致敬2022)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Callable</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token class-name">Thread</span> game1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"王者"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">Thread</span> game2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"哈利"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">Thread</span> game3<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"吃鸡"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">Thread</span> game4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"第五"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"每月游戏，每周一轮转"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              game1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              game2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              game3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              game4<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>       <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> game_num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token keyword">private</span>  <span class="token class-name">String</span> name<span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                     <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                     e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>game_num<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                     game_num<span class="token operator">--</span><span class="token punctuation">;</span>                     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>              <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-02.md</title>
      <link href="/2021/12/08/JavaEE-02/"/>
      <url>/2021/12/08/JavaEE-02/</url>
      
        <content type="html"><![CDATA[<h2 id="JSP基础语法"><a href="#JSP基础语法" class="headerlink" title="JSP基础语法"></a>JSP基础语法</h2><h4 id="1-JSP注释"><a href="#1-JSP注释" class="headerlink" title="1. JSP注释"></a>1. JSP注释</h4><p>​    JSP中一共支持两种注释</p><ul><li><p>显式注释</p><p>使用的是HTML风格的注释</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--注释--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>隐式注释</p><ul><li><p>使用Java语言提供的注释</p><pre class="line-numbers language-none"><code class="language-none">单行注释(&#x2F;&#x2F;)多行注释(&#x2F;* ... *&#x2F;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>JSP提供的注释</p><pre class="line-numbers language-none"><code class="language-none">&lt;%-- 注释 --%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul><p>​    <strong>注释的区别</strong></p><p>​    代码运行之后只有显式注释的内容会发送到客户端上，即通过查看网页源代码可以看见</p><h4 id="2-三种Scriptlet"><a href="#2-三种Scriptlet" class="headerlink" title="2. 三种Scriptlet"></a>2. 三种Scriptlet</h4><p>​    <strong>Scriptlet指的是脚本小程序</strong>，在之前只要编写Java程序的语句都需要在”&lt;%%&gt;”之中进行编写，而这样的操作形式就称为Scriptlet，根据其作用不同，Scriptlet分为三类：&lt;%%&gt;、&lt;%!%&gt;、&lt;%=%&gt;</p><p>​    <strong>注意：一个JSP文件里面可以同时编写多个Scriptlet，且相互关联</strong></p><h5 id="第一种Scriptlet：-lt-gt"><a href="#第一种Scriptlet：-lt-gt" class="headerlink" title="第一种Scriptlet：&lt;%%&gt;"></a>第一种Scriptlet：&lt;%%&gt;</h5><p>​    在这种Scriptlet里面只能够编写<strong>局部变量、程序语句</strong></p><p>​    范例：观察&lt;%%&gt;</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%&#x2F;&#x2F;局部变量，每次页面刷新(执行)都要重新执行(重复声明)int num &#x3D; 100;%&gt;&lt;%out.println(&quot;&lt;h1&gt;&quot;+num+&quot;&lt;&#x2F;h1&gt;&quot;);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    一般，在一个JSP文件中使用的最多的就是“&lt;%%&gt;”，里面就定义一些基础的局部变量</p><h5 id="第二种Scriptlet：-lt-gt"><a href="#第二种Scriptlet：-lt-gt" class="headerlink" title="第二种Scriptlet：&lt;%!%&gt;"></a>第二种Scriptlet：&lt;%!%&gt;</h5><p>​    这种Scriptlet定义的变量为全局变量，还可以定义全局常量、方法、类</p><p>​    范例：定义全局变量</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%!        &#x2F;&#x2F;声明全局变量，只在第一次生成页面时声明，之后刷新页面不会再将100赋值给num，num为最近一次更新的值int num &#x3D; 100;%&gt;&lt;%out.println(&quot;&lt;h1&gt;&quot;+num+++&quot;&lt;&#x2F;h1&gt;&quot;);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    此时，随着页面刷新，显示的数字也会不断增加，重新打开界面仍为之前退出去前的数字</p><p>​    <strong>注意：一般不会这样使用代码来编写程序</strong></p><p>​    范例：定义全局常量</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%!        public static final String str &#x3D; &quot;HELLO&quot;;%&gt;&lt;%out.println(&quot;&lt;h1&gt;&quot;+str+&quot;&lt;&#x2F;h1&gt;&quot;);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>基本上在“&lt;%!%&gt;”能用到的只是定义全局常量(常量)功能</strong></p><p>​    范例：定义类和方法</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%!        class fish&#123;private String name;private String color;public fish(String name,String color)&#123;this.name &#x3D; name;this.color &#x3D; color;&#125;public String getfish()&#123;return &quot;name: &quot;+this.name +&quot; color : &quot;+this.color;&#125;&#125;public static double buy(double ... args)&#123;double sum &#x3D; 0;for(double x: args)&#123;sum &#x3D; sum+x;&#125;return sum;&#125;%&gt;&lt;%out.println(&quot;&lt;h1&gt;&quot;+new fish(&quot;red fish&quot;,&quot;red&quot;).getfish()+&quot;&lt;&#x2F;h1&gt;&quot;);out.println(&quot;&lt;h1&gt;&quot;+buy(11.1,56.3)+&quot;&lt;&#x2F;h1&gt;&quot;);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    一般也不会这样写代码，只有业余的那部分人会在JSP里面直接编写一堆的Java类或者是方法。</p><h5 id="第三种Scriptlet：-lt-gt"><a href="#第三种Scriptlet：-lt-gt" class="headerlink" title="第三种Scriptlet：&lt;%=%&gt;"></a>第三种Scriptlet：&lt;%=%&gt;</h5><p>​    out.println()可以向页面中进行内容显示输出，但是在JSP中，<strong>输出某个变量、常量、方法的返回值，可以使用表达式输出的Scriptlet完成：&lt;%=%&gt;</strong></p><p>​    范例：观察表达式输出</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%!        public static final String str &#x3D; &quot;HELLO&quot;;%&gt;&lt;h1&gt;&lt;%&#x3D;str%&gt;&lt;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这种Scriptlet可以很好的代替out.println()</p><p>​    <strong>那么这两种输出方式选哪种</strong></p><p>​    范例：使用两种形式打印乘法口诀表</p><p>1.使用out.println()打印</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%out.println(&quot;&lt;table&gt;&quot;);%&gt;&lt;%for(int x &#x3D; 1 ; x &lt;&#x3D; 9 ; x++)&#123;out.println(&quot;&lt;tr&gt;&quot;);for(int y &#x3D; 1 ; y&lt;&#x3D;x ;y++)&#123;out.println(&quot;&lt;td&gt;&quot;+x+&quot;*&quot;+ y+&quot;&#x3D;&quot;+x*y+&quot;&lt;&#x2F;td&gt;&quot;);&#125;out.println(&quot;&lt;&#x2F;tr&gt;&quot;);&#125;%&gt;&lt;%out.println(&quot;&lt;&#x2F;table&gt;&quot;);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    以上代码完成了开发需要，但是存在如下问题</p><ul><li><p>不方便使用任何的网页设计工具进行调试</p><ul><li>代码没有缩进，输出的代码格式不适合浏览</li></ul></li></ul><p>2.使用表达式输出</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;table&gt;&lt;%for(int x &#x3D; 1 ; x &lt;&#x3D; 9 ; x++)&#123;%&gt;&lt;tr&gt;&lt;%for(int y &#x3D; 1 ; y&lt;x ;y++)&#123;%&gt;&lt;td&gt;&lt;%&#x3D;x%&gt;*&lt;%&#x3D;y%&gt;&#x3D;&lt;%&#x3D;x*y%&gt;&lt;&#x2F;td&gt;&lt;%&#125;%&gt;&lt;&#x2F;tr&gt;&lt;%&#125;%&gt;&lt;&#x2F;table&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    此时的程序与out.println()相比最大的好处在于代码简化，而且功能又相同</p><p>​    <strong>注意：在以后的所有开发中，只要是JSP页面不允许使用out.println()输出，JSP的内容输出永远都依靠表达式输出完成</strong></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>​    如果把JSP页面当成一个Java类的话</p><pre class="line-numbers language-none"><code class="language-none">class xxx.jsp&#123;全局变量; &lt;%!%&gt;全局常量; &lt;%!%&gt;public void 方法()&#123;局部变量;&lt;%%&gt;语句;&lt;%%&gt;输出;&lt;%&#x3D;%&gt;&#125;class 内部类&#123;&#125;&lt;%!%&gt;方法;&lt;%!%&gt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-page指令"><a href="#3-page指令" class="headerlink" title="3. page指令"></a>3. page指令</h4><p>​    page主要功能是定义一个页面中的全部属性，里面会包含很多的选项</p><p>​    page是JSP页面开发中用到的最多的一个操作</p><p>​    <strong>page指令的语法格式</strong></p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page 属性名1 &#x3D; &quot;value1&quot; 属性名2 &#x3D; &quot;value2&quot; ... %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="1-解决显示乱码"><a href="#1-解决显示乱码" class="headerlink" title="1. 解决显示乱码"></a>1. 解决显示乱码</h5><p>​    (1).如果是一个<strong>HTML文件</strong>，对于乱码可以使用</p><pre class="line-numbers language-none"><code class="language-none">meta charset &#x3D; &#39;UTF-8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>的方式解决，<strong>其指定了页面的编码</strong>，浏览器在解析的时候被指定了编码，就可以准确的使用特定的解码方式进行显示</p><p>​    (2).<strong>jsp如果要设置浏览器支持的编码(浏览器会有默认的解码格式)，可以使用pageEncoding属性完成</strong></p><p>​    范例：设置浏览器的编码(.jsp文件)</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@page pageEncoding &#x3D; &quot;UTF-8&quot;%&gt;&lt;h1&gt;中文&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <strong>注意：pageEncoding的编码设置只能一次，多次会报错</strong></p><p>​    (3).设置MIME类型</p><p>​    MIME指的是多路Internet媒体访问协议。相当于通过MIME类型定义出当前页面的执行方式</p><p>​    所有支持的MIME类型都在Tomcat安装目录中/conf/web.xml文件里面定义，<strong>里面定义了各种文件的执行方式</strong></p><p>​    范例：设置MIME类型，其优先级大于第二种设置方法</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;%&gt;&lt;h1&gt;中文&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <strong>注意：不要乱加空格，尤其是等号那里</strong></p><p>​    这个设置与上面的第二种不冲突</p><p>​    MIME类型一般不需要设置，默认就是“text/html”</p><p>​    <strong>contentType为MIME类型，设置文件运行方式，可以更改为其他形式，如更改为word形式</strong></p><p>​    范例：将jsp页面 以word格式下载</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;application&#x2F;msword&quot;%&gt;&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;h1&gt;中文&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    此时运行会弹出下载框，下载word文件，<strong>这个在ie中才明显，一般浏览器感受不到</strong></p><p>​    现在对于编码的设置一般都是使用第二种</p><h5 id="2-使用page来使用Java中的import操作"><a href="#2-使用page来使用Java中的import操作" class="headerlink" title="2. 使用page来使用Java中的import操作"></a>2. 使用<code>page</code>来使用Java中的<code>import</code>操作</h5><p>​     在page指令里面几乎所有的指令都只能够设置一次，但是import指令可以使用多次，表示导入开发包</p><p>​    范例：使用Java中的<code>import</code>(可以一行导入也可以多行导入)</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.io.*,java.text.*&quot;%&gt;&lt;%@ page import&#x3D;&quot;java.util.*&quot;%&gt;&lt;h1&gt;&lt;%&#x3D;new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date())%&gt;&lt;&#x2F;h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    只要能导包，那么所有的系统类都可以调用</p><h5 id="3-数据库操作"><a href="#3-数据库操作" class="headerlink" title="3. 数据库操作"></a>3. 数据库操作</h5><p>​    因为可以进行导包操作，所以意味着可以在JSP页面上进行数据库的数据操作</p><p>​    对于要进行数据库操作的驱动程序，都需要拷贝到TomcatHOME/lib目录下即可(Tomcat需要重新启动才能加载新的包)</p><p>​    <strong>实际上，所有在JSP中的显示的内容永远都不是固定的，都是由程序动态生成的，在WebContainer中负责生成要显示的代码</strong></p><h4 id="4-包含指令"><a href="#4-包含指令" class="headerlink" title="4. 包含指令"></a>4. 包含指令</h4><p>​    一般要进行页面开发时都需要包含如下结构：菜单栏、头部信息、<strong>中间显示信息</strong>、尾部信息</p><p>​    一般都是中间显示信息发生变化，为实现这个有两种显示方式</p><ul><li>在每一个显示的页面里面重复包含有“菜单栏”、“头部信息”、“尾部信息”，这三个重复内容</li><li>将“菜单栏”、“头部信息”、“尾部信息”分别定义为三个文件，在需要的地方进行引用</li></ul><p>​    很明显第二种更加适合代码维护，所以此处就需要使用包含指令，但<strong>在JSP中对于包含指令有两种提供形式</strong></p><h5 id="1-静态包含：-lt-include-gt"><a href="#1-静态包含：-lt-include-gt" class="headerlink" title="1. 静态包含：&lt;%@include%&gt;"></a>1. 静态包含：<code>&lt;%@include%&gt;</code></h5><p>​    静态包含的语法：</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@include file&#x3D;&quot;包含文件路径&quot;%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>静态包含可以包含任意的文件内容</strong></p><p>​    范例：实现静态包含操作(定义几个被包含的页面)   </p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;1.jsp页面&lt;%@ page pageEncoding&#x3D;&#39;UTF-8&#39;%&gt;&lt;% String str &#x3D; &quot;这是页面一&quot;;%&gt;&lt;%&#x3D;str%&gt;&#x2F;&#x2F;2.html页面&lt;meta charset &#x3D; &quot;UTF-8&quot;&gt;&lt;%@ page pageEncoding&#x3D;&#39;UTF-8&#39;%&gt; &#x2F;&#x2F;保证引用后页面中文不会乱码&lt;h1&gt;这是页面2&lt;&#x2F;h2&gt;&#x2F;&#x2F;all.jsp&lt;%@ page contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;%&gt;&lt;%@include file&#x3D;&quot;2.html&quot;%&gt;&lt;%@include file&#x3D;&quot;1.jsp&quot;%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：使用jsp包含html页面时，会一起编译为java代码进行处理，此时就需要对html页面进行设置防止乱码</strong></p><p>​    在这个程序中文件名为中文不影响结果</p><p>​    此时所有的页面都被包含显示在all.jsp中</p><h5 id="2-动态包含：-lt-jsp-include-gt"><a href="#2-动态包含：-lt-jsp-include-gt" class="headerlink" title="2. 动态包含：&lt;jsp:include&gt;"></a>2. 动态包含：<code>&lt;jsp:include&gt;</code></h5><p>​    静态包含只是简单的将文件进行包含，而动态包含则分为两种情况处理</p><ul><li><p>情况一：被包含的页面属于静态文件，那么就将静态包含一样直接将内容导入进去</p></li><li><p>情况二：被包含的页面属于动态页面，则要分别处理后再进行包含</p></li></ul><p>​    <strong>注意：动态包含给出的指令形式属于标签指令，标签指令最后必须完结</strong></p><p>​    动态包含的语法格式定义：</p><ul><li><p>定义一：包含的页面不接收递参数</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;jsp:include page&#x3D;&quot;路径&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p>定义二：包含的页面需要接收参数</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;jsp:include page&#x3D;&quot;路径&quot;&gt;&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;...&lt;&#x2F;jsp:include&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​    <strong>注意：标签指令不能写在Scriptlet里面，其和HTML标签相似</strong></p><p>​    如果要在标签指令中使用Scriptlet里面定义的变量内容，则必须使用表达式输出的方式(<code>&lt;%=%&gt;</code>)</p><p>​    范例：实现参数的发送和接收</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;send.jsp,发送并显示receive.jsp界面&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;jsp:include page&#x3D;&quot;receive.jsp&quot;&gt;&lt;jsp:param name&#x3D;&quot;a&quot; value&#x3D;&quot;刘旭晟&quot;&#x2F;&gt;&lt;jsp:param name&#x3D;&quot;do&quot; value&#x3D;&quot;说&quot;&#x2F;&gt;&lt;jsp:param name&#x3D;&quot;proclaim&quot; value&#x3D;&quot;共产党万岁&quot;&#x2F;&gt;&lt;&#x2F;jsp:include&gt;&#x2F;&#x2F;receive.jsp,接收端需要接收参数传递内容&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;%&#x3D;request.getParameter(&quot;a&quot;)%&gt;&lt;%&#x3D;request.getParameter(&quot;do&quot;)%&gt;&lt;%&#x3D;request.getParameter(&quot;proclaim&quot;)%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-动态包含和静态包含的区别"><a href="#3-动态包含和静态包含的区别" class="headerlink" title="3. 动态包含和静态包含的区别"></a>3. 动态包含和静态包含的区别</h5><p>​    在静态导入时，如果导入的页面定义了Scriptlet变量且本页面也定义了一个一模一样名字的变量，则<strong>页面显示报错，如果执行报错后依然再次刷新会把错误给刷新没</strong></p><p>​    <strong>静态包含的最大特点为：先把内容包含到一起，而后一起进行处理</strong></p><p>​    在动态导入时，如果导入的页面定义了Scriptlet变量且本页面也定义了一个一模一样名字的变量，页面照常显示没有影响</p><p>​    <strong>动态包含的特点：</strong></p><ul><li>*<em>如果被包含页面是动态页面(</em>.jsp)，那么先分别处理两个页面的操作，而后将结果包含进来**</li><li>*<em>如果被包含的页面是静态页面(</em>.txt)，那么只是将文件内容简单的导入进来**</li></ul><p>​    动态包含相比静态包含可以在不同页面重复定义变量，更加安全</p><h4 id="5-跳转指令"><a href="#5-跳转指令" class="headerlink" title="5. 跳转指令"></a>5. 跳转指令</h4><p>​    跳转：从一个JSP页面可以跳转到另外一个JSP或其他页面</p><p>​    <strong>跳转指令依然输入标签指令形式，所以在跳转指令完成操作后依然要进行标签完结</strong></p><p>​    跳转指令的两种定义形式：</p><ul><li><p>定义一：不向跳转页面传递参数：</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;jsp:forward page&#x3D;&quot;路径&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p>定义二：向跳转页面传递参数</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;jsp:forward page&#x3D;&quot;路径&quot;&gt;&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;&lt;jsp:param name&#x3D;&quot;参数名称&quot; value&#x3D;&quot;参数内容&quot;&#x2F;&gt;...&lt;&#x2F;jsp:forward&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​    范例：实现跳转</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&#x2F;&#x2F;要跳转到的界面&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;h1&gt;&lt;%&#x3D;request.getParameter(&quot;paramA&quot;)%&gt;&lt;&#x2F;h1&gt;&lt;h1&gt;&lt;%&#x3D;request.getParameter(&quot;paramB&quot;)%&gt;&lt;&#x2F;h1&gt;&#x2F;&#x2F;跳转界面&lt;%@ page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;jsp:forward page&#x3D;&quot;param.jsp&quot;&gt;&lt;jsp:param name&#x3D;&quot;paramA&quot; value&#x3D;&quot;int&quot;&#x2F;&gt;&lt;jsp:param name&#x3D;&quot;paramB&quot; value&#x3D;&quot;double&quot;&#x2F;&gt;&lt;&#x2F;jsp:forward&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    像以上代码这种跳转之后地址栏不发生改变，但页面内容发生改变，<strong>这种跳转称为服务器端跳转</strong></p><p>​    <strong>还有一种跳转会连地址栏一起跳转的叫客户端跳转</strong>，实现方式是使用Javascript，或者可以使用超链接跳转也是一样的</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">window<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">"param.jsp"</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    <strong>结论</strong>    </p><p>​    地址栏不改变的跳转称为服务器跳转</p><p>​    地址栏改变的跳转称为客户端跳转</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-01</title>
      <link href="/2021/11/15/JavaEE-01/"/>
      <url>/2021/11/15/JavaEE-01/</url>
      
        <content type="html"><![CDATA[<h2 id="Web与Tomcat"><a href="#Web与Tomcat" class="headerlink" title="Web与Tomcat"></a>Web与Tomcat</h2><h4 id="1-Web的简介"><a href="#1-Web的简介" class="headerlink" title="1. Web的简介"></a>1. Web的简介</h4><p>​    WEB最早出现是为了展示科研产品，到现在其发展超过预期，从WEB开始整个互联网的行业发生了变化</p><p>​    不管怎么改变WEB的处理流程永远都只有两种形式：<strong>静态WEB和动态WEB</strong></p><p>​    (1).静态WEB</p><p><a href="https://imgtu.com/i/IcNA3T"><img src="https://z3.ax1x.com/2021/11/14/IcNA3T.png" alt="IcNA3T.png"></a></p><p>​    在WEB中分为客户端与服务器端，而客户端主要通过WEB浏览器访问服务器端，并且使用的是HTTP协议</p><p>​    静态WEB的实现主要技术是：HTML、CSS、Javascript</p><p>​    <strong>静态WEB的缺点：无法操作数据库</strong></p><p>​    (2).动态WEB</p><p><a href="https://imgtu.com/i/Icaq41"><img src="https://z3.ax1x.com/2021/11/14/Icaq41.png" alt="Icaq41.png"></a></p><p>​    动态WEB与静态WEB一样，客户端上依然使用普通的WEB浏览器进行访问，但是服务器端的操作发生了变化</p><p>​    用户发送来的请求将由WEB服务插件进行接收，插件的主要功能是区分用户发送过来的是动态的还是静态的请求( * .htm为静态请求、 * .jsp为动态请求)，如果是静态请求，则由Web Server调用文件系统中的指定文件内容并发回给客户端(与静态Web相同)，但是如果发送为动态请求，则所有的请求交由Web容器进行处理。Web容器负责拼凑代码，拼凑完后交由Web Server返回给用户进行展示</p><p>​    <strong>动态Web的最大特征：交互性</strong></p><p>​    由于有Web容器的支持，所以动态Web可以进行数据库的连接访问</p><p>​    动态Web需要进行拼凑，所以总体上静态Web会快于动态Web</p><p>​    <strong>动态Web的实现可以使用的技术</strong></p><p>​    CGI，ASP，PHP，Servlet/JSP(Java做前台太费钱，也费劲)，RUBY，<strong>Node.JS</strong>，<strong>Python</strong></p><p>​    没有加粗的不用看，都是夕阳</p><p>​    核心本质没有变，还是Java处理整个后端业务(大脑)</p><p>​    <strong>注意：Web Container（Web容器）是决定整个动态Web的核心，所有的代码一定是拼凑而成，拼凑完后还是HTML代码</strong></p><h4 id="2-Tomcat的安装与配置"><a href="#2-Tomcat的安装与配置" class="headerlink" title="2. Tomcat的安装与配置"></a>2. Tomcat的安装与配置</h4><p>​    Tomcat是符合JavaEE标准的最小的Web容器</p><p>​    <strong>服务器与容器的区别</strong></p><p>​    服务器中会包含容器，除了容器之外服务器中还可能包含一些组件，例如：事务处理</p><p>​    <strong>Tomcat的下载</strong></p><p>​    去官网下载安装版，Tomcat本身很小，所以电脑上需要有额外的JDK，Tomcat在电脑中的运行必须有JDK的支持，或者简化版JRE支持，在安装Tomcat时会进行选择。</p><p>​    安装完成后会自动在Windows的服务里面进行服务的注册，但是不可以在这里启动</p><p>​    <strong>Tomcat的安装目录</strong></p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Apache Software Foundation\Tomcat 10.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>bin：包含了所有的可执行的程序命令，使用“Tomcat10.exe”命令可以启动Tomcat服务器，<strong>打开服务器之后，就可以利用浏览器访问，输入：<a href="http://localhost:8080/">http://localhost:8080</a></strong></p></li><li><p>conf：包含了所有的配置文件路径信息</p></li><li><p>lib：这是一个Tomcat自己的CLASSPATH，可以在里面配置第三方的jar文件</p></li><li><p>logs：负责所有日志文件的保存目录</p></li><li><p>webapps：为项目的自动部署目录</p></li><li><p>work：保存所有的临时生成文件，如果程序则么都运行不了，但又没有错，可以考虑将此目录清空</p></li></ul><p>​    <strong>Tomcat的使用（配置虚拟目录）</strong></p><p>​    如果要在项目中使用Tomcat必须配置虚拟目录（核心）</p><p>​    虚拟目录指的就是工作目录，即，如果进行Web项目的开发，需要有一个指定结构的目录进行内容的保存，并且要在Tomcat中配置此目录</p><ol><li><p>在D盘建立一个lxsWeb的目录，这个目录作为虚拟目录存在</p></li><li><p>这个目录有建立要求，在这个目录中必须存在有一个WEB-INF/web.xml(大小写不能错)文件（从Tomcat的安装目录webapps-&gt;ROOT可以拷贝出来）</p></li><li><p>此时Tomcat不知道硬盘存在此目录，所以需要修改Tomcat的配置文件(conf/server.xml),在“<code>&lt;/Host&gt;</code> ”上面编写这行代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;Context path &#x3D; &quot;&#x2F;lxs&quot; docBase &#x3D; &quot;D:\lxsweb&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置意义：</p><ul><li><code>&lt;Context&gt;</code> ：表示配置一个新的上下文，结尾必须有<code>/</code> </li><li>path：为浏览器上的输入路径(<code>http://localhost:8080/lxs</code> )，名称不允许重复，此时通过上面的路径访问<code>D:\lxsweb</code> 目录下的内容</li><li>docBase：配置项目的磁盘路径，此目录下必须存在WEB-INF</li></ul></li><li><p>在默认情况下，如果直接输入路径会出现404(HTTP状态码，表示路径不可访问)错误，因为没有输入具体执行文件名称，输入后就可以访问。另外，从Tomca6.5开始关闭了页面列表功能，此时通过修改conf/web.xml文件打开列表，查找文件中listings，把其值改为true，此时就可以进行列表显示</p></li><li><p>默认情况下，所有的网络服务器都是有监听端口的，Tomcat默认的端口为8080端口，但是如果不想输入端口，则可以将监听端口设置为80这个默认端口(当你不写端口号时默认去寻找的就是80端口)，修改conf/server.xml文件即可</p><pre class="line-numbers language-none"><code class="language-none">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; &#x2F;&#x2F;8080改为80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时访问时就不需要写端口8080了：<code>http://localhost/lxs/</code> ，此时如果加了8080反而进不去</p></li><li><p>也可以不使用localhost改用本机ip，通过cmd输入ipconfig，其中的IPv4地址，为本机ip地址，通过ip地址可以访问其ip的电脑</p></li></ol><p><strong>注意：所有的配置文件修改后，Tomcat需要重新启动才可以加载到新的内容</strong></p><h4 id="3-第一个JSP程序"><a href="#3-第一个JSP程序" class="headerlink" title="3. 第一个JSP程序"></a>3. 第一个JSP程序</h4><p>​    范例：在页面上输出”hello world”</p><p>​    此时需要定义一个JSP文件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Hello JSP<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>&lt;%//此处为JSP代码out.println("hello world"); //页面输出%><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    程序要想正常执行，必须将其保存在服务器工作区内(虚拟目录)，随后打开浏览器输入访问地址执行<a href="http://localhost/lxs/Hello.jsp">http://localhost/lxs/Hello.jsp</a></p><p>​    <strong>一般第一次会比第二次慢</strong></p><p>​    图示：Tomcat的原理</p><p><a href="https://imgtu.com/i/I24uXF"><img src="https://z3.ax1x.com/2021/11/15/I24uXF.png" alt="I24uXF.png"></a></p><ol><li><p>如果用户要访问服务器端的程序将通过浏览器输入访问地址</p></li><li><p>而后服务器端要读取hello.jsp文件，但这个时候并不是直接将这个文件发送给客户端</p></li><li><p>服务器端把hello.jsp文件变为hello.java的文件，并且会自动将这个 hello.java文件自动编译为 hello.class文件</p></li><li><p>之后将执行生成的hello.class文件，并且通过服务器端解析生成为HTML代码后发送给客户端浏览器</p><p>总结：第一次执行hello.jsp文件的时候需要将其转换和编译后才可以执行，而第二次访问由于 hello.class文件已经存在，不会再执行上面操作所以速度就快，但是如果文件发生变化，那么就会重新转换、编译</p></li></ol><p><strong>注意：所有转换和编译后的文件都保存在work目录下</strong></p><p>​    <strong>如果电脑变慢可能导致这个流程异常，即怎样修改文件都执行无变化，此时将Tomcat关上，而后将work目录清空即可</strong></p><p>​    范例：输出更多内容</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Hello JSP<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>&lt;%//此处为JSP代码out.println("hello world"); //页面输出out.println("<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>"); out.println("<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>text/javascript<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>"); %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>关系</strong></p><p>​        <strong>JavaScript可以控制HTML代码的输出</strong></p><p>​        <strong>JSP可以控制JavaScript与HTML代码的输出</strong></p><h4 id="4-接收客户端请求数据"><a href="#4-接收客户端请求数据" class="headerlink" title="4. 接收客户端请求数据"></a>4. 接收客户端请求数据</h4><p>​    动态Web最大的特征就是交互性，而交互性的关键是必须由用户输入数据，在HTML中已经提供了表单给用户进行输入数据的空间，而所有的输入数据应由服务器端进行接收</p><p>​    <strong>如果要在服务器端接收数据可以使用操作：request.getParameter(String 参数名称(表单中的name属性))，该操作返回的是String型数据(可以通过正则验证且可以向任意数据类型转换)</strong></p><p>​    范例：编写表单–input.html</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>input.jsp<span class="token punctuation">"</span></span> <span class="token attr-name">method</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>请输入信息：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>send<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    当点击提交按钮之后会自动的将表单的输入参数内容发送给服务器端，服务器端可以进行接收</p><p>​    范例：接收参数–input.jsp</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%String str = request.getParameter("msg");out.println("<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>"+str+"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>");%><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    此时用客户端输入的内容服务器端都可以接收到</p><p>​    <strong>注意：服务器若出现500，则表示代码错误</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java15</title>
      <link href="/2021/11/11/Java15/"/>
      <url>/2021/11/11/Java15/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><h4 id="1-多线程编程的本质就是并发编程"><a href="#1-多线程编程的本质就是并发编程" class="headerlink" title="1. 多线程编程的本质就是并发编程"></a>1. 多线程编程的本质就是并发编程</h4><p>​    并发编程的本质是指的发挥出所有硬件的最大性能</p><p>​    Java是为数不多的真正支持有多线程并发编程的开发语言，所以在整体的处理性能上是最高的</p><p>​    而python是多进程编程的注意区分</p><h4 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h4><p>​    传统硬件只有一个CPU(单核CPU)，为了发挥硬件的全部性能，引入了多进程编程模式</p><ul><li>进程指的是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</li><li>进程是系统进行资源分配和调度运行的基本单位</li><li>进程实体中包含有三个组成部分：“程序”、“数据”、“PCB(进程控制块)”</li></ul><h4 id="3-单进程运行与多进程运行的区别"><a href="#3-单进程运行与多进程运行的区别" class="headerlink" title="3. 单进程运行与多进程运行的区别"></a>3. 单进程运行与多进程运行的区别</h4><p>​    单进程运行<br>​    所有的系统资源都为一个进程服务，该进程资源独享</p><p><a href="https://imgtu.com/i/5oHkGR"><img src="https://z3.ax1x.com/2021/10/26/5oHkGR.png" alt="5oHkGR.png"></a></p><p>​    多进程运行<br>​    在没有拓展原始系统硬件资源的前提下，利用一些算法，实现多个进程的并行执行</p><p>​    在每个进程执行时要独享全部资源，即在同一个时间点上只会有一个进程执行</p><p><a href="https://imgtu.com/i/5o7LPs"><img src="https://z3.ax1x.com/2021/10/26/5o7LPs.png" alt="5o7LPs.png"></a></p><h4 id="4-线程"><a href="#4-线程" class="headerlink" title="4. 线程"></a>4. 线程</h4><p>​    线程是在进程基础上的进一步划分，可以达到更快的处理性能，任何一个进程的启动都是非常缓慢的，线程性能上远高于进程，但是线程不可以离开进程存活</p><p>​    进程与线程图示</p><p><a href="https://imgtu.com/i/5oqIr6"><img src="https://z3.ax1x.com/2021/10/26/5oqIr6.png" alt="5oqIr6.png"></a></p><p>​    每一个进程都只有一个自己的重要处理单元，如果要想实现CPU(变量信息等)的共享，则必须利用线程来描述</p><p>​    一般来说，每一块CPU只会有一个线程执行，但有一些CPU可以使用超线程技术，设计出若干个多线程的执行状态，这叫<strong>超线程</strong></p><h4 id="5-并行编程"><a href="#5-并行编程" class="headerlink" title="5. 并行编程"></a>5. 并行编程</h4><p>​    随着硬件和软件技术的发展，硬件中的CPU出现了多核状态，理论上多核CPU的多进程执行称为并行编程</p><h4 id="6-纤-协-程"><a href="#6-纤-协-程" class="headerlink" title="6. 纤(协)程"></a>6. 纤(协)程</h4><p>​    在进程和线程的概念之上还有一个叫纤(协)程，是在线程基础上进一步划分，并不是像进程和线程一样由硬件支持，协程用的是由程序控制的<br>​    Java并没有支持有多协程编程（不代表以后没有），像python是支持多协程的</p><h4 id="7-多线程编程起步"><a href="#7-多线程编程起步" class="headerlink" title="7. 多线程编程起步"></a>7. 多线程编程起步</h4><p>​    所有的Java程序是通过主方法完成的，主方法作为程序的起点。而要进行多线程的编程也需要一个线程的起点结构，此结构称为线程类，所有的线程类是有继承要求的，可以有三种实现模式：<strong>继承Thread类、实现Runnable接口、实现Callable接口(两个接口更重要)</strong></p><h5 id="1-继承Thread类的实现多线程"><a href="#1-继承Thread类的实现多线程" class="headerlink" title="1. 继承Thread类的实现多线程"></a>1. 继承Thread类的实现多线程</h5><p>​    java.lang.Thread是由系统定义的一个线程处理类，<em>任何的子类只需要继承此类就可以得到一个线程处理的能力，在使用时一定要覆写Thread类中的run()方法</em>，<strong>这个方法将作为一个线程启动的主方法存在</strong></p><p>​    范例：定义一个<strong>线程主体类</strong></p><pre class="line-numbers language-none"><code class="language-none">class MyThread extends Thread&#123; &#x2F;&#x2F;得到了一个线程主体类private String name;public MyThread(String name) &#123; &#x2F;&#x2F;保存线程名称&#125;public void run() &#123; &#x2F;&#x2F;覆写run()方法for(int x &#x3D; 0; x &lt; 30 ; x++) &#123;System.out.println(&quot;【&quot;+this.name+&quot;线程】运行，x &#x3D; &quot;+x);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>线程中主方法类和线程类的关系</strong><br>​    要在主类的主方法中启动线程<br>​    线程一般会多个交替执行，所以无法通过调用run()方法来调用线程<br>​    通过start()方法来开启线程<br><a href="https://imgtu.com/i/IpE5DS"><img src="https://z3.ax1x.com/2021/10/31/IpE5DS.png" alt="IpE5DS.png"></a></p><p>​    <strong>如果想要进行多线程的并发执行，则需要调用机器上操作系统提供的底层函数支持，所有多线程启动并不是依靠调用run()方法完成的，它需要通过start()方法进行启动，所有start()方法启动之后将调用run()方法中定义的方法体</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public void start()</td><td align="center">方法</td><td align="center">使线程开始执行，不能重复启动同一个进程，会造成异常</td></tr></tbody></table><p>​    <strong>注意：所有线程的启动只能依靠Thread.start()方法</strong></p><p>​    范例：启动多线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    所有线程对象交替执行run()方法中的内容</p><p>​    <strong>在start()方法里面调用了一个start0()方法，该方法没有方法体，但由关键字native来定义，此关键字的作用在于表示此操作交由底层实现</strong></p><p><a href="https://imgtu.com/i/IpeYNQ"><img src="https://z3.ax1x.com/2021/10/31/IpeYNQ.png" alt="IpeYNQ.png"></a></p><h5 id="2-实现Runnable接口实现多线程"><a href="#2-实现Runnable接口实现多线程" class="headerlink" title="2. 实现Runnable接口实现多线程"></a>2. 实现Runnable接口实现多线程</h5><p>​    可以通过java.lang.Runnable接口来实现多线程</p><table><thead><tr><th align="center">接口名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@FunctionalInterface public interface <strong>Runnable</strong></td><td align="center">函数式接口，里面可以使用nameda表达式</td></tr></tbody></table><p>​    在Runnable接口中只有唯一一个方法–run()方法，此方法作为线程主方法</p><p>​    **注意：之前Thread类中有提供start()方法启动线程，但是Runnable接口中不提供这个方法，此时需要Thread类提供的构造方法</p><pre class="line-numbers language-none"><code class="language-none">public Thread(Runnable target)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>这个构造方法里面需要接收Runnable接口对象的实例（子类对象实例）</strong></p><p>​    范例：使用Runnable接口实现多线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">MyThread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">MyThread</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">MyThread</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    使用Runnable接口实现可以避免单继承局限(在Java中一个类只能使用extends继承一个父类),更加适合项目编写</p><p>​    在JDK1.8之后Runnable成为了函数式接口,所以此时的代码可以使用Lambda进行定义</p><p>​    <strong>Lambda表达式</strong></p><pre class="line-numbers language-none"><code class="language-none">()-&gt;&#123;&#125;  &#x2F;&#x2F;()表输入参数,&#123;&#125;里面是表达式或者返回值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    范例：使用Lambda表达式修改Runnable接口程序实现多线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"个线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    此时Lambda表达式本质上还是Runnable接口的实例</p><p>​    <strong>Thread类与Runnable接口关系</strong></p><p><a href="https://imgtu.com/i/ICrjVP"><img src="https://z3.ax1x.com/2021/11/01/ICrjVP.png" alt="ICrjVP.png"></a></p><ol><li><p>为什么Thread接收Runnable接口对象之后，会去调用真实线程类中的run()方法呢？</p><p>因为当Runnable接口传递到Thread类中之后，会自动利用Thread类中的target属性保存Runnable的接口实例</p></li><li><p>观察Thread类中的run()方法（调用start()就调用Thread类中的run()方法）</p><p>Thread.run()方法定义的时候会判断是否有target实例，如果有此实例，则调用相应的run()方法</p></li></ol><p>​    <strong>多个线程并行操作同一个资源</strong></p><p>​    Runnable接口相比较Thread类更容易描述</p><p>​    范例：观察资源共享</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">MyThread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> ticket <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">30</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ticket<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"票数"</span><span class="token operator">+</span> ticket<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    代码理解图示</p><p><a href="https://imgtu.com/i/IC5xIJ"><img src="https://z3.ax1x.com/2021/11/01/IC5xIJ.png" alt="IC5xIJ.png"></a></p><p>​    <strong>核心结论</strong></p><p>​    <strong>多线程的实现主要依靠Runnable来定义核心的业务处理功能，但是所有关于线程的控制都通过Thread类定义</strong></p><h5 id="3-Callable实现多线程"><a href="#3-Callable实现多线程" class="headerlink" title="3. Callable实现多线程"></a>3. Callable实现多线程</h5><p>​    Java多线程最初依靠Runnable接口来定义线程核心功能类，<strong>但是Runnable接口的run()方法没有返回值</strong></p><p>​    从JDk1.5开始，Java提供一个新的多线程实现接口：Callable，<strong>该接口定义在java.util.concurrent(JUC)，一共提供了三个JUC包</strong></p><p>​    </p><table><thead><tr><th align="center">接口名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@FunctionalInterface public interface Callable&lt; V &gt;</td><td align="center">(函数式接口)在java.util.concurrent包中提供的Callable接口</td></tr></tbody></table><p>​    Callable接口中提供的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">V <strong>call()</strong> throws Exception</td><td align="center">方法</td><td align="center">描述线程的主体方法，与上面的run()方法相同但提供返回值</td></tr></tbody></table><p>​    使用call()方法定义线程主体，线程执行完毕后会将处理结果进行返回</p><p>​    范例：用callable定义线程核心业务类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> ticket <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">300</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ticket<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"票数"</span><span class="token operator">+</span> ticket<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token string">"执行完成"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>Callable接口与Thread类的关系图</strong></p><p><a href="https://imgtu.com/i/IuYocT"><img src="https://z3.ax1x.com/2021/11/05/IuYocT.png" alt="IuYocT.png"></a></p><p>​    要充分理解这个关系，通过与Thread类相联系才可以用start()方法启动线程</p><p>​    范例：启动Callable的多线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>xpath<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>objects<span class="token punctuation">.</span></span><span class="token class-name">XString</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Callable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">FutureTask</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> callA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> callB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> futurecallA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>callA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futurecallA<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futurecallA<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futurecallA<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> ticket <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">30</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ticket<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"票数"</span><span class="token operator">+</span> ticket<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token string">"执行完成"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    Callable和Runnable两个多线程接口的差别在于是否有返回值</p><p>​    <strong>多线程的几种状态</strong></p><p><a href="https://imgtu.com/i/IQEGtg"><img src="https://z3.ax1x.com/2021/11/06/IQEGtg.png" alt="IQEGtg.png"></a></p><p>​    </p><p>​    所有的系统的资源是有限的，不管多线程还是多进程都必须在执行一段时间之后让出资源，交由其他的线程继续执行</p><ol><li>创建过程：开发者定义好了相应的线程类对象(每一个Thread类的实例)</li><li>就绪状态：多线程的启动依靠的是start()方法，当调用start()方法的时候所有的线程不是立即执行，而是将进入到等待状态，等待CPU进行调度</li><li>执行状态：当CPU执行调度到了某个线程对象之后，该线程对象开始执行run()方法或call()方法，此时不是持续占用资源，而是在一段时间之后(一共时间片时间)，该线程就需要暂停执行</li><li>阻塞状态：当某个线程不再执行时(中断、休眠或调度失败)，那么所有的线程将进入到阻塞状态，如果此时线程没有执行完毕，则由阻塞状态切换到就绪状态，重新等待CPU执行调度</li><li>终止状态：如果多线程的执行体执行完毕或者被强制性的结束，那么就将进入到终止状态，终止状态不会再进入到就绪状态，即该线程对象将不会被继续执行</li></ol><h4 id="8-多线程操作方法-Thread类"><a href="#8-多线程操作方法-Thread类" class="headerlink" title="8. 多线程操作方法(Thread类)"></a>8. 多线程操作方法(Thread类)</h4><p>​    Thread类是实现线程的控制，所以除了有启动多线程的方法之外，也包含一些其他方法</p><h5 id="1-线程的命名与获取"><a href="#1-线程的命名与获取" class="headerlink" title="1. 线程的命名与获取"></a>1. 线程的命名与获取</h5><p>​     对于所有的线程对象而言，只能通过名称来进行线程的唯一标记</p><p>​    Thread类提供有方法实现线程名称的操作</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public Thread(Runnable target, String name)</td><td align="center">构造方法</td><td align="center">接收Runnable以及线程的名字</td></tr><tr><td align="center">public final void setName(String name)</td><td align="center">方法</td><td align="center">设置&amp;修改线程名字（一般不要去改）</td></tr><tr><td align="center">public final String getName()</td><td align="center">方法</td><td align="center">返回线程的名字</td></tr><tr><td align="center">public <strong>static</strong> Thread currentThread()</td><td align="center">方法</td><td align="center">返回对当前执行的线程对象的引用(因为线程不可控，你不知道执行到哪一个线程了)</td></tr></tbody></table><p>​    范例：线程名字的获取</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> th <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//等同于创造一个Runnable实例</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>th<span class="token punctuation">,</span><span class="token string">"线程A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>th<span class="token punctuation">,</span><span class="token string">"线程B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"线程运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：如果没有为线程设置名称，线程会自动生成线程名称</p><p>​    如果不使用start()启动run方法，而是直接类名.run()，<strong>此时是main()线程运行，即main方法本身就是一个线程，主线程</strong></p><p>​    当用户使用java命令解释一个类的时候，实际上会启动一共JVM的进程，<strong>即所有JVM程序运行时都会默认启动一个新的进程，所有的线程都是在这个进程产生的，该进程执行时默认启动一共主线程，又由主线程创建若干个子线程，所有线程并行执行</strong></p><h5 id="2-线程的休眠"><a href="#2-线程的休眠" class="headerlink" title="2. 线程的休眠"></a>2. 线程的休眠</h5><p>​    一般情况下线程对象只要启动了，那么就会持续的运行，一直到其运行完毕为止，<strong>如果想减慢线程的执行速度，就可以对其使用休眠处理</strong></p><p>​    Thread类中提供线程休眠操作的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public <strong>static</strong> void sleep(long millis) throws InterruptedException</td><td align="center">方法</td><td align="center">休眠，单位毫秒</td></tr><tr><td align="center">public static void sleep(long millis, int nanos) throws InterruptedException</td><td align="center">方法</td><td align="center">休眠，单位毫秒，纳秒</td></tr></tbody></table><p>​    以第一个方法为主，<strong>sleep()方法为静态方法，静态调用即可</strong></p><p>​    <strong>InterruptedException为中断异常，所有的休眠都会有中断的问题</strong></p><h5 id="3-线程的中断"><a href="#3-线程的中断" class="headerlink" title="3. 线程的中断"></a>3. 线程的中断</h5><p>​    所有线程的执行都是可以被中断的</p><p>​    Thread类中提供有中断处理的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public void interrupt()</td><td align="center">方法</td><td align="center">中断线程</td></tr><tr><td align="center">public boolean isInterrupted()</td><td align="center">方法</td><td align="center">判断线程的中断状态</td></tr></tbody></table><p>​    范例：线程中断处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> my <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">"执行中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程执行完毕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程被中断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程的是否中断"</span><span class="token operator">+</span>my<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//主线程打断my线程</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程的是否中断"</span><span class="token operator">+</span>my<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>线程中断的本质：一个线程被另外一个线程打断执行</strong></p><p>​    线程一旦被中断之后会引发中断异常</p><h5 id="4-线程的强制执行-强制让出资源"><a href="#4-线程的强制执行-强制让出资源" class="headerlink" title="4. 线程的强制执行(强制让出资源)"></a>4. 线程的强制执行(强制让出资源)</h5><p>​    当一个程序有若干个线程时，那么这若干个线程一定是交替执行的状态。但如果某个线程特别急，需要优先处理完成，则可以使用线程的强制执行</p><p>​    Thread类中提供了强制执行的方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public final void join() throws InterruptedException</td><td align="center">方法</td><td align="center">程序会等待调用join方法的线程运行完，再执行当前线程</td></tr><tr><td align="center">public final void join(long millis) throws InterruptedException</td><td align="center">方法</td><td align="center">程序会等待调用join方法的线程运行若干毫秒，再执行当前线程</td></tr><tr><td align="center">public final void join(long millis, int nanos) throws InterruptedException</td><td align="center">方法</td><td align="center">程序会等待调用join方法的线程运行若干毫秒以及纳秒，再执行当前线程</td></tr></tbody></table><p>​    范例：线程的强制执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> my <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里应当调主线程实例，让主线程先执行，而不是自己让自己执行</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行，x ="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行，x ="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：像这样自己让自己先执行的话，这个线程之间就不会继续运行了</strong></p><h5 id="5-线程的礼让"><a href="#5-线程的礼让" class="headerlink" title="5. 线程的礼让"></a>5. 线程的礼让</h5><p>​    礼让指让出当前执行操作，类似让座，多线程并行执行时，礼让一次其他线程让它优于礼让的线程先执行</p><p>​    Thread类中提供礼让操作的方法：</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public <strong>static</strong> void yield()</td><td align="center">方法</td><td align="center">让当前线程让出一次，让其他线程优先执行一次</td></tr></tbody></table><p>​    范例：线程的礼让</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> a <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> my <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"礼让"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行，x ="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"子线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行 , j ="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：线程礼让不一定会成功，可能失败</strong></p><h5 id="6-线程的优先级"><a href="#6-线程的优先级" class="headerlink" title="6. 线程的优先级"></a>6. 线程的优先级</h5><p>​    理论上线程的优先级越高，越有<strong>可能先执行</strong></p><p>​    在Thread类中提供有优先级的操作方法：</p><table><thead><tr><th align="center">方法及常量</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public final void setPriority(int newPriority)</td><td align="center">方法</td><td align="center">设置优先级，int newPriority的范围为[MIN_PRIORITY ~ MAX_PRIORITY]</td></tr><tr><td align="center">public final int getPriority()</td><td align="center">方法</td><td align="center">获取当前线程优先级</td></tr><tr><td align="center">public static final int MIN_PRIORITY</td><td align="center">常量</td><td align="center">最低优先级（整型数值为1）</td></tr><tr><td align="center">public static final int NORM_PRIORITY</td><td align="center">常量</td><td align="center">中等优先级（整型数值为5）</td></tr><tr><td align="center">public static final int MAX_PRIORITY</td><td align="center">常量</td><td align="center">最高优先级（整型数值为10）</td></tr></tbody></table><p>​    范例：设置线程优先级</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span> my <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行 , x ="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>my<span class="token punctuation">,</span><span class="token string">"线程A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>my<span class="token punctuation">,</span><span class="token string">"线程B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>my<span class="token punctuation">,</span><span class="token string">"线程C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>MAX_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>MIN_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>MIN_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：一般未设置优先级时，子线程优先级为NORM_PRIORITY，主线程优先级为NORM_PRIORITY</strong></p><h4 id="9-多线程的同步与死锁"><a href="#9-多线程的同步与死锁" class="headerlink" title="9. 多线程的同步与死锁"></a>9. 多线程的同步与死锁</h4><p>​    多线程的优势在于，可以使用多个并行的程序处理同一个操作业务，这样可以实现业务功能的快速处理，但是<strong>在进行多个线程并发资源访问的时候也会造成不同步的因素</strong></p><h5 id="1-同步问题引出"><a href="#1-同步问题引出" class="headerlink" title="1. 同步问题引出"></a>1. 同步问题引出</h5><p>​    设计一个多线程买票程序，一共一百张票，要五个线程进行售票处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">TicketThread</span> th <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TicketThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>th<span class="token punctuation">,</span><span class="token string">"售票"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">TicketThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span>  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">120</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"卖票，剩余票数为："</span><span class="token operator">+</span> x<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    会发现运行结果的问题</p><p><a href="https://imgtu.com/i/IaYMUs"><img src="https://z3.ax1x.com/2021/11/10/IaYMUs.png" alt="IaYMUs.png"></a></p><p>​    这就是线程不同步</p><p>​    <strong>图示：</strong></p><p><a href="https://imgtu.com/i/IaNHEQ"><img src="https://z3.ax1x.com/2021/11/10/IaNHEQ.png" alt="IaNHEQ.png"></a></p><p>​    <strong>注意：线程的休眠只是放大问题，不是问题的本因</strong></p><p>​    <strong><em>不同步问题核心的本质：多个线程并行执行操作</em></strong></p><h5 id="2-线程同步处理"><a href="#2-线程同步处理" class="headerlink" title="2. 线程同步处理"></a>2. 线程同步处理</h5><p>​    要解决上面的问题，需要使用同步，而<strong>同步就是指：多个操作在同一个时间段内只能有一个线程进行，其他线程要等待此线程完成之后才可以继续执行</strong></p><p>​    线程的同步处理通过<strong>synchronized</strong>关键字来实现</p><p>​    <strong>synchronized的使用有两种模式：同步代码块和同步方法</strong></p><ul><li><p>同步代码块</p><p>指使用synchronized关键字定义的代码块，在进行使用时<strong>必须要设置一个同步的对象</strong>，这个对象往往为当前资源的对象，<strong>可以使用this描述</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>同步对象<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//所有的同步处理操作代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>范例：更改上面售票代码，实现同步处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">TicketThread</span> th <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TicketThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>th<span class="token punctuation">,</span><span class="token string">"售票"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">TicketThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span>  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">120</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"卖票，剩余票数为："</span><span class="token operator">+</span> x<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当使用了同步代码块之后，所有的线程一个一个的执行，所以这个时候就解决了数据并发访问的安全问题，<strong>但是会带来执行性能过慢的性能问题</strong></p></li></ul><ul><li><p>同步方法</p><p>指的是使用了“synchronized”关键字定义的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">修饰符 <span class="token keyword">synchronized</span> 返回值 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//需要同步的代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>  <strong>注意：同步方法比同步代码块更常见</strong></p><h5 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h5><p>​    <em>同步的本质：一个线程要等待其他线程执行完毕</em></p><p>​    <strong>synchronized关键字</strong></p><p>​    <strong>synchronized的作用域默认是当前对象，这时锁就是对象，谁拿到这个锁谁就可以运行它所控制的那段代码。如果这个对象有多个synchronized方法，其它线程就不能同时访问这个对象中任何一个synchronized方法</strong></p><p>​    在项目中，不正当的同步处理有可能造成死锁，<strong>即两个线程彼此相互等待</strong></p><pre><code>  范例：死锁的产生情况**（本身无意义）**</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span>  <span class="token class-name">Play</span> play <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span>  <span class="token class-name">Learn</span> learn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Learn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>play<span class="token punctuation">.</span><span class="token function">said</span><span class="token punctuation">(</span>learn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>learn<span class="token punctuation">.</span><span class="token function">said</span><span class="token punctuation">(</span>play<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Play</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">said</span><span class="token punctuation">(</span><span class="token class-name">Learn</span> learn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"玩完就学习"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>learn<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"学完了，这就去玩"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Learn</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">said</span><span class="token punctuation">(</span><span class="token class-name">Play</span> play<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"学完才能玩"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>play<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"玩完了，这就去学习"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在实际的项目中，死锁是通过大量的程序测试得出来的，上述代码只是死锁的表现，不具有真实开发意义</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统03</title>
      <link href="/2021/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03/"/>
      <url>/2021/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F03/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU与多进程"><a href="#CPU与多进程" class="headerlink" title="CPU与多进程"></a>CPU与多进程</h2><h4 id="1-多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心"><a href="#1-多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心" class="headerlink" title="1. 多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心"></a>1. 多进程是管理CPU提出来的，通过管理明白CPU而后会管理其他硬件，所以说多进程是操作系统的核心</h4><h4 id="2-CPU的工作原理"><a href="#2-CPU的工作原理" class="headerlink" title="2. CPU的工作原理"></a>2. CPU的工作原理</h4><p>​    把一个程序存放在内存中，设置一个地址，CPU根据这个地址发出一条取址的命令，即把这个地址从地址总线上由内存发给CPU，CPU得到程序后开始解释执行</p><p>​    <strong>CPU的工作就是不断的自动取址执行</strong></p><h4 id="3-CPU的管理"><a href="#3-CPU的管理" class="headerlink" title="3. CPU的管理"></a>3. CPU的管理</h4><p>​    设置好PC初值就行（<strong>PC是寄存器</strong>），把PC初值设置在一段程序的开始地址</p><p>​    <strong>问题</strong><br>​    但是如果只是设置好PC初值就等待程序执行会出现一个问题，当程序开始磁盘读写(I/O)时(很慢)，CPU不工作进入等待，而一般一个程序计算时间远比磁盘读写时间少，则造成CPU利用率很低，甚至为0</p><p>​    <strong>解决方式：多到程序、交替执行(让CPU更好的工作)</strong><br>​    当CPU执行程序执行不下去时，就切出换到另外的程序去执行。等再执行不下去再切出，由此使得CPU忙碌，但<strong>所有程序终会在来回切换中执行完</strong></p><p>​    一个CPU上交替的执行多个程序叫做<strong>并发</strong></p><h4 id="4-怎么让CPU并发的工作"><a href="#4-怎么让CPU并发的工作" class="headerlink" title="4. 怎么让CPU并发的工作"></a>4. 怎么让CPU并发的工作</h4><ul><li>控制PC进行切换</li><li>记录程序切出去时的程序执行到的地址，样子（运行的程序和静态程序不一样）</li></ul><h4 id="5-刻画运行程序的样子：进程"><a href="#5-刻画运行程序的样子：进程" class="headerlink" title="5. 刻画运行程序的样子：进程"></a>5. 刻画运行程序的样子：进程</h4><p>​    一个运行中的程序就是一个进程<br>​    所有程序的不一样都存在PCB中</p><h4 id="6-用进程描述CPU管理"><a href="#6-用进程描述CPU管理" class="headerlink" title="6. 用进程描述CPU管理"></a>6. 用进程描述CPU管理</h4><p>​    启动一个进程让CPU去执行这个进程，此时CPU工作；而让CPU更好的工作则是操作系统启动多个进程，让CPU去跑这多个进程，提升CPU利用率。</p><h4 id="7-多进程图像从启动开始到关机结束"><a href="#7-多进程图像从启动开始到关机结束" class="headerlink" title="7. 多进程图像从启动开始到关机结束"></a>7. 多进程图像从启动开始到关机结束</h4><p>​    在开机时在main中创建第一个进程（Linux是shell，Windows是桌面）</p><pre class="line-numbers language-none"><code class="language-none">if(!fork()&#123;init();&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    之后再通过shell启动其他的进程</p><pre class="line-numbers language-none"><code class="language-none">int main(int argc,char *argv[])&#123;while(1)&#123;scanf(&quot;%s&quot;,cmd);if(!fork())&#123;exec(cmd);&#125;wait();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    多进程图示<br><a href="https://imgtu.com/i/IPnpHx"><img src="https://z3.ax1x.com/2021/11/01/IPnpHx.png" alt="IPnpHx.png"></a></p><p>​    通过创建多进程来使用计算机</p><p>​    在Windows下任务管理器可以看见多进程，启动一个进程就是开启一个任务</p><p>​    <strong>操作系统通过管理多线程来管理计算机，用户使用计算机就是启动一堆进程，用户管理计算机就是管理一堆进程</strong></p><h4 id="8-多进程如何组织"><a href="#8-多进程如何组织" class="headerlink" title="8. 多进程如何组织"></a>8. 多进程如何组织</h4><p>​    PCB：用来记录进程信息的数据结构</p><p>​    操作系统通过PCB(进程控制块)来感知和组织进程（用PCB形成队列）</p><p>​    进程状态转换图<br><a href="https://imgtu.com/i/IEj5qS"><img src="https://z3.ax1x.com/2021/11/03/IEj5qS.png" alt="IEj5qS.png"></a></p><p>​    <strong>状态的转化是操作系统来实现的，通过不断的转化推进进程</strong></p><h4 id="9-进程调度"><a href="#9-进程调度" class="headerlink" title="9. 进程调度"></a>9. 进程调度</h4><ol><li><p>FIFO</p><p>先来先付，最简单的调度，谁第一谁先</p><ol start="2"><li>Priority</li></ol><p>优先级设定，最短的先做</p></li></ol><h4 id="10-多进程的地址分离"><a href="#10-多进程的地址分离" class="headerlink" title="10. 多进程的地址分离"></a>10. 多进程的地址分离</h4><p>​    阻止两个以上进程在来回切换时访问同一个地址（通过映射表实现），使得地址在逻辑上可以相同但是物理上是不同</p><p>​    <strong>所以说进程管理连带内存管理形成多进程图像</strong></p><h4 id="11-多进程的合作问题"><a href="#11-多进程的合作问题" class="headerlink" title="11. 多进程的合作问题"></a>11. 多进程的合作问题</h4><p>​    如打印任务，存在一个打印文件队列，有进程往里面放要打印的东西（但是两个进程交替进行但是同时放会产生错误），有进程从中取出进行打印</p><p>​    <strong>解决方式上锁（即进程同步(合理的推进方式)）</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统02</title>
      <link href="/2021/10/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02/"/>
      <url>/2021/10/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><h4 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h4><p>​    连接两个东西、完成信号转换、屏蔽细节<br>​    接口表现为函数的调用，函数又由系统提供，也称为系统调用</p><p>​    上层是调用底层（使用接口），而接口就是通过普通的C语言加上一些重要操作系统函数的调用</p><p>​    <strong>操作系统接口表现为函数调用，又由系统提供，所以称为系统调用</strong>，系统调用是操作系统给上层提供的接口</p><p>​    shell是一个永不停机的程序</p><p>​    Linux 0.11没有图形界面</p><h4 id="2-POSIX（统一的接口）"><a href="#2-POSIX（统一的接口）" class="headerlink" title="2. POSIX（统一的接口）"></a>2. POSIX（统一的接口）</h4><p>​    要知道去哪里去查，网上可以下载，如果开发的操作系统满足这个要求，则在Linux上开发的应用程序也可以在你的操作系统上跑</p><h4 id="3-系统调用的实现"><a href="#3-系统调用的实现" class="headerlink" title="3. 系统调用的实现"></a>3. 系统调用的实现</h4><p>​    (1).不能随意的调用内核的数据，这样会使得操作系统不安全（像root被获取）</p><p>​    (2).通过硬件来保证不能随意的调用内核的数据，即（区分内核态用户态(把内存割成两个区域)），<strong>内核态可以访问任何数据，用户态不能访问内核数据</strong>，0是内核态，3是用户态</p><p>​    (3).通过段寄存器来实现(因为内存都是一段一段的)<br>​    DPL&gt;=CPL，只有满足才可以访问<br>​    DPL：(用来描述目标内存段的特权级)，即你要访问的目标段的特权级<br>​    CPL：(CS)，即当前所处在的特权级</p><p>​    (4).硬件提供了主动进入内核的方法(中断指令int)<br>​    是计算机提供的唯一方法进入内核<br>​    int指令将使CS中的CPL改成0，进入内核</p><h4 id="4-系统调用的核心"><a href="#4-系统调用的核心" class="headerlink" title="4. 系统调用的核心"></a>4. 系统调用的核心</h4><ol><li>用户程序中一段包含int指令的代码，进去的话一定是(int 0x80)</li><li>操作系统写中断处理，获取想调程序的编号</li><li>操作系统根据编号执行相应代码</li></ol><h4 id="5-int-0x80的具体实现"><a href="#5-int-0x80的具体实现" class="headerlink" title="5. int 0x80的具体实现"></a>5. int 0x80的具体实现</h4><p>​    int指令通过查看idt表来选择中断需要转去哪里进行执行<br>​    idt表和gdt表长的非常相似<br>​    在系统进行初始化时，就已经对int 0x80进行处理定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sched_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">set_system_gate</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>system_call<span class="token punctuation">)</span> <span class="token comment">//每次要调用时就取中断函数地址system_call调用0x80</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    int 0x80进入后将DPL制成3，CS为8，IP=system_call，CPL为CS的后两位为0</p><p>​    从int 0x80返回后就一切恢复之前</p><h4 id="6-操作系统历史"><a href="#6-操作系统历史" class="headerlink" title="6. 操作系统历史"></a>6. 操作系统历史</h4><h5 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h5><h6 id="1-操作系统的演变"><a href="#1-操作系统的演变" class="headerlink" title="1. 操作系统的演变"></a>1. 操作系统的演变</h6><p>​    随着计算机不断发展后，需要完成多道程序，要使得作业之间进行相互的切换和调度成为核心，如果不切换一定要一个一个等，计算机的速度就会非常的慢，<strong>此时多进程结构和进程管理概念萌芽</strong>，这时制作了OS/360</p><p>​    在之后，任务不可以等到做不下去再进行切换，而是需要主动的进行切换，此时引入了<strong>分时系统</strong>的概念，此时一个计算机可以多个人进行使用，这时制作的是MULTICS</p><p>​    再之后由MULTICS发明了UNIX</p><h6 id="2-PC与DOS"><a href="#2-PC与DOS" class="headerlink" title="2. PC与DOS"></a>2. PC与DOS</h6><p>​    由DOS演变为Windows，Windows主要是磁盘、文件、命令令人使用方便</p><p>​    再之后在Windows3.0加入图形界面</p><p>​    </p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><h6 id="1-操作系统的演变-1"><a href="#1-操作系统的演变-1" class="headerlink" title="1. 操作系统的演变"></a>1. 操作系统的演变</h6><p>​    <strong>多进程结构是操作系统基本图谱，要掌握，并且实现它</strong></p><p>​    多进程结构图示：**(当一个系统进入打印或其他操作使得CPU等待时，跳转到下一个作业，之后再转回来)**</p><p><a href="https://imgtu.com/i/54jP0O"><img src="https://z3.ax1x.com/2021/10/25/54jP0O.png" alt="54jP0O.png"></a></p><p>​    对于操作系统实现概念远比理解概念重要</p><h6 id="2-PC与DOS-1"><a href="#2-PC与DOS-1" class="headerlink" title="2. PC与DOS"></a>2. PC与DOS</h6><p>​    文件、开发环境、图形界面对于OS的重要性，<strong>要掌握、实现操作系统的文件操作视图</strong></p><h5 id="核心思想，技术"><a href="#核心思想，技术" class="headerlink" title="核心思想，技术"></a>核心思想，技术</h5><ul><li>程序执行、多线程、程序执行带动其他设备使用的基本结构</li><li>对用户的使用感觉：各种文件、编程环境、图形界面</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java14</title>
      <link href="/2021/10/25/Java14/"/>
      <url>/2021/10/25/Java14/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="1-泛型是在JDK1-5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题"><a href="#1-泛型是在JDK1-5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题" class="headerlink" title="1. 泛型是在JDK1.5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题"></a>1. 泛型是在JDK1.5之后主要引入的一项技术，其主要的目的是为了解决类对象的安全隐患问题</h4><h4 id="2-泛型问题的引出"><a href="#2-泛型问题的引出" class="headerlink" title="2. 泛型问题的引出"></a>2. 泛型问题的引出</h4><p>​    在Java中，最方便的参数统一使用Object类型，但是并不是意味所有的Object都可以解决实际问题</p><p>​    现在假设需要一个描述坐标点的信息类(Point)，该类中可以保存三种坐标类型</p><ul><li><p>保存整型</p></li><li><p>保存浮点型</p></li><li><p>保存字符串</p></li></ul><p>​    此时，要保证三类数据的保存，只有通过Object类型可以解决</p><p>​    <strong>Point类的设计</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token class-name">Object</span> x<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">Object</span> y<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token class-name">Object</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在使用这个类时，需要进行向上转型输入和向下转型输出。但是，由于Object所能描述的范围太广泛了，所以<strong>可能传入了字符串类型任何转型时不小心转为了int(其他)类型</strong>，此时代码在<strong>编译时可以通过，执行时出现”ClassCastException“异常</strong>，<strong>由此可以看出Object提供的解决方案实际上会存在安全隐患</strong>，所以Object类作为参数是项目中最大的败笔</p><h4 id="3-泛型基本定义"><a href="#3-泛型基本定义" class="headerlink" title="3. 泛型基本定义"></a>3. 泛型基本定义</h4><p>​    通过分析Object作为参数的优缺点，<strong>要想解决对象转型安全隐患问题，最简单的方式就是不转型</strong><br>​    JDk1.5后提供了泛型的概念，泛型&lt; T &gt;最大的特点为，类中的属性类型或方法的参数，可以在类的使用时，动态决定<br>​    <strong>范例：修改Point类的设计</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span> <span class="token comment">//T表示Type的意思，不一定要T写其他的也可以</span><span class="token keyword">private</span> <span class="token class-name">T</span> x<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">T</span> y<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token class-name">T</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在Point类上定义的泛型T实际上只是一个随机设置的名称，表示的是，该类型由使用的时候来决定，<strong>泛型使用时只能使用引用数据类型，不能使用基本类型</strong></p><p>​    范例：使用泛型声明的类Point</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws Exception&#123;Point&lt;Integer&gt; a &#x3D; new Point&lt;Integer&gt;();a.setX(10);a.setY(20);System.out.println(&quot;x &#x3D; &quot;+a.getX()+ &quot;,y &#x3D; &quot;+a.getY());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    注意：使用泛型后，所有程序之中具有泛型标记的部分都会更换为相应的类型标记，这个标记在类对象实例化的时候进行动态的配置，此时就不需要转型了，而且编译时会帮助检测错误</p><p>​    <strong>注意：如果使用了泛型设计类但是使用这个类并没有给泛型，那么会把泛型中所有的T变成Object类型，Object的使用就需要转型了</strong></p><h4 id="4-泛型通配符"><a href="#4-泛型通配符" class="headerlink" title="4. 泛型通配符"></a>4. 泛型通配符</h4><p>​    泛型的出现解决了数据类型的转换安全问题，但是随之而来也会带来引用传递的麻烦。<strong>为解决该问题则用通配符对形参进行约束</strong></p><p>​    范例：泛型的引用传递</p><pre class="line-numbers language-none"><code class="language-none">package hello;class Message&lt;T&gt;&#123;private T info;public void setMessage(T info) &#123;this.info &#x3D; info;&#125;public T getMessage() &#123;return this.info;&#125;&#125;public class First&#123;public static void main(String[] args) throws Exception&#123;Message&lt;String&gt; msg &#x3D; new Message&lt;String&gt;();msg.setMessage(&quot;篮球&quot;);print(msg);&#125;public static void print(Message&lt;String&gt; msg) &#123;System.out.println(msg.getMessage());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：</strong></p><ol><li>泛型作为形参不可以作为重载标识，重载的参数类型名以类名作为标识与泛型无关</li><li>泛型在作为形参时需要注明泛型的类型</li><li>如果没有声明泛型类型，传过来则使用Object类型来代替未设置的泛型标记，也就说传过来后的泛型可以设置成任意类型</li></ol><p>​    <em>为了解决3这个问题，泛型里提供了通配符”?“</em><br>​    使用通配符”?“会限制程序不可以修改传过来的对象，此时对象仍然为object类型(可以描述一切的泛型类型)，但无法进行修改(取和改)</p><p>​    在通配符?的基础之上，又产生了两个通配符的应用：</p><ul><li>设置泛型的下限：? super类;<br>​    例如：”? super String“，表示可以设置的泛型类只能够是String以及其父类(Object)</li><li>设置泛型的上限：? extands 类;<br>​    例如：”? extends Number“：表示所设置的泛型类型只能够是Number或者其子类<br>​    <strong>注意：泛型的上限可以对类进行修饰(类&lt; T extends 类(界限)&gt;)</strong></li></ul><h4 id="5-泛型接口"><a href="#5-泛型接口" class="headerlink" title="5. 泛型接口"></a>5. 泛型接口</h4><p>​    泛型也可以应用在接口上，此类接口称为泛型接口</p><p>​    泛型接口的定义</p><pre class="line-numbers language-none"><code class="language-none">interface IMessage&lt;T&gt;&#123;public void send(T content);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    所有的接口在使用的时候都必须依靠子类，那么在此时子类有两种实现泛型接口的方式</p><ul><li>方式一：在子类中继续指定泛型标记<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">IMessage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">T</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MessageImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">IMessage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">T</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token class-name">IMessage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//后面的String可以省略，尖括号还是需要</span>a<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​    上面代码的注释中，在JDK1.8出现了一个自动推导泛型的概念，因为每一次前后都需要编写泛型类型，过于复杂，所以现在前面定义了泛型类型，那么后面就可以不需要重复定义了</p><ul><li>方式二：子类不再设置泛型类型，而为父类指派好类型</li></ul><pre class="line-numbers language-none"><code class="language-none">package hello;interface IMessage&lt;T&gt;&#123;public void send(T content);&#125;class MessageImpl implements IMessage&lt;String&gt;&#123;public void send(String content) &#123; System.out.println(content);&#125;&#125;public class First&#123;public static void main(String[] args) throws Exception&#123;IMessage&lt;String&gt; a &#x3D; new MessageImpl();a.send(&quot;hello&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-泛型方法"><a href="#6-泛型方法" class="headerlink" title="6. 泛型方法"></a>6. 泛型方法</h4><p>​    所有泛型方法不一定非要定义在泛型的类或泛型接口之中，这也就是说任意一个方法都可以定义为泛型方法，但是需要对泛型标记（&lt;  T &gt;）加以声明</p><p>​    范例：定义泛型方法<br>​    此时对于传入的参数类型就由调用方法的语句来外部定义了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//T[]表示T类型数组</span><span class="token keyword">return</span> args<span class="token punctuation">;</span> <span class="token comment">//返回是类对象</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    知道一个方法如何去定义一个泛型就行了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射实例</title>
      <link href="/2021/10/25/%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B/"/>
      <url>/2021/10/25/%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-静态工厂"><a href="#1-静态工厂" class="headerlink" title="1. 静态工厂"></a>1. 静态工厂</h3><pre class="line-numbers language-none"><code class="language-none">package hello;public class First&#123;public static void main(String[] args) throws Exception&#123;Message msg &#x3D; factory.getMessage(&quot;PaperMessage&quot;);msg.send(&quot;静态工厂&quot;);&#125;&#125;interface Message&#123;public void send(String msg);&#125;class PaperMessage implements Message&#123;public void send(String msg) &#123;System.out.println(&quot;【报纸报道】：&quot;+ msg);&#125;&#125;class InternalMessage implements Message&#123;public void send(String msg) &#123;System.out.println(&quot;【网络报道】：&quot;+ msg);&#125;&#125;&#x2F;&#x2F;工厂类，隐藏构造方法，提供分发的方法class factory&#123;private factory() &#123;&#125;public static Message getMessage(String className) &#123;if(&quot;PaperMessage&quot;.equals(className)) &#123;return new PaperMessage();&#125;else if(&quot;InternalMessage&quot;.equals(className)) &#123;return new InternalMessage();&#125;elsereturn null;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用反射修改后的静态工厂"><a href="#2-使用反射修改后的静态工厂" class="headerlink" title="2. 使用反射修改后的静态工厂"></a>2. 使用反射修改后的静态工厂</h3><pre class="line-numbers language-none"><code class="language-none">package hello;import java.lang.reflect.InvocationTargetException;public class First&#123;public static void main(String[] args) throws Exception&#123;Message msg &#x3D; factory.getMessage(&quot;hello.PaperMessage&quot;);msg.send(&quot;静态工厂&quot;);&#125;&#125;interface Message&#123;public void send(String msg);&#125;class PaperMessage implements Message&#123;public void send(String msg) &#123;System.out.println(&quot;【报纸报道】：&quot;+ msg);&#125;&#125;class InternalMessage implements Message&#123;public void send(String msg) &#123;System.out.println(&quot;【网络报道】：&quot;+ msg);&#125;&#125;&#x2F;&#x2F;使用反射修改了工厂类class factory&#123;private factory() &#123;&#125;public static Message getMessage(String className) &#123;Message msg &#x3D; null;try &#123;msg &#x3D; (Message)Class.forName(className).getDeclaredConstructor().newInstance();&#125; catch (Exception e) &#123;e.printStackTrace();&#125;return msg;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-反射获取类结构"><a href="#3-反射获取类结构" class="headerlink" title="3. 反射获取类结构"></a>3. 反射获取类结构</h3><pre class="line-numbers language-none"><code class="language-none">package hello;import java.util.Arrays;public class First&#123;public static void main(String[] args)&#123;Class&lt;?&gt; clazz &#x3D; D.class;System.out.println(&quot;【包名称：】&quot;+clazz.getPackageName());System.out.println(&quot;【继承的父类：】&quot;+clazz.getSuperclass());System.out.println(&quot;【继承的接口：】&quot;+Arrays.toString(clazz.getInterfaces()));&#125;&#125;interface A&#123;&#125;interface B&#123;&#125;abstract class C implements A,B&#123;&#125;abstract class D extends C implements A,B&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java13</title>
      <link href="/2021/10/24/Java13/"/>
      <url>/2021/10/24/Java13/</url>
      
        <content type="html"><![CDATA[<h2 id="反射-Class-lt-gt"><a href="#反射-Class-lt-gt" class="headerlink" title="反射(Class&lt; ? &gt;)"></a>反射(Class&lt; ? &gt;)</h2><h4 id="1-Java的反射机制"><a href="#1-Java的反射机制" class="headerlink" title="1. Java的反射机制"></a>1. Java的反射机制</h4><p>​    Java语言最为重要的特性之一就是反射机制的存在，这个机制使得Java设计更加的灵活<br>​    要写出高复用的代码就要去学习Java反射，几乎所有的Java开发框架都为Java的反射应用</p><h4 id="2-反射的“反”"><a href="#2-反射的“反”" class="headerlink" title="2. 反射的“反”"></a>2. 反射的“反”</h4><p>​    在常规的做法是明确知道一个类之后，导入此类随后进行对象实例化处理，但反射可以依据实例化对象找到其根源。</p><h4 id="3-Object类中的getClass-方法"><a href="#3-Object类中的getClass-方法" class="headerlink" title="3. Object类中的getClass()方法"></a>3. Object类中的getClass()方法</h4><table><thead><tr><th>public final Class&lt;?&gt;  getClass()</th></tr></thead><tbody><tr><td>获得该类型详细描述。Class&lt;?&gt;的意思为记录了该类的一切信息</td></tr></tbody></table><p>​    <strong>注意：该方法不能被重写</strong></p><h4 id="4-反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要"><a href="#4-反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要" class="headerlink" title="4. 反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要"></a>4. 反射的根源是Class类，Java对实例化的操作提供三类支持，实际项目都是混用都重要</h4><ol><li>利用Object类中提供的getClass()方法，通过实例化调用获得</li><li>利用“类.class”的Java原生代码操作实现<br>示例<pre class="line-numbers language-none"><code class="language-none">Class&lt;?&gt; clsA &#x3D; java.util.Date.class  &#x2F;&#x2F;这个类必须存在<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>利用Class类中提供的forName()方法进行实例化<table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public <strong>static</strong> Class&lt; ? &gt; forName(String className) <strong>throws ClassNotFoundException</strong></td><td align="center">此类方法需要将加载反射类型的名称进行定义(通过字符串描述要使用类的名称)，而且定义的时候要求使用类的完整名称“包.类”，如果该类不存在则会出现”ClassNotFoundException”，也就意味着要进行加载的类一定要放在CLASSPATH可以识别</td></tr></tbody></table></li></ol><p>​    示例</p><pre class="line-numbers language-none"><code class="language-none">Class&lt;?&gt; clsA &#x3D; Class.forName(&quot;java.util.Date&quot;) &#x2F;&#x2F;需要包.类<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个与第二个的区别是第二个必须要类存在,这个写错的话会报异常</p><p>​    <strong>总结：三种形式获取Class类实例的特点</strong></p><ul><li>**getClass()**：需要明确的获得使用类的实例化对象；</li><li><strong>类.class</strong>：需要明确的进行操作类的导入处理；</li><li>**Class.forName()**：可以通过字符串描述要使用类的名称(最灵活的)</li></ul><p>​    <strong>注意：反射可以用来代替“new”操作符进行实例化对象，但其操作和“new”关键字一样受到类的构造方法的约束，如果类构造方法为private，在类外它一样不可以实例化对象</strong></p><h4 id="5-反射应用案例"><a href="#5-反射应用案例" class="headerlink" title="5. 反射应用案例"></a>5. 反射应用案例</h4><h5 id="1-反射对象实例化"><a href="#1-反射对象实例化" class="headerlink" title="1. 反射对象实例化"></a>1. 反射对象实例化</h5><p>​    获取Class类对象之后最大用处在于可以直接利用反射提供的方法调用指定类的构造实现对象的实例化，此操作的方法为：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public <strong>T</strong> newInstance() <strong>throws InstantiationException, IllegalAccessException</strong></td><td align="center">反射实例化对象，<strong>T表示返回值为Object类型</strong></td></tr></tbody></table><p>注意：由于反射定义中的泛型比较尴尬所以出现“?”居多，“?”的返回为Object</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;clazz表示class的实例化对象Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;java.util.Date&quot;);Object obj &#x3D; clazz.newInstance(); &#x2F;&#x2F;反射实例化对象，相当于表示“new java.util.Date()”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：上面代码反射为Object类型，如果要使用Date类的对象需要对obj进行向下转型，若只是需要对象则可以直接使用obj</strong></p><h5 id="2-反射与工厂设计模式"><a href="#2-反射与工厂设计模式" class="headerlink" title="2. 反射与工厂设计模式"></a>2. 反射与工厂设计模式</h5><p>​    工厂设计模式常用来获取接口实例，属于java面向对象编程的基本模型<br>​    使用工厂模式，在使用new操作符时，也叫做静态工厂</p><pre class="line-numbers language-none"><code class="language-none">class factory&#123;private factory() &#123;&#125;public static Message getMessage(String className) &#123;if(&quot;PaperMessage&quot;.equals(className)) &#123;return new PaperMessage();&#125;else if(&quot;InternalMessage&quot;.equals(className)) &#123;return new InternalMessage();&#125;elsereturn null;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>详细完整代码见反射实例例一</strong></p><p>​    <strong>静态工厂类的缺点</strong><br>​    当你要添加或者删除接口子类很多时，传统的静态工厂类将无法满足需要，问题产生的原因是关键字“new”，关键字“new”是Java提供的原生对象实例化支持，但需要使用特定的结构使用，一个好的代码new使用的少，所以此时需要使用反射机制来解决</p><p>​    <strong>反射机制的思路</strong><br><a href="https://imgtu.com/i/5ZJDt1"><img src="https://z3.ax1x.com/2021/10/11/5ZJDt1.png" alt="5ZJDt1.png"></a></p><p>​     用反射机制修改工厂类</p><pre class="line-numbers language-none"><code class="language-none">class factory&#123;private factory() &#123;&#125;public static Message getMessage(String className) &#123; Message msg &#x3D; null;try &#123;msg &#x3D; (Message)Class.forName(className).getDeclaredConstructor().newInstance();&#125; catch (Exception e) &#123;e.printStackTrace();&#125;return msg;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：此时由于调用Class.forname()所以方法传字符串(className)必须是完整路径，包+类名</strong></p><p>​    <strong>详细完整代码见反射实例例二</strong></p><p>​    此时添加子类时就不需要去修改工厂类了</p><h5 id="3-反射与单例设计模式"><a href="#3-反射与单例设计模式" class="headerlink" title="3. 反射与单例设计模式"></a>3. 反射与单例设计模式</h5><p>​    单例设计模式的核心：一个类在一个JVM进程之中只允许有一个实例化对象</p><p>​    单例设计模式的两种结构：饿汉式单例、懒汉式单例（问题比较麻烦，但找工作用这个可以使得问题表述的更加清晰）</p><p>​    懒汉式就是创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建。饿汉式就是在系统初始化的时候我们已经把对象创建好了，需要用的时候直接拿过来用就好了</p><ul><li><p>设计饿汉式单例</p><pre class="line-numbers language-none"><code class="language-none">class SingletonEH &#123;    &#x2F;**     *是否 Lazy 初始化：否     *是否多线程安全：是     *实现难度：易     *描述：这种方式比较常用，但容易产生垃圾对象。     *优点：没有加锁，执行效率会提高。     *缺点：类加载时就初始化，浪费内存。     *它基于 classloder 机制避免了多线程的同步问题，     * 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，     * 在单例模式中大多数都是调用 getInstance 方法，     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，     * 这时候初始化 instance 显然没有达到 lazy loading 的效果。     * 饿汉就是类一旦加载（ java文件通过编译器变成了.class文件），就把单例初始化完成，保证getInstance的时候，单例是已经存在的了     *&#x2F;    private static SingletonEH instance &#x3D; new SingletonEH();    private SingletonEH ()&#123;&#125;    public static SingletonEH getInstance() &#123;        System.out.println(&quot;instance:&quot;+instance);        System.out.println(&quot;加载饿汉式....&quot;);        return instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>设计懒汉式单例</p><pre class="line-numbers language-none"><code class="language-none">class Singleton&#123;&#x2F;**     *是否 Lazy 初始化：是     *是否多线程安全：否     *实现难度：易     *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。     *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。*&#x2F;&#x2F;&#x2F;设置单例，保证只有一个单例private static Singleton instance;&#x2F;&#x2F;私有化构造方法，使之只能在内部调用实例化private Singleton()&#123;System.out.println(&quot;hello&quot;);&#125;&#x2F;&#x2F;通过公有化方法提供对外部的接口public static Singleton getInstance() &#123;if(instance &#x3D;&#x3D; null) &#123;instance &#x3D; new Singleton();&#125;return instance;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​    但是一旦使用多线程，并且结合懒汉式设计时会出现对象的多次实例化<br><a href="https://imgtu.com/i/5mOrjJ"><img src="https://z3.ax1x.com/2021/10/12/5mOrjJ.png" alt="5mOrjJ.png"></a></p><p>​    需要解决问题需要增加同步处理<br>​    <strong>同步是否添加的因素：如果读取不要加同步，如果更新要加同步</strong><br>​    如果直接在方法外增加同步，线程若有10w个线程获取Singleton类的对象，则这10w个线程排队等待，性能会下降<br><a href="https://imgtu.com/i/5mxlan"><img src="https://z3.ax1x.com/2021/10/12/5mxlan.png" alt="5mxlan.png"></a></p><p>​    所以应该在方法内增加同步，而同步内用的对象的获取则使用反射机制</p><p>​    <strong>解决代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;此时即保证了getInstance()方法的操作性能，同时又保护了Singleton类对象的实例化次数class Singleton&#123;private static Singleton instance;private Singleton()&#123;System.out.println(&quot;hello&quot;);&#125;public static Singleton getInstance() &#123;if(instance &#x3D;&#x3D; null) &#123;synchronized(Singleton.class) &#123;if(instance &#x3D;&#x3D; null) &#123;instance &#x3D; new Singleton();&#125;&#125;&#125;return instance;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>代码解释图示</strong><br><a href="https://imgtu.com/i/5nSyuD"><img src="https://z3.ax1x.com/2021/10/12/5nSyuD.png" alt="5nSyuD.png"></a></p><h4 id="6-反射与类操作"><a href="#6-反射与类操作" class="headerlink" title="6. 反射与类操作"></a>6. 反射与类操作</h4><p>​    反射可以完整的实现Java允许规定的类的操作形式<br>​    传统的Java二进制文件对其进行操作就是进行类加载(import、CLASSPATH)；实例化类对象并操作，<strong>对于这些二进制文件的分析(Java中允许你做到的)就是反射</strong>，如果要对这个文件进行更深入的分析，需要使用第三方工具包</p><h5 id="1-反射获取类结构"><a href="#1-反射获取类结构" class="headerlink" title="1. 反射获取类结构"></a>1. 反射获取类结构</h5><p>​    class作为所有反射操作的源头，于是在Class类里面就可以获取clazz的一些结构上的信息，例如：类所在的包、类所继承的父类、已经类所实现的相关的接口，方法如下：</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public Package getPackage()</td><td align="center">方法</td><td align="center">获取程序所在的包名称</td></tr><tr><td align="center">public <strong>Class</strong>&lt; ? super T&gt; getSuperclass()</td><td align="center">方法</td><td align="center">获取所继承的父类</td></tr><tr><td align="center">public Class&lt; ? &gt;[] getInterfaces()</td><td align="center">方法</td><td align="center">获取所有的父接口</td></tr></tbody></table><p>​    之所以通过反射可以获取这些信息，主要是由于Class类拥有了“*.class”二进制数据的分析能力，它实际上是根据二进制的结构文件动态获取的内容。</p><p>​    <strong>详细代码见反射实例例三</strong></p><h5 id="2-反射调用构造方法"><a href="#2-反射调用构造方法" class="headerlink" title="2. 反射调用构造方法"></a>2. 反射调用构造方法</h5><p>​    所有的构造方法都可以利用反射来进行获取，在Class类中定义如下构造方法获取的操作</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public Constructor&lt; T &gt; getConstructor(Class&lt; ? &gt;… parameterTypes) throws NoSuchMethodException, SecurityException</td><td align="center">方法</td><td align="center">根据指定的参数类型获取指定 的构造方法(Public)</td></tr><tr><td align="center">public Constructor&lt; ? &gt;[] getConstructors()                                 throws SecurityException</td><td align="center">方法</td><td align="center">获取类中所有的构造方法(public)</td></tr><tr><td align="center">public Constructor&lt; T &gt; get<strong>Declared</strong>Constructor(Class)&lt; ? &gt;… parameterTypes)                                      throws NoSuchMethodException, SecurityException</td><td align="center">方法</td><td align="center">获取一个类中指定的构造方法(public、protected、default)</td></tr><tr><td align="center">public Constructor&lt; ? &gt;[] get<strong>Declared</strong>Constructors() throws SecurityException</td><td align="center">方法</td><td align="center">获取一个类中的全部构造方法(public、protected、default)</td></tr></tbody></table><p>​    在Java中好用的方法为后两个，因为构造方法不一定只使用public来定义，所以获取的方法应该采用“getDeclaredConstructor”</p><p>​    <strong>获取构造并不意味着要进行简单的输出，这种获取信息的操作只在开发工具中比较常见，但是获取Constructor最大的意义在于其可以进行反射构造调用，提供有如下方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public T <strong>newInstance(Object… initargs)</strong> throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</td><td align="center">方法</td><td align="center">调用指定的构造进行对象实例化处理</td></tr></tbody></table><p>​    范例：利用反射调用指定参数的构造进行实例化</p><pre class="line-numbers language-none"><code class="language-none">package hello;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;class Ball&#123;private String name;private double price;public Ball(String name,double price) &#123;this.name &#x3D; name;this.price &#x3D; price;&#125;public void print() &#123;System.out.println(&quot;球的名字为：&quot;+this.name+&quot;、价格为：&quot; + this.price);&#125;&#125;public class First&#123;public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123;Class&lt;?&gt; clazz &#x3D; Ball.class;&#x2F;&#x2F;获取反射对象Constructor&lt;?&gt; con &#x3D; clazz.getDeclaredConstructor(String.class,double.class);Ball ball &#x3D; (Ball)con.newInstance(&quot;足球&quot;,12.5);ball.print();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    以上操作是JDK1.9之后官方推荐的做法，在JDK1.8及以前的版本里面，关于反射对象的实例化操作实际上提供了两个不同的方法</p><ul><li><p><strong>Class类：</strong>@Deprecated(since)=”9”) public T newInstance() throws InstantiationException, IllegalAccessException</p><p>-默认调用无参构造，如果类中，没有无参构造则将抛出异常；JDK1.9之后就修改为Constructor类调用；</p></li><li><p><strong>Constructor类：</strong>public T newInstance() throws InstantiationException, IllegalAccessException</p></li></ul><h5 id="3-反射调用方法"><a href="#3-反射调用方法" class="headerlink" title="3. 反射调用方法"></a>3. 反射调用方法</h5><p>​    在class类中定义了可以获取类中方法实例的操作</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public Method[] <strong>getMethods()</strong> throws SecurityException</td><td align="center">方法</td><td align="center">获取本类和父类中所有的public方法</td></tr><tr><td align="center">public Method getMethod(String name, Class&lt; ? &gt;… parameterTypes) throws NoSuchMethodException, SecurityException</td><td align="center">方法</td><td align="center">获取一个public的方法，包括父类的方法</td></tr><tr><td align="center">public Method[] <strong>getDeclaredMethods()</strong> throws SecurityException</td><td align="center">方法</td><td align="center">获取本类中所有的方法</td></tr><tr><td align="center">public Method getDeclaredMethod(<strong>String name</strong>, <strong>Class&lt; ? &gt;… parameterTypes</strong>) throws NoSuchMethodException, SecurityException</td><td align="center">方法</td><td align="center">获取本类一个指定类型的Method实例；String name表示方法名称，Class&lt; ? &gt;… parameterTypes表示我要操作的参数类型</td></tr></tbody></table><p>​    当获取了一个方法之后将以Method类的实例进行该方法的描述，Method类的定义方式如下：</p><p>​    <strong>Method类的定义</strong></p><pre class="line-numbers language-none"><code class="language-none">public final class Method extends Executable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    这个类的定义方式和之前Constructor类是完全一样的</p><p>​    图示：</p><p><a href="https://imgtu.com/i/5w4OD1"><img src="https://z3.ax1x.com/2021/10/19/5w4OD1.png" alt="5w4OD1.png"></a> </p><p>​    在Java里面可以利用Method明确的描述一个可以调用的方法结构，可以利用Method实现类中全部方法的输出</p><p>​    范例：获取Ball类中所有的public方法,包括所有父类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationTargetException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Balls</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">toDo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Ball</span> <span class="token keyword">extends</span> <span class="token class-name">Balls</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">SecurityException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz <span class="token operator">=</span> <span class="token class-name">Ball</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token class-name">Method</span> method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Method</span> x<span class="token operator">:</span>method<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    获取method实例后对<strong>该方法</strong>信息获得的方法<strong>（Method类或者其父类（Executable）下的方法）</strong>：</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String getName()</td><td align="center">方法</td><td align="center">获取方法的名字</td></tr><tr><td align="center">public abstract int getModifiers()</td><td align="center">方法</td><td align="center">获取方法前的权限修饰符</td></tr><tr><td align="center">public Class&lt; ? &gt; getReturnType()</td><td align="center">方法</td><td align="center">获取方法的返回值</td></tr><tr><td align="center">public abstract Class&lt; ? &gt;[] getParameterTypes()</td><td align="center">方法</td><td align="center">获取方法的所有参数,返回值为数组</td></tr><tr><td align="center">public Class&lt; ? &gt;[] getExceptionTypes()</td><td align="center"></td><td align="center">获取方法的所有异常</td></tr></tbody></table><p>​    <strong>注意：getModifiers()方法的返回值为int类型，因为所有的权限都是数字的组合(相加)，在java.lang.reflect.Modifier类中有static String toString(int mod)方法，将这些数字反推权限修饰符的字符串</strong></p><p>​    程序配置了任何的第三方工具包,各个开发工具之所以可以进行代码的检测以及方法的获取,就是由于反射机制的支持(二进制数据流的解析处理),但是对于我们开发人员来讲**,真正有意义的代码在于Method类中提供的反射调用方法(非常重要,使用Method类中最有意义的操作)**:</p><pre class="line-numbers language-none"><code class="language-none">public Object invoke(Object obj,Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>invoke()可以直接依据Object类的实例化对象(不一定是具体类型)实现反射方法调用</strong></p><p>​    注意：所有的简单Java类一定要提供有无参构造方法,同时所有的属性必须封装(private),封装后的属性必须编写setter、getter方法</p><p>​    <strong>范例：利用反射调用setter、getter方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Ball</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"hello.Ball"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化对象</span><span class="token class-name">Method</span> setmethod <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"setName"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//参数类型暂时无法动态获取，先固定一个String.class</span>setmethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"篮球"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等价于“实例化对象.setName("篮球")”</span><span class="token class-name">Method</span> getmethod <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"getName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Object</span> a <span class="token operator">=</span> getmethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    此时程序实现了方法的反射调用，同时也解释了为什么简单Java类中的命名要有setter、getter规则</p><h5 id="4-反射调用成员属性"><a href="#4-反射调用成员属性" class="headerlink" title="4. 反射调用成员属性"></a>4. 反射调用成员属性</h5><p>​    类结构里面包含的三个组成：构造、方法、成员属性，那么对于所有的成员属性也是可以通过反射来实现调用，在class类中提供有如下的与成员有关的操作方法</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public Field[] getFields() throws SecurityException</td><td align="center">方法</td><td align="center">获取所有继承来的public成员</td></tr><tr><td align="center">public Field getField(String name) throws NoSuchFieldException, SecurityException</td><td align="center">方法</td><td align="center">获取一个指定类型的成员</td></tr><tr><td align="center">public Field[] getDeclaredFields() throws SecurityException</td><td align="center">方法</td><td align="center">获取本类定义的全部的成员</td></tr><tr><td align="center">public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException</td><td align="center">方法</td><td align="center">获取一个本类定义成员</td></tr></tbody></table><p>​    代码：获取属性信息，见反射实例-例四</p><p>​    在代码中获取了所需要的成员的信息，但是Field类的使用并不是获取成员信息的，这个类有如下几个重要的方法：</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public Class&lt; ? &gt; getType()</strong></td><td align="center">方法</td><td align="center">获取属性类型，可以与上上面代码中(invoke())结合动态获取参数类型</td></tr><tr><td align="center">public Object get(Object obj) throws IllegalArgumentException, IllegalAccessException</td><td align="center">方法</td><td align="center">获取对象属性</td></tr><tr><td align="center">public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException</td><td align="center">方法</td><td align="center">设置属性内容</td></tr><tr><td align="center"><strong>public void setAccessible(boolean flag)</strong></td><td align="center">方法</td><td align="center">取消封装(private)，即设置可见</td></tr></tbody></table><p>​    <strong>图示：field类的继承图示以及setAccessible(boolean flag)方法的作用区间</strong></p><p>​    <a href="https://imgtu.com/i/5DuKSI"><img src="https://z3.ax1x.com/2021/10/20/5DuKSI.png" alt="5DuKSI.png"></a></p><p>​    <strong>注意：setAccessible(boolean flag)方法是在AccessibleObject类中定义的方法，所以下面继承此类的方法都可以进行调用，从而解除封装</strong></p><p>​    范例：调用类中的属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Ball</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">First</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz <span class="token operator">=</span> <span class="token class-name">Ball</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Field</span> field <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解除封装</span>field<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"篮球"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等价于"对象.name = "篮球""</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等价于"System.out.println(对象.name)"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：类中所谓的封装只是局限于标准语法的访问的限制，但是如果直接利用反射就可以打破这种封装所带来的影响，只不过大多数情况不会这样操作</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构01</title>
      <link href="/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401/"/>
      <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h2><h4 id="1-数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。"><a href="#1-数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。" class="headerlink" title="1. 数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。"></a>1. 数据结构中的堆表示堆栈，数据结构中没有堆这个概念，堆分配内存的方式，不属于存储数据的结构。</h4><h4 id="2-数据结构的定义"><a href="#2-数据结构的定义" class="headerlink" title="2. 数据结构的定义"></a>2. 数据结构的定义</h4><p>​    <strong>以特定的数据类型(个体如何来存储)和特定的存储结构(个体之间的关系)保存到主存储器（内存）中</strong>（注意不是保存到硬盘），以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行的相应操作，这个相应的操作也叫算法</p><p>​    数据结构 = 个体 + 个体的关系，即解决存储问题<br>​    算法 = 对存储数据的操作（狭义，存储的方式不同则算法也不同），即解决数据操作的问题</p><h4 id="3-算法的定义"><a href="#3-算法的定义" class="headerlink" title="3. 算法的定义"></a>3. 算法的定义</h4><p>​    解题的方法和步骤</p><h4 id="4-衡量算法的标准"><a href="#4-衡量算法的标准" class="headerlink" title="4. 衡量算法的标准"></a>4. 衡量算法的标准</h4><p>​    (1).时间复杂度<br>​    大概程序要执行的次数，而非执行的时间</p><p>​    (2).空间复杂度<br>​    算法执行过程中大概所占用的最大内存</p><p>​    (3).难易程度</p><p>​    (4).健壮性</p><p>​    (5).正确性（废话）</p><h4 id="5-数据结构的地位"><a href="#5-数据结构的地位" class="headerlink" title="5. 数据结构的地位"></a>5. 数据结构的地位</h4><p>​    数据结构是软件最核心的课程</p><p>​    程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言</p><h4 id="6-指针变量"><a href="#6-指针变量" class="headerlink" title="6. 指针变量"></a>6. 指针变量</h4><p>​    指针是C语言的灵魂，指针就是地址(内存单元的编号)，地址就是指针，指针变量是存放内存单元地址的变量</p><p>​    若指针变量p指向整型变量i，那么*p就是i</p><p>​    指针变量都统一的只占四个字节</p><p>​    指针变量的声明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//p是个指针变量，int * 表示该p变量只能存储int类型变量的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-结构体"><a href="#7-结构体" class="headerlink" title="7. 结构体"></a>7. 结构体</h4><p>​    为了表示一些复杂的数据，而普通的基本类型变量无法满足要求，所以使用结构体来表示</p><p>​    结构体适合在以算法为核心程序即面向过程的语言，但在面向对象的语言算法就不是核心了</p><p>​    注意：对于C语言中结构体内字符串的赋值需要使用strcpy()来进行赋值，不能像Java一样，Java本身也是C和C++实现，而且java是用String类实现的</p><pre class="line-numbers language-none"><code class="language-none">strcpy(st.name,&quot;LiHua&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>在结构体中有定义一个结构体然后用成员操作符来使用结构体里的成员，但一般不会这样使用，更多的是定义一个结构体指针，然后通过该指针来访问</strong></p><p>​    一般都会使用结构体指针来调用里面的内容</p><pre class="line-numbers language-none"><code class="language-none">pst-&gt;sid等价于(*pst).sid &#x2F;&#x2F;pst为指针<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    注意：结构体变量不能加减乘除但可以相互赋值</p><p>​    结构体变量和结构体指针作为函数传参的问题<br>​    <strong>注意：一般还是用传指针好，如果单传结构体耗内存、耗时间不推荐(即指针占得内存小，一般一个结构体变量占用内存大)</strong></p><h4 id="8-malloc-动态分配内存"><a href="#8-malloc-动态分配内存" class="headerlink" title="8. malloc()动态分配内存"></a>8. malloc()动态分配内存</h4><p>​    通过动态分配内存以实现动态分配数组，这样实现数组是灵活的，<strong>动态数组不够时可以继续增加，多出时可以删除</strong></p><pre class="line-numbers language-none"><code class="language-none">int len;scanf(&quot;%d&quot;,len);int * pArr &#x3D; (int *)malloc(sizeof(int) * len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    注意1：malloc()函数只返回第一个字节的地址，强制转换目的是确定多少个为字节为一个元素</p><p>​    注意2：用完malloc()后要用free()释放它，不释放的话只能等程序终止了才能释放</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">free</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把pArr所分配的动态内存释放</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="9-跨函数内存分配问题"><a href="#9-跨函数内存分配问题" class="headerlink" title="9. 跨函数内存分配问题"></a>9. 跨函数内存分配问题</h4><p>​    如果是使用普通在栈内存的函数(静态)，在调用完之后就会释放掉，而如果是含有动态分配的函数，除非手动的去释放调用不然不会系统自动释放</p><p>​    范例：跨函数分配内存</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span> q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件实例</title>
      <link href="/2021/09/29/%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B/"/>
      <url>/2021/09/29/%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="文件操作实例"><a href="#文件操作实例" class="headerlink" title="文件操作实例"></a>文件操作实例</h2><h4 id="1-D-盘删盘程序"><a href="#1-D-盘删盘程序" class="headerlink" title="1. D:盘删盘程序"></a>1. D:盘删盘程序</h4><p>​    <strong>可以通过修改位置删除指定文件夹</strong></p><pre class="line-numbers language-none"><code class="language-none">package hello;import java.io.*;public class First&#123;public static void main(String[] args) &#123;File file &#x3D; new File(&quot;D:&quot;+File.separator);test(file);&#125; public static void test(File file) &#123;if(file.isDirectory()) &#123;File[] s &#x3D; file.listFiles();for(File a : s) &#123;test(a);&#125;&#125;file.delete();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>创建一堆文件</strong></p><pre class="line-numbers language-none"><code class="language-none">package hello;import java.io.*;import java.text.SimpleDateFormat;public class First&#123;public static void main(String[] args) throws Exception &#123;File fileOld &#x3D; new File(&quot;D:&quot;+File.separator+&quot;test-java&quot;);for(int x &#x3D; 0 ; x &lt; 100 ; x++) &#123;new File(fileOld,&quot;mldn-&quot; + getTime() + &quot;-&quot; + x + &quot;.log&quot;).createNewFile();&#125;&#125;public static String getTime() &#123;return new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new java.util.Date());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>对同类型的文件批量更改文件名（补零操作）</strong></p><pre class="line-numbers language-none"><code class="language-none">package hello;import java.io.*;import java.text.SimpleDateFormat;public class First&#123;public static void main(String[] args)&#123;File file &#x3D; new File(&quot;D:&quot;+File.separator+&quot;test-java&quot;);Count a &#x3D; new Count();a.to(file);a.rename(file);&#125;&#125;class Count&#123;private int max &#x3D; 0;private String filename &#x3D; null;private int length &#x3D; 0;public void to(File file) &#123;if(file.isDirectory()) &#123;&#x2F;&#x2F;判断是否为文件夹File a[] &#x3D; file.listFiles();&#x2F;&#x2F;获得所有子文件if(a !&#x3D; null) &#123;for(File childFile : a) &#123; to(childFile);&#125;&#125;&#125;else &#123;if(file.isFile()) &#123;if(file.getName().matches(&quot;mldn\\-\\d&#123;17&#125;\\-\\d+\\.log&quot;))&#123;&#x2F;&#x2F;需要修改路径的文件名称this.getMaxLength(file.getName());&#125;&#125;&#125;&#125;public void getMaxFileLength() &#123;this.length &#x3D; this.filename.substring(this.filename.lastIndexOf(&quot;-&quot;) + 1, this.filename.lastIndexOf(&quot;.&quot;)).length();&#125;public String getNewFileName(String oldName) &#123;StringBuffer buffer &#x3D; new StringBuffer(oldName);while(buffer.length() &lt; this.length) &#123;buffer.insert(0, 0);&#125;return buffer.toString();&#125;public void getMaxLength(String fileName) &#123;if(this.max &lt; fileName.length()) &#123;this.max &#x3D; fileName.length();this.filename &#x3D; fileName;&#125;&#125;public void rename(File file) &#123;if(file.isDirectory()) &#123;File a[] &#x3D; file.listFiles();if(a !&#x3D; null) &#123;for(File childFile : a) &#123;rename(childFile);&#125;&#125;&#125;else &#123;if(file.isFile()) &#123;if(file.getName().matches(&quot;mldn\\-\\d&#123;17&#125;\\-\\d+\\.log&quot;))&#123;&#x2F;&#x2F;需要修改路径的文件名称if(this.filename !&#x3D; null) &#123;this.getMaxFileLength();String oldFileName &#x3D; file.getName().substring(file.getName().lastIndexOf(&quot;-&quot;) + 1, file.getName().lastIndexOf(&quot;.&quot;));String newFileName &#x3D; file.getName().substring(0,file.getName().lastIndexOf(&quot;-&quot;) + 1) + this.getNewFileName(oldFileName) + file.getName().substring(file.getName().lastIndexOf(&quot;.&quot;));File newFile &#x3D; new File(file.getParentFile(),newFileName);file.renameTo(newFile);&#125;&#125;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>OutputStream类与其子类FileOutputStream的应用</strong><br>​    创建文件并且向文件中写入</p><pre class="line-numbers language-none"><code class="language-none">package hello;import java.io.*;public class First&#123;public static void main(String[] args) throws Exception&#123;File file &#x3D; new File(&quot;D:&quot;+File.separator+&quot;java-test&quot;+File.separator+&quot;test.txt&quot;);&#x2F;&#x2F;文件与其路径现在是不存在的，代码并没有进行手动创建，但文件还是直接生成了if(!file.getParentFile().exists()) &#123;&#x2F;&#x2F;创建父路径file.getParentFile().mkdirs();&#125;OutputStream output &#x3D; new FileOutputStream(file);output.write(&quot;hello&quot;.getBytes());output.close();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java12</title>
      <link href="/2021/09/19/Java12/"/>
      <url>/2021/09/19/Java12/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O（Input-amp-Output）"><a href="#I-O（Input-amp-Output）" class="headerlink" title="I/O（Input&amp;Output）"></a>I/O（Input&amp;Output）</h2><h3 id="1-Java中的输入-输出流"><a href="#1-Java中的输入-输出流" class="headerlink" title="1. Java中的输入/输出流"></a>1. Java中的输入/输出流</h3><p>​    Java语言定义了许多类负责各种方式的输入/输出，java的io是所有语言之最，这些类都放在java.io包中。<strong>核心组成：一个类(File)、一个接口(Serializable)、四个抽象类(InputStream，OutputStream，Reader，Writer)</strong></p><h3 id="2-File类的简介"><a href="#2-File类的简介" class="headerlink" title="2. File类的简介"></a>2. File类的简介</h3><h4 id="1-File类是整个java-io包中唯一一个与文件本身有关-可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容-的操作类"><a href="#1-File类是整个java-io包中唯一一个与文件本身有关-可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容-的操作类" class="headerlink" title="(1).File类是整个java.io包中唯一一个与文件本身有关(可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容)的操作类"></a>(1).File类是整个java.io包中唯一一个<strong>与文件本身有关</strong>(可以进行操作文档的路径指派，可以创建或者删除文件，以及还可以获取文件的相关信息内容)的操作类</h4><h4 id="2-File类的常用构造方法"><a href="#2-File类的常用构造方法" class="headerlink" title="(2).File类的常用构造方法"></a>(2).File类的常用构造方法</h4><p>​    </p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public File(String pathname)</td><td align="center">构造方法</td><td align="center">设置要操作文件的完整路径，要考虑分隔符</td></tr><tr><td align="center">public File(String parent, String child)</td><td align="center">构造方法</td><td align="center">设置要操作文件的父目录和子文件路径</td></tr><tr><td align="center">public boolean createNewFile() throws IOException</td><td align="center">方法</td><td align="center">创建一个新文件</td></tr><tr><td align="center">public boolean delete()</td><td align="center">方法</td><td align="center">删除此抽象路径名表示的文件或目录。如果此路径名表示目录，则该目录必须为空才能删除</td></tr><tr><td align="center">public boolean exists()</td><td align="center">方法</td><td align="center">判断文件是否存在</td></tr></tbody></table><p>​    <strong>注意：在使用File类指派操作文件的时候该文件的路径有可能不存在，只要不进行信息的获取操作不会有报错问题，只是表示一个要操作的文件路径</strong></p><p>​    <strong>程序的磁盘操作(解释为什么有延迟)</strong></p><p><a href="https://imgtu.com/i/hve0eI"><img src="https://z3.ax1x.com/2021/09/10/hve0eI.png" alt="hve0eI.png"></a></p><p>​    <strong>跨平台的分隔符问题</strong></p><ul><li>windows系统的路径分隔符为“\”；</li><li>Unix、类Unix（Linux、MacOS、ALX）路径分隔符为“/”；</li></ul><p>​    java考虑到这个问题所以是互通的，但写大量的<code>//</code>或<code>\\</code>转义处理非常麻烦，所以<strong>一般使用File类中提供的常量(public static final String separator)</strong>,早期命名规范与现在不同所以是小写separator</p><p>​    <strong>separator常量的使用</strong></p><pre class="line-numbers language-none"><code class="language-none">File file &#x3D; new File(&quot;D:&quot;+File.separator+&quot;Hello.txt&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>注意：以后编写代码所有路径分隔符尽量通过常量separator来进行定义</strong></p><h4 id="3-File类在父-多-目录下子文件的创建"><a href="#3-File类在父-多-目录下子文件的创建" class="headerlink" title="(3).File类在父(多)目录下子文件的创建"></a>(3).File类在父(多)目录下子文件的创建</h4><p>​    子文件在父目录下创建时必须保证父目录是存在的，不然会产生异常</p><p>​    <strong>对目录创建的File类中的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean mkdir()</td><td align="center">方法</td><td align="center">只创建单级目录</td></tr><tr><td align="center"><strong>public boolean mkdirs()</strong></td><td align="center"><strong>方法</strong></td><td align="center"><strong>创建多级目录(多个子目录可以同时创建)</strong></td></tr><tr><td align="center">public String getParent()</td><td align="center">方法</td><td align="center">获取父目录的信息</td></tr><tr><td align="center"><strong>public File getParentFile()</strong></td><td align="center"><strong>方法</strong></td><td align="center"><strong>获取父路径的File实例</strong></td></tr></tbody></table><p>​    <strong>在多线程下对文件的操作</strong><br>​    在Java项目中没有多线程，不是Java的风格。在多线程下对于文件是不是在父目录下每个线程都需要进行一个判断，此时程序的性能很低</p><p><a href="https://imgtu.com/i/hveNSe"><img src="https://z3.ax1x.com/2021/09/10/hveNSe.png" alt="hveNSe.png"></a></p><p>​    为了提高程序的性能最好的方法是让判断操作只执行一次，所以<strong>我们可以考虑使用静态代码块的模式来执行，静态代码块的执行优先于主方法执行</strong></p><h4 id="4-File类提供的其他操作"><a href="#4-File类提供的其他操作" class="headerlink" title="(4).File类提供的其他操作"></a>(4).File类提供的其他操作</h4><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean canExecute()</td><td align="center">方法</td><td align="center">程序是否能执行该文件</td></tr><tr><td align="center">public boolean canRead()</td><td align="center">方法</td><td align="center">是否能读</td></tr><tr><td align="center">public boolean canWrite()</td><td align="center">方法</td><td align="center">是否能写</td></tr><tr><td align="center">public File getAbsoluteFile()</td><td align="center">方法</td><td align="center">显示文件的绝对路径</td></tr><tr><td align="center">public boolean isDirectory()</td><td align="center">方法</td><td align="center">判断File对象是否是文件夹</td></tr><tr><td align="center">public boolean isFile()</td><td align="center">方法</td><td align="center">判断当前路径是否为文件</td></tr><tr><td align="center">public long lastModified()</td><td align="center">方法</td><td align="center">获取最后一次修改日期</td></tr><tr><td align="center">public long length()</td><td align="center">方法</td><td align="center">获取文件的长度(大小)</td></tr></tbody></table><p>​    <strong>File类之中的返回的日期long就是毫秒数、而文件大小返回的就是字节个数</strong></p><h4 id="5-File类获取文件目录信息"><a href="#5-File类获取文件目录信息" class="headerlink" title="(5).File类获取文件目录信息"></a>(5).File类获取文件目录信息</h4><p>​    将一个目录中所有的目录下所有子目录和文件详细的列出<br>​    </p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public String[] list()</td><td align="center">方法</td><td align="center">列出子路径的信息(不包括父目录)</td></tr><tr><td align="center"><strong>public File[] listFiles()</strong></td><td align="center"><strong>方法</strong></td><td align="center"><strong>列出子路径的完整信息(不包括父目录)</strong></td></tr><tr><td align="center">​    <strong>可以通过递归查询到目录下所有的文件，通过删除操作，可以实现恶意程序，见文件实例例一</strong></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="6-File类实现文件的更名处理"><a href="#6-File类实现文件的更名处理" class="headerlink" title="(6).File类实现文件的更名处理"></a>(6).File类实现文件的更名处理</h4><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public boolean renameTo(File dest)</td><td align="center">方法</td><td align="center">重命名由此抽象路径名表示的文件，即改变文件名</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">oldfile.renameTo(newFile); &#x2F;&#x2F;把旧文件名转化为新文件名，这两个都是绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    实例：文件的批量更名，见文件实例例二、例三</p><h3 id="3-流"><a href="#3-流" class="headerlink" title="3. 流"></a>3. 流</h3><h4 id="1-File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念"><a href="#1-File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念" class="headerlink" title="(1).File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念"></a>(1).File类本身实现了文件自身的处理操作，但是并未规定其文件内容的操作，而要想实现文件内容就必须使用流的概念</h4><h4 id="3-流的简介"><a href="#3-流的简介" class="headerlink" title="(3).流的简介"></a>(3).流的简介</h4><p>​    流指的是数据的处理方式，以及目标的内容的处理机制，所有的流都分为输入流或输出流，Java针对输入流和输出流分为了两种类型：</p><ul><li>字节操作流：OutputStream（字节输出流）、InputStream（字节输入流）</li><li>字符操作流：Write（字符输出流）、Reader（字符输入流）</li></ul><p>​    字节与字符最大的区别体现在对中文的处理上<br>​    注意：不管使用哪一种操作流，本质上的操作流程都是类似的</p><p>​    所谓输入流与输出流是相对的，而Java会提供一组标准的操作形式<br><a href="https://imgtu.com/i/hveKy9"><img src="https://z3.ax1x.com/2021/09/10/hveKy9.png" alt="hveKy9.png"></a></p><h4 id="4-以文件流为例来描述流的表现形式"><a href="#4-以文件流为例来描述流的表现形式" class="headerlink" title="(4).以文件流为例来描述流的表现形式"></a>(4).以文件流为例来描述流的表现形式</h4><ul><li>通过File类设定要操作的文件路径</li><li>通过字节流或字符流的子类为对象进行对象实例化处理 </li><li>进行读、写的流操作</li><li>流属于宝贵资源，操作完毕后一定要关闭（close()）</li></ul><h4 id="5-字节输出流-OutputStream"><a href="#5-字节输出流-OutputStream" class="headerlink" title="(5).字节输出流(OutputStream)"></a>(5).字节输出流(OutputStream)</h4><p>​    java.io.OutputStream是实现字节输出流的操作类，<strong>通过其子类对其实例化后使用</strong></p><table><thead><tr><th>OutputStream类的定义</th></tr></thead><tbody><tr><td>public <strong>abstract</strong> class OutputStream extends Object <strong>implements Closeable, Flushable</strong></td></tr></tbody></table><table><thead><tr><th>Closeable接口的定义和它提供的方法</th><th>Flushable接口的定义和它提供的方法</th></tr></thead><tbody><tr><td>public interface Closeable extends AutoCloseable {void close() throws IOException{}}</td><td>public interface Flushable{void flush() throws IOException{}}</td></tr><tr><td>该方法时强制关闭</td><td>该方法是强制清空缓存</td></tr></tbody></table><p>​    <strong>缓存的作用</strong><br><a href="https://imgtu.com/i/hvZBPU"><img src="https://z3.ax1x.com/2021/09/10/hvZBPU.png" alt="hvZBPU.png"></a></p><p>​    <strong>OutputStream类提供的三个输出方法（都很重要，加粗的用的多）</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public abstract void write(int b) throws IOException</td><td align="center">方法</td><td align="center">输出单个字节数据，<strong>byte和int是可以相互转换的</strong></td></tr><tr><td align="center">public void write(byte[] b) throws IOException</td><td align="center">方法</td><td align="center">输出全部字节数组的数据</td></tr><tr><td align="center"><strong>public void write(byte[] b, int off, int len) throws IOException</strong></td><td align="center"><strong>方法</strong></td><td align="center"><strong>输出部分字节数组的数据</strong></td></tr></tbody></table><p>​    <strong>FileOutputStream类（OutputStream类的子类）提供的构造方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public FileOutputStream(File file) throws FileNotFoundException</td><td align="center">构造方法</td><td align="center">设置文件输出流，每次都对原始内容进行覆盖</td></tr><tr><td align="center">public FileOutputStream(File file,boolean append) throws FileNotFoundException</td><td align="center">构造方法</td><td align="center">如果将append的内容设置为true，表示进行内容追加</td></tr></tbody></table><p>​    <strong>注意：在创建FileOutputStream需要进行异常处理</strong></p><h4 id="6-字节输入流-InputStream"><a href="#6-字节输入流-InputStream" class="headerlink" title="(6).字节输入流(InputStream)"></a>(6).字节输入流(InputStream)</h4><p>​    InputStream是一个提供字节输入流的实现类</p><table><thead><tr><th>InputStream类的定义</th></tr></thead><tbody><tr><td>public <strong>abstract</strong> class InputStream extends Object implements <strong>Closeable</strong></td></tr></tbody></table><p>​    注意：系统在进行读操作的时候是不会使用到系统的缓冲区的，是为了防止过多的写入才提供写入缓冲区，写入缓冲区才需要清空处理，所以InputStream类不实现Flushable父接口</p><p>​    InputStream类提供的输出方法（读取方法）</p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public abstract int read() throws IOException</td><td align="center">方法</td><td align="center">读取单个字节数据，如果没有数据返回-1</td></tr><tr><td align="center"><strong>public int read(byte[] b) throws IOException</strong></td><td align="center"><strong>方法</strong></td><td align="center"><strong>将内容读取到字节数组之中，返回读取个数，如果没有数据返回-1，不够长就有多长读多长</strong></td></tr><tr><td align="center">public int read(byte[] b,int off,                 int len) throws IOException</td><td align="center">方法</td><td align="center">读取部分内容到字节数组中，返回读取个数，没有数据返回-1</td></tr><tr><td align="center">public int available() throws IOException</td><td align="center">方法</td><td align="center">获取可用长度</td></tr></tbody></table><p>​    InputStream是一个抽象类，可以利用FileInputStream子类为其进行实例化</p><p>​    <strong>FileInputStream提供的构造方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public FileInputStream(File file) throws FileNotFoundException</td><td align="center">构造方法</td><td align="center">打开实际文件创建FileInputStream实例，如果命名文件不存在，或是目录而不是常规文件，则会引发FileNotFoundException</td></tr></tbody></table><h4 id="7-字符输出流-Writer"><a href="#7-字符输出流-Writer" class="headerlink" title="(7).字符输出流(Writer)"></a>(7).字符输出流(Writer)</h4><p>​    OutputStream是可以实现输出操作的，但是其在进行输出的时候全部都是字节数组的形式完成的，但在大部分情况下，最方便的处理类型一定是字符串，所以为了简化输出操作，提供了字符输出流</p><table><thead><tr><th>Writer类的定义</th></tr></thead><tbody><tr><td>public <strong>abstract</strong> class Writer <strong>extends</strong> Object <strong>implements</strong> Appendable, Closeable, Flushable</td></tr></tbody></table><p>​    Writer抽象类与之前的OutputStream类相比，多实现了一个Appendable接口，里面只有一个append方法，<strong>append方法用来追加内容</strong></p><pre class="line-numbers language-none"><code class="language-none">public interface Appendable&#123; &#x2F;&#x2F;Appendable接口定义的三种方法public Appendable append(CharSequence csq) throws IOException;public Appendable append(CharSequence csq,int start,int end) throws IOException;public Appendable append(char c) throws IOException;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在使用Writer类进行输出的时候最大的操作特点在于其可以直接进行字符串的数据处理</p><table><thead><tr><th>Writer类的输出方法</th></tr></thead><tbody><tr><td>public void write(String str) throws IOException  //它可以直接输出字符串</td></tr></tbody></table><p>​    Writer类在后续的版本中逐步有了CharSequence接口的支持，只要可以接收此接口的实例，就意味可以追加String、StringBuffer、StringBuilder类的实例</p><p>​    <strong>与之前一样可以将Writer类实例化为FileWriter</strong></p><p>​    使用Writer可以实现与OutputStream类似的功能，但其最大的优势在于可以直接进行字符串数据的输出处理</p><h4 id="8-字符输入流-Reader"><a href="#8-字符输入流-Reader" class="headerlink" title="(8).字符输入流(Reader)"></a>(8).字符输入流(Reader)</h4><p>​    Reader是实现字符数据的输入流类</p><table><thead><tr><th>Reader类的定义</th></tr></thead><tbody><tr><td>public <strong>abstract</strong> class Reader <strong>extends</strong> Object <strong>implements</strong> Readable, Closeable</td></tr></tbody></table><p>​    Readable这个接口与NIO有关，不是IO</p><table><thead><tr><th>Reader类的输入方法</th><th>说明</th></tr></thead><tbody><tr><td>public int read() throws IOException</td><td>读取单个字符</td></tr><tr><td>public int read(char[] cbuf) throws IOException</td><td>将字符读入数组</td></tr><tr><td>public abstract int read(char[] cbuf, int off, int len) throws IOException</td><td>将一部分字符读入数组</td></tr></tbody></table><p>​    <strong>Reader的子类有FileReader</strong></p><h4 id="9-AutoCloseable类"><a href="#9-AutoCloseable类" class="headerlink" title="(9).AutoCloseable类"></a>(9).AutoCloseable类</h4><p>​    上面介绍的四个类实际上都属于AutoCloseable子类，所以对于打开和关闭的操作可以使用自动关闭的形式来处理</p><h4 id="10-字节流和字符流的区别"><a href="#10-字节流和字符流的区别" class="headerlink" title="(10).字节流和字符流的区别"></a>(10).字节流和字符流的区别</h4><p>​    字节操作属于基础的二进制数据流的操作形式，在网络、文件、图片、音乐等操作之中几乎都是以字节数据为主的，但是字节数据不方便进行中文的处理，所以对于中文的处理应该使用字符流。</p><p>​    在进行网络传输或者磁盘数据存储的时候，所有存放的内容都属于字节数据</p><p><a href="https://imgtu.com/i/4Eka5Q"><img src="https://z3.ax1x.com/2021/09/14/4Eka5Q.png" alt="4Eka5Q.png"></a><br>​    <strong>缓冲区：实现字符与字节的转换</strong></p><p>​    实际上如果想要观察出字符流的缓冲区的存在，只需要在输出的时候取消close()方法的调用即可，因为此方法一旦调用实际上会自动清空缓冲区的内容，随后才会将数据写入到目标终端设备之中，如果此时由于某些原因就是无法进行字符输出流的关闭，则可以使用由Flushable接口继承而来的flush()方法进行手工的强制清除。</p><p>​    <strong>本质上传递的所有内容只有字节，而字符是程序对字节的包装，通过代码可以发现字节流和字符流的使用非常相似，一般以字节流方式为主，只有进行中文操作时才会考虑字符流处理</strong></p><h4 id="11-字节流和字符流的转换（转换流）"><a href="#11-字节流和字符流的转换（转换流）" class="headerlink" title="(11).字节流和字符流的转换（转换流）"></a>(11).字节流和字符流的转换（转换流）</h4><p>​    为了方便实现字节流和字符流的转换处理，提供了两个类：<strong>OutputStreamWriter</strong>和<strong>InputStreamReader</strong></p><ol><li><p>OutputStreamWriter</p><p>在构造方法中，需要接收一个OutputStream的对象，而后再向上转型变为字符流</p><p><a href="https://imgtu.com/i/4VFHJJ"><img src="https://z3.ax1x.com/2021/09/15/4VFHJJ.png" alt="4VFHJJ.png"></a></p></li><li><p>InputStreamReader</p><p><a href="https://imgtu.com/i/4Ve0Ln"><img src="https://z3.ax1x.com/2021/09/15/4Ve0Ln.png" alt="4Ve0Ln.png"></a></p><p>通过继承的关系，<strong>InputStreamReader、OutputStreamWriter都是字符流的子类</strong>，同时又可以通过构造方法接收InputStream类和OutputStream类的实例，<strong>再向上转型为字符流</strong></p><p>转换流在一些系统类库的操作之中比较常见，有些情况系统只会给用户字节流，但是为了方便处理需要进行字符流转换，这个时候才会使用到这个流</p><p>注意：这种转换在类的定义时也有体现，如：OutputStreamWriter是FileWriter的父类，InputStreamReader是FileReader的父类，<strong>即转换流是字符输入输出流的父类</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统01</title>
      <link href="/2021/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01/"/>
      <url>/2021/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01/</url>
      
        <content type="html"><![CDATA[<h2 id="初识操作系统"><a href="#初识操作系统" class="headerlink" title="初识操作系统"></a>初识操作系统</h2><h4 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1. 什么是操作系统"></a>1. 什么是操作系统</h4><p>​    操作系统是计算机硬件和应用之间的一层软件，方便使用硬件、高效的使用硬件，操作系统可以看作是资源分配器</p><h4 id="2-操作系统管理的软件"><a href="#2-操作系统管理的软件" class="headerlink" title="2. 操作系统管理的软件"></a>2. 操作系统管理的软件</h4><p>​    <strong>CPU管理、内存管理、终端管理、磁盘管理、文件管理</strong>、网络管理、电源管理、多核管理</p><h4 id="3-操作系统的表层"><a href="#3-操作系统的表层" class="headerlink" title="3. 操作系统的表层"></a>3. 操作系统的表层</h4><p>​    表层是通过应用使用操作系统的接口<br>​    操作系统中的接口就是一个让用户操作电脑的一个界面，比如windows，它有三个接口：</p><ol><li>cmd：windows上按win+r打开运行，输入cmd就会打开命令提示符，这个是系统管理员接口。</li><li>explorer.exe:你打开任务管理器会看到explorer.exe，这个就是windows的桌面接口。</li><li>api接口，这个是面向程序员的接口</li></ol><h4 id="4-计算机的工作原理"><a href="#4-计算机的工作原理" class="headerlink" title="4. 计算机的工作原理"></a>4. 计算机的工作原理</h4><p>​    通过IP(指针)把程序载入到内存(存储器)中，再载入到CPU(运算器、控制器)中解释执行，再输出</p><p>​    <strong>计算机工作的本质：取指执行</strong></p><h4 id="5-计算机的开机-x86-PC"><a href="#5-计算机的开机-x86-PC" class="headerlink" title="5. 计算机的开机(x86 PC)"></a>5. 计算机的开机(x86 PC)</h4><ol><li>x86 PC刚开机时CPU处于实模式（实模式的寻址CS:IP(CS左移4位+IP)）</li><li>开机时，CS=0xFFFF；IP=0x0000</li><li>寻址0xFFFF0（ROM BLOS(基本输入输出)映射区(此处此时为固化的)）</li><li>检查RAM(内存)，键盘，显示器，软硬键盘（执行过不去就是硬件坏了）</li><li>将磁盘0磁道0扇区(操作系统的引导扇区)读入0x7c00处（一个扇区为512字节）</li><li>设置CS=0x07c0，IP=0x0000（BLOS跳到这个自己写的引导扇区执行，引导扇区为启动设备的第一个扇区）</li></ol><p>​    <strong>这512个字节为开机时发生的事情</strong></p><h4 id="6-操作系统的启动"><a href="#6-操作系统的启动" class="headerlink" title="6. 操作系统的启动"></a>6. 操作系统的启动</h4><p>​    将磁盘中的操作系统读到内存中，即程序boot sect.s<br>​    setup.s将完成OS启动前的设置（让系统获取到硬件配置）</p><h4 id="7-setup-s"><a href="#7-setup-s" class="headerlink" title="7. setup.s"></a>7. setup.s</h4><p>​    获取设备硬件信息，而后将整个操作系统移动到0地址，而后执行操作系统，操作系统也一直会在0地址，再之后初始化gdt表并进入到保护模式（由之前的16位寻址模式(CS&lt;&lt;4+ip)切换到32位寻址模式），再跳到0地址（head.s）</p><h4 id="8-保护模式下地址的翻译（gdt的作用）"><a href="#8-保护模式下地址的翻译（gdt的作用）" class="headerlink" title="8. 保护模式下地址的翻译（gdt的作用）"></a>8. 保护模式下地址的翻译（gdt的作用）</h4><p>​    CS改叫选择子，不在左移4位获得地址而是通过其查表+ip获得地址（这个表就叫gdt表）</p><h4 id="9-head-s"><a href="#9-head-s" class="headerlink" title="9. head.s"></a>9. head.s</h4><p>​    初始化gdt表，执行完head.s之后，再去执行main.c由汇编转为C语言，由于C语言本质会转成汇编语言，所以可以看成是由一个c函数跳转到另一个c函数，这个过程通过栈完成，此时main死循环，main返回时，电脑死机</p><h4 id="10-main-c"><a href="#10-main-c" class="headerlink" title="10. main.c"></a>10. main.c</h4><p>​    初始化一些硬件<br>​    mem_init()：把内存信息列表，即mem_init表，哪些占用，哪些没有</p><h4 id="11-内核"><a href="#11-内核" class="headerlink" title="11. 内核"></a>11. 内核</h4><p>​    操作系统一直运行在计算机上的程序<br>​    除了内核以外还有两类程序：系统程序、应用程序</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java11</title>
      <link href="/2021/08/16/Java11/"/>
      <url>/2021/08/16/Java11/</url>
      
        <content type="html"><![CDATA[<h2 id="对象数组-集合类"><a href="#对象数组-集合类" class="headerlink" title="对象数组(集合类)"></a>对象数组(集合类)</h2><h4 id="1-在java-util包中提供一些集合类，集合类又被称为容器-对象数组"><a href="#1-在java-util包中提供一些集合类，集合类又被称为容器-对象数组" class="headerlink" title="1. 在java.util包中提供一些集合类，集合类又被称为容器/对象数组"></a>1. 在java.util包中提供一些集合类，集合类又被称为容器/对象数组</h4><h4 id="2-集合类和数组的区别"><a href="#2-集合类和数组的区别" class="headerlink" title="2. 集合类和数组的区别"></a>2. 集合类和数组的区别</h4><ul><li>数组的长度是固定的，集合类的长度是可变的</li><li>数组用来存放基本数据类型的数据，集合类用来存放对象**(基本数据类型需要用包装类)**的引用</li></ul><h4 id="3-对象数组的优势"><a href="#3-对象数组的优势" class="headerlink" title="3. 对象数组的优势"></a>3. 对象数组的优势</h4><ul><li>对象数组属于Java语言的原生支持，不需要手工实现(简单)</li><li>对象数组根据索引的数据查询性能是“O(1)”。但若根据的是内容查询，在未经优化的情况下其性能是“O(n)”，优化为使用二分法可以使其时间复杂度为“log<del>2</del>n”</li></ul><h4 id="4-Collection-lt-E-gt-接口"><a href="#4-Collection-lt-E-gt-接口" class="headerlink" title="4. Collection&lt; E &gt;接口"></a>4. Collection&lt; E &gt;接口</h4><p>​    在Java中，Collection接口是层次结构的根接口（即集合的顶层框架）<br>​    Collection接口通常不能直接使用，但其提供增加、删除、管理数据的方法。List接口与Set接口继承了该接口，这些方法在这两个接口中是通用的</p><table><thead><tr><th align="center">方法</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">add(E e)</td><td align="center">将指定的对象(元素e)添加到该集合中</td></tr><tr><td align="center">remove(Object o)</td><td align="center">将指定的对象从该集合中删除</td></tr><tr><td align="center">isEmpty()</td><td align="center">返回值为boolean，判断当前集合是否为空</td></tr><tr><td align="center">iterator()</td><td align="center">返回在此Collection的元素的迭代器，用于遍历集合中的对象</td></tr><tr><td align="center">size()</td><td align="center">返回值为int，获取该集合中元素的个数</td></tr></tbody></table><h4 id="4-迭代器（Iterator-lt-E-gt-接口，E为元素迭代器返回元素类型）"><a href="#4-迭代器（Iterator-lt-E-gt-接口，E为元素迭代器返回元素类型）" class="headerlink" title="4. 迭代器（Iterator&lt; E &gt;接口，E为元素迭代器返回元素类型）"></a>4. 迭代器（Iterator&lt; E &gt;接口，E为元素迭代器返回元素类型）</h4><p>​    在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果，<strong>即：迭代器的作用是用来遍历集合元素</strong>，我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象,使用迭代器就可以遍历这个对象的内部</p><p>​    <strong>注意：一般使用增强for也可以遍历元素，但如果是无序的则需要用迭代器了</strong></p><p>​    迭代器的创建</p><pre class="line-numbers language-none"><code class="language-none">Iterator&lt;String&gt; a &#x3D; list.iterator();  &#x2F;&#x2F;在集合list下创建它的迭代器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    迭代器的方法</p><ul><li><p>hasNext()方法：如果迭代器有下一个元素返回true，否则返回false，这个方法并不移动指针</p></li><li><p>next()方法：向下移动指针，并且返回指针指向的元素，如果指针指向的内存中没有元素，会报异常，而且指针目前无法反向指，所以只可以一直向下。<strong>注意：返回元素的类型是Object类型</strong></p></li><li><p>remove()方法：移除iterator.next()方法最后访问的元素</p><p><strong>注意：在同一个迭代(循环)中只能使用一次next()方法，不然会产生异常（java.util.NoSuchElementException)</strong></p></li></ul><h4 id="5-List集合"><a href="#5-List集合" class="headerlink" title="5. List集合"></a>5. List集合</h4><p>​    (1).List集合包括List接口和List接口中所有实现类。List集合中元素允许重复，顺序为插入对象时的顺序，类似Java数组，用户可以通过索引来访问集合中的元素</p><p>​    (2).List接口继承Collection接口，包含其所有方法，还定义了两个重要方法</p><ul><li>get(int index)：获得指定索引位置的元素</li><li>set(int index , Object obj)：将元素中指定位置的对象修改</li></ul><p>​    (3).List接口的实现类</p><ul><li>ArrayList类<br>​    ArrayList类实现了可变的数组，允许保存所有元素，包括null，可以根据索引位置快速访问，缺点为插入和删除对象元素速度较慢，<strong>其操作是移动数组</strong><br>​    <strong>ArrayList是使用动态数组实现的</strong></li></ul><ul><li>LinkedList类<br>​    采用链表结构保存对象，优点便于向集合中插入和删除对象，缺点对于随机访问时效率低，<strong>其操作是定位节点</strong><br>​    <strong>LinkedList是使用双向链表实现的</strong></li></ul><p>​    (4).List集合的声明<br>​    <strong>通常声明为List类型，然后通过不同的实现类来进行实例化</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;E为Java中合法的数据类型List&lt;E&gt; list &#x3D; new ArrayList&lt;&gt;(); List&lt;E&gt; list2 &#x3D; new LinkedList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意1：代码中小括号内是可以设置容量的，如果不写的话JDK 1.8 默认是10且建议初始化容量减少系统初始化容量的耗时</strong><br><strong>注意2：该构造方法并不是将ArrayList()初始化为指定长度，而是指定了其内部的Object数组的长度，也就是其容量。当我们调用size()时，返回的是其实际长度，而非容量大小。对超出ArrayList长度的部分进行访问或赋值操作时也会造成访问越界，尽管它的容量大小足够</strong></p><p>​    <strong>注意：集合的索引与数组一样从0开始，而且使用remove方法删除数据时需要注意是否越界，即使用该方法时同时使用try-catch来捕捉异常</strong></p><h4 id="5-Set集合"><a href="#5-Set集合" class="headerlink" title="5. Set集合"></a>5. Set集合</h4><p>​    (1).Set集合的对象不按特定的方式排序，只是简单的把对象加入集合中<br>​    <strong>Set的构造有一个约束条件，传入的Collection对象不能有重复值，加入Set的元素必须定义equals()方法以确保对象的唯一性(在上面List中是可以重复的) ，小心操作可变可变对象导致出现问题</strong> </p><p>​    (2). Set接口继承Collection接口，包含Collection中所有的方法</p><p>​    (3). Set集合的常用的实现类</p><ul><li>HashSet类<br>​    HashSet类实现Set接口，由哈希表支持，不保证Set的迭代顺序，不保证顺序永恒不变，此类允许使用null元素</li><li>TreeSet类<br>​    TreeSet类在实现Set集合时，必须实现Comparable接口，实现接口中的方法compareTo(Object o)方法比较此对象与指定对象的顺序<br>​    TreeSet类不仅实现Set接口，还实现java.util.SortedSet接口，TreeSet类实现的Set集合在遍历集合时按照自然顺序递增排序，也可以按照指定的比较器递增排序，<strong>即TreeSet通过 Comparator&lt;-(这是一个无参方法) 或者 Comparable &lt;-(这是一个接口)维护了一个排序顺序</strong><br>​    <strong>一般使用TreeSet类来实现自定义排序</strong></li></ul><h4 id="6-Map集合"><a href="#6-Map集合" class="headerlink" title="6. Map集合"></a>6. Map集合</h4><p>​    (1).Map集合没有继承Collection接口，其提供key到value的映射，Map中不能有相同的key，每个key只可以映射一个value，使用的是Map接口</p><p>Map接口的常用方法</p><table><thead><tr><th align="center">方法</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">put(K key,V value)</td><td align="center">向集合中添加指定的key与value的映射关系</td></tr><tr><td align="center">containsKey(Object key)</td><td align="center">如果此映射包含指定key的映射关系，则返回true</td></tr><tr><td align="center">containsValue(Object value)</td><td align="center">如果此映射将一个或多个key映射到指定值，则返回true</td></tr><tr><td align="center">get(Object key)</td><td align="center">如果存在指定的key对象，则返回该对象对应的值，否则返回null</td></tr><tr><td align="center">keySet()</td><td align="center">返回该集合中的所有key对象形成的Set集合</td></tr><tr><td align="center">values()</td><td align="center">返回该集合中所有值对象形成的Collection集合</td></tr></tbody></table><p><a href="https://imgtu.com/i/f2JSeS"><img src="https://z3.ax1x.com/2021/08/15/f2JSeS.png" alt="f2JSeS.png"></a></p><p>​    (2).<strong>注意：Map是双列的,Collection是单列的</strong><br>​    Map集合的实例化</p><pre class="line-numbers language-none"><code class="language-none">Map&lt;*,*&gt; map &#x3D; new HashMap&lt;&gt;() &#x2F;&#x2F;*为你要的数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>(3).Map和Set和List的关系</strong></p><ul><li>Map中存放的时键值对，Set中存放的是单个对象，但如果把value看做key的附庸，key在哪里，value就在哪里，这样就可以像对待Set一样来对待Map了。事实上，Map提供了一个Entry内部类来封装key-value对，再计算Entry存储时则只考虑Entry封装的key。</li><li>如果把Map集合里的所有value放在一起来看，它们又类似于一个List，元素可以重复，每个元素可以根据索引来找，只是Map中的索引不再是整数值，而是以另一个对象作为索引</li></ul><p>​    (4).Map集合的内部类Entry<br>​    Map中包括一个内部类Entry,该类封装一个键值对，常用方法：</p><ul><li>Object getKey():返回该Entry里包含的所有key值；</li><li>Object getvalue():返回该Entry里包含的所有value值；</li><li>Object setValue(V value):设置该Entry里包含的value值，并设置新的value值。</li></ul><p>​    (5).Map接口的实现类<br>​    Map接口的常用实现类有HashMap和TreeMap。建议使用HashMap类实现Map集合，HashMap类实现的Map集合添加和删除元素效率更高</p><ul><li><p>HashMap类<br>​    基于哈希表的Map接口的实现，此实现提供所有可选的映射操作，并允许使用null值和null键，但必须保证键的唯一性，此类不保证映射的顺序，特别是它不保证该顺序永恒不变</p></li><li><p>TreeMap类<br>​    TreeMap类不仅实现了Map接口，而且实现了java.util.SortedMap接口，集合中的映射关系具有一定的顺序，在添加、删除、定位映射关系时，比HashMap性能稍差，且TreeMap不允许键对象为null</p></li></ul><p>​    <strong>注意：可以通过HashMap类创建Map集合，当需要顺序输出时，再创建一个完成相同映射关系的TreeMap类实例</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java10</title>
      <link href="/2021/06/20/Java10/"/>
      <url>/2021/06/20/Java10/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h4 id="1-异常的概述"><a href="#1-异常的概述" class="headerlink" title="1. 异常的概述"></a>1. 异常的概述</h4><ul><li>异常是一个在程序执行期间发生的事件，它中断了正在执行的程序的正常指令流</li><li>异常产生后，如果不做任何处理，程序会被终止</li><li>异常在Java中也是作为类的实例的形式出现，在某一方法错误时，这个方法会创建一个异常对象，并把他传递给正在运行的系统，通过异常处理机制，可以将非正常情况下的处理代码与程序的主逻辑分离，即在编写代码主流程的同时在其他地方处理异常</li></ul><h4 id="2-jvm默认处理异常的方式"><a href="#2-jvm默认处理异常的方式" class="headerlink" title="2. jvm默认处理异常的方式"></a>2. jvm默认处理异常的方式</h4><ol><li>当某个方法出现异常情况时，会将异常封装成一个异常对象。</li><li>异常对象抛出给调用者，一层一层往上抛，最终到达main方法，主方法也没有办法处理，就抛出给jvm虚拟机</li><li>jvm虚拟机有没有得到指令处理异常，只能将异常的信息通过标准错误流（System.err）打印到控制台，结束自己。</li></ol><h4 id="3-异常的结构"><a href="#3-异常的结构" class="headerlink" title="3. 异常的结构"></a>3. 异常的结构</h4><p>​     <strong>在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出类）</strong><br>​     <strong>在java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch）</strong><br>​    <strong>Throwable</strong>： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。异常和错误的区别是：异常能被程序本身可以处理，错误是无法处理（但错误也是异常）<br><a href="https://imgtu.com/i/2qtZ5Q"><img src="https://z3.ax1x.com/2021/06/15/2qtZ5Q.png" alt="2qtZ5Q.png"></a></p><p>​    </p><p>**Error（错误）:**一般来说，最常见的错误有程序进入死循环、内存泄漏等。在这种情况下，程序运行时本身无法解决，只能通过其他程序干预，Error类对象由java虚拟机生成并抛弃（通常Java程序不对这类异常进行处理）</p><p>​    <strong>Exception（异常）</strong>：分两大类，运行时异常(不检查异常)和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p><ul><li><strong>运行时异常</strong>：都是<strong>RuntimeException类及其子类</strong>异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，<strong>这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理</strong>。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是<strong>Java编译器不会检查它</strong>，也就是说，当程序中可能出现这类异常，<strong>即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过</strong>。</li><li><strong>非运行时异常 （编译异常）</strong>：是<strong>RuntimeException以外的异常，类型上都属于Exception类及其子类</strong>。从程序语法角度讲是<strong>必须进行处理的异常，如果不处理，程序就不能编译通过</strong>。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</li></ul><h4 id="4-异常的处理"><a href="#4-异常的处理" class="headerlink" title="4. 异常的处理"></a>4. 异常的处理</h4><p>​    在Java中如果某个方法抛出异常，可以在当前方法中进行捕捉并处理，也可以将异常向上抛出</p><h4 id="5-异常的捕捉"><a href="#5-异常的捕捉" class="headerlink" title="5. 异常的捕捉"></a>5. 异常的捕捉</h4><p>​    Java语言通过try、catch、finally来处理异常</p><ul><li>try语句块用来存放可能发生异常的Java语句</li><li>catch程序块在try语句块之后，当try语句块里抛出异常时执行</li><li>finally语句块里的内容无论try语句是否跳出，正常都会执行</li></ul><p>​    <strong>注意：如果程序跳到了catch块后会继续向下执行，不会再去执行try代码块的内容</strong></p><pre class="line-numbers language-none"><code class="language-none">try &#123; &#x2F;&#x2F;可能出现异常的代码&#125; catch (Exception e) &#123;&#x2F;&#x2F;可能出现的异常类型 异常的变量名称,e是引用了抛出的实例&#x2F;&#x2F;针对该异常类型的处理办法&#125;finally&#123;&#x2F;&#x2F;语句块&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    获取异常的信息的函数(需要在异常引用变量名称后调用，这是可抛出类(异常最上层父类)的方法)</p><ul><li>getMessage()函数：输出错误性质</li><li>toString()函数：给出异常的类型与性质</li><li>printStackTrace()函数：指出异常的类型、性质、栈层次及出现在程序中的位置</li></ul><h4 id="6-在方法中抛出异常"><a href="#6-在方法中抛出异常" class="headerlink" title="6. 在方法中抛出异常"></a>6. 在方法中抛出异常</h4><p>​    <strong>(1).使用throws关键字抛出异常</strong><br>​    <strong>throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。</strong>多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会将异常抛给指定异常对象<br>​    <strong>throws关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理</strong><br>​    <strong>注意：throws不会抛出异常对象只是起通知作用，但是catch块的引用方法按这个通知的来分配异常对象的引用类型，即throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常及其父类</strong></p><pre class="line-numbers language-none"><code class="language-none">修饰符 方法名() throws 异常名&#123; &#x2F;&#x2F;异常名必须是JavaException的子类，不可以自己取&#x2F;&#x2F;方法内容&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：写了throws后，调用这个方法的调用方必须要对可能发生异常进行处理(不管程序是否发生异常)，不写throws的话，就正常使用方法，其出错的话编译器报错，但用了接收的try-catch可以处理。</strong><br>​    <strong>而且抛给调用方后，调用方使用try-catch来处理，如果不想处理可以继续向上抛，但最终还是要有能够处理该异常的代码</strong></p><p>​    <strong>(2).使用throw关键字抛出异常</strong><br>​    throw关键字通常用于方法体中，通过throw<strong>抛出一个异常对象</strong>，程序在执行到throw语句时立即终止,必须对该抛出的异常进行处理，要么捕获要么上抛，如果需要该方法上一级代码来捕获处理异常，则需要在方法的声明中使用throws关键字并指明要抛出的异常（是该异常的引用，如果用父类可能会造成问题），捕捉throw抛出的异常用try-catch语句块</p><h4 id="7-自定义的异常"><a href="#7-自定义的异常" class="headerlink" title="7. 自定义的异常"></a>7. 自定义的异常</h4><p>​    在Java中用户通过继承Exception类来自定义异常类<br>​    通常使用throw来抛出自定义异常<br>​    父类Exception的主要构造方法，详细见API文档</p><pre class="line-numbers language-none"><code class="language-none">Exception()Constructs a new exception with null as its detail message.Exception(String message)Constructs a new exception with the specified detail message.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    使用自定义异常的步骤<br>​    (1). 创建自定义异常类<br>​    (2). 在方法中通过throw关键字抛出异常对象<br>​    (3). 对抛出异常进行处理</p><h4 id="7-异常的使用原则"><a href="#7-异常的使用原则" class="headerlink" title="7. 异常的使用原则"></a>7. 异常的使用原则</h4><p>​    异常的处理不应用来控制程序的正常流程，其主要作用是捕获程序在运行时发生的异常并进行相应的处理</p><h4 id="8-异常的注意事项"><a href="#8-异常的注意事项" class="headerlink" title="8. 异常的注意事项"></a>8. 异常的注意事项</h4><ul><li>一个方法被覆盖时，覆盖它的方法必须抛出相同的异常或异常子类</li><li>如果父类抛出多个异常，则覆盖方法必须抛出那些异常的一个子集，不能抛出新异常</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java09</title>
      <link href="/2021/06/15/Java09/"/>
      <url>/2021/06/15/Java09/</url>
      
        <content type="html"><![CDATA[<h2 id="类的高级特性"><a href="#类的高级特性" class="headerlink" title="类的高级特性"></a>类的高级特性</h2><h4 id="1-类名冲突与完整路径"><a href="#1-类名冲突与完整路径" class="headerlink" title="1. 类名冲突与完整路径"></a>1. 类名冲突与完整路径</h4><p>​    在Java中，同名的两个类需要放在不同的类包(包)中<br>​    完整的类名为包名和类名的组合<br>​    像指定类时是可以写完整类名的但是由于麻烦和可读性就会使用import关键字来引入</p><h4 id="2-同一个包中的类相互访问时，可以不指定包名"><a href="#2-同一个包中的类相互访问时，可以不指定包名" class="headerlink" title="2. 同一个包中的类相互访问时，可以不指定包名"></a>2. 同一个包中的类相互访问时，可以不指定包名</h4><h4 id="3-CLASSPATH"><a href="#3-CLASSPATH" class="headerlink" title="3. CLASSPATH"></a>3. CLASSPATH</h4><p>​    直译的话就是类的路径，配置了classpath后java程序会直接去classpath的路径下去找.class文件运行。这样我们就可以在任意目录下来运行我们的java程序，在连接数据库时我配置了这个的环境变量</p><h4 id="4-package关键字"><a href="#4-package关键字" class="headerlink" title="4. package关键字"></a>4. package关键字</h4><p>​    用来定义包</p><pre class="line-numbers language-none"><code class="language-none">package 包名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    需要将package表达式放置在第一行，它必须是程序第一行非注释代码<br>​    Java包的命名规则：全部使用小写字母</p><h4 id="5-import关键字"><a href="#5-import关键字" class="headerlink" title="5. import关键字"></a>5. import关键字</h4><p>​    (1).用来导入包</p><pre class="line-numbers language-none"><code class="language-none">import 包名.类名  &#x2F;&#x2F;如果类不在包中则只要类名即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    如果需要使用包中的多个类，类名用 * 代替， * 表所有的类<br>​    <strong>注意：<br>​    如果已经用import引入了一个类，如果还要引用一个和这个类同名的类，则必须使用完整路径</strong></p><p>​    (2).用来导入静态成员</p><pre class="line-numbers language-none"><code class="language-none">import static 静态成员 &#x2F;&#x2F;静态成员应为完整路径，可以为静态变量，也可以是静态方法<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    导入完之后就可以直接使用了，不需要再写完整的路径</p><h4 id="6-final关键字"><a href="#6-final关键字" class="headerlink" title="6. final关键字"></a>6. final关键字</h4><p>​    <strong>(1).final变量</strong><br>​    使用final声明的变量，一旦被设定就不可以再改变它的值，<strong>通常使用这个方式来定义常量，final常量定义时需要使用大写字母命名</strong><br>​    注意：final变量定义的时候，可以先声明，而不给初值，这种变量也称为final空白</p><p>​    final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量</p><p>​    <strong>(2).final对象</strong><br>​    使用final修饰对象，一旦一个对象的引用被修饰，则它只能恒定指向一个对象，不能改变指向，未被指定时可以随便指<br>​    <strong>注意：数组也可以看作是一个对象来使用这个关键字</strong></p><p>​    <strong>(3).final方法</strong><br>​    定义为final的方法不能被重写，可以被继承<br>​    定义为final的方法的执行效率高于非final的方法<br>​    定义为private不能被子类方法覆盖，private类型的方法默认是final类型的（这句先不说覆不覆盖就private感觉外部就调用不了了）</p><p>​    <strong>(4).final类</strong><br>​    定义为final类不能被继承，没有子类</p><pre class="line-numbers language-none"><code class="language-none">final 类名&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>如果一个类设置为final，则类中所有的方法都被隐式设置为final形式，但final类中的成员变量可以被定义为final或者非final形式</strong></p><p>​    <strong>(5).static和final一起使用</strong><br>​    static final用来修饰成员变量和成员方法，可以看作为全局常量</p><ul><li>对于变量，表示一旦给值就不可修改，并且通过类名可以访问</li><li>对于方法，表示不可覆盖，并且可以通过类名直接访问</li></ul><p>​    <strong>注意：对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象</strong></p><h4 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7. 内部类"></a>7. 内部类</h4><p>​    如果在一个类中再定义一个类，则将这个再定义的类称为内部类，<strong>内部类分为成员内部类、局部内部类、匿名类</strong></p><p>​    <strong>(1).成员内部类</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Outside&#123; &#x2F;&#x2F;外部类private class Inside&#123; &#x2F;&#x2F;内部类,是一个私有成员&#x2F;&#x2F;something&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>在内部类中可以随意使用外部类的成员方法和成员变量，尽管被修饰为了private</strong><br>​    就像main方法放在类中可以访问该类的私有成员一样<br>​    <strong>但外部类不能直接访问内部类成员，需要先将内部类在外部类中实例化后再使用，内部类为private在外部类实例化后一样也可以使用</strong><br>​    <strong>内部类修饰为private只能外部类访问，其他类没有权限访问（哪怕是继承了外部类的子类）</strong></p><p>​    内部类的实例化需要绑定在外部类的实例上</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;内部类的实例化，如果在外部类和外部类非静态方法之外实例内部类对象则需要下面的形式外部类名.内部类名 引用变量名 &#x3D; 外部实例引用变量.内部实例  &#x2F;&#x2F;内部实例可以是new的也可以是其他只要是内部实例就行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <strong>类中多次实现接口中同一个方法</strong><br>​    在程序中可以用权限修饰符为private的内部类实现。可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，就可以定义多个内部类以不同的方式实现接口中的同一个方法，而在一般的类中是不能多次实现接口中同一个方法的<br>​    此时通过在外部类中写方法实例化这个private内部类，之后用接口的引用来接这个实现接口的实例<br>​    <strong>详细见《Java实例-内部类的基本作用》例一</strong></p><p>​    <strong>外部类中定义的成员变量与内部类的成员变量名称相同，可以使用this关键字</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Outside&#123;private int x &#x3D; 0;private class Inside&#123;private int x &#x3D; 9;public void doit(int x)&#123;x++;              &#x2F;&#x2F;调用的是形参xthis.x++          &#x2F;&#x2F;调用的是内部类成员变量xOutside.this.x++  &#x2F;&#x2F;调用的是外部类成员变量x&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>(2).局部内部类</strong><br>​    在类的局部进行定义，如在类的方法或任意作用域中定义<br>​    由于内部类在类方法或者任意作用域中，<strong>在方法(作用域)的外部是无法访问该内部类</strong>，而内部类却可以访问当前代码块的常量**(final类型的局部变量)<strong>以及</strong>此外部类的所有成员**<br>​    在方法中的局部变量在内部类中可以访问<br>​    <strong>详细见《Java实例-内部类的基本作用》例二</strong></p><p>​    <strong>(3).匿名内部类</strong><br>​    用时再查，和局部内部类一样在方法中，不过去掉类名，在return语句下在描述类体</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;语法return new A()&#123;&#x2F;&#x2F;A为接口名&#x2F;&#x2F;类体&#125;; &#x2F;&#x2F;注意：这里特殊的需要加一个分号，分号代表接口的引用表达式的创建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    匿名内部类编译后会产生以“外部类名$序号”为名称的.class文件，序号以1<del>n排列，分别代表1</del>n个匿名内部类</p><p>​    <strong>(4).静态内部类（少见）</strong><br>​    在内部类前加修饰符static，则为静态内部类，<strong>静态内部类中可以声明static成员，但在非静态内部类中不能声明静态成员</strong><br>​    <strong>静态内部类的特点</strong></p><ul><li>静态内部类内不可以使用外部类的非静态成员</li><li>如果创建静态内部类的对象，不需要其外部类的对象<br>​    在程序测试时需要每个文件设置一个主方法，这会产生许多额外的代码，程序本身不需要这些主方法，所以一般把主方法写到静态内部类中，主要是编译后会产生独立类，测试完后删除即可</li></ul><h4 id="8-内部类的继承"><a href="#8-内部类的继承" class="headerlink" title="8. 内部类的继承"></a>8. 内部类的继承</h4><p>​    内部类的继承比普通类的继承要复杂</p><pre class="line-numbers language-none"><code class="language-none">package hello;public class First extends A.B&#123; &#x2F;&#x2F;继承内部类class Bpublic First(A a) &#123;a.super();&#125;&#125;class A&#123;class B&#123;&#x2F;&#x2F;something&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>在某个类继承内部类时，必须硬性给与这个类一个带参数的构造方法，并且该构造方法的参数为需要继承内部类的外部类的引用，同时在构造方法体中使用a.super()语句，这样才为继承提供了必要的对象引用</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实例-内部类</title>
      <link href="/2021/06/15/Java%E5%AE%9E%E4%BE%8B-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2021/06/15/Java%E5%AE%9E%E4%BE%8B-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Java实例-内部类的基本作用"><a href="#Java实例-内部类的基本作用" class="headerlink" title="Java实例-内部类的基本作用"></a>Java实例-内部类的基本作用</h2><h4 id="1-实例内部类–内部类在外部类中，内部类修饰为private"><a href="#1-实例内部类–内部类在外部类中，内部类修饰为private" class="headerlink" title="1. 实例内部类–内部类在外部类中，内部类修饰为private"></a>1. 实例内部类–内部类在外部类中，内部类修饰为private</h4><pre class="line-numbers language-none"><code class="language-none">package hello;interface Food&#123;public void doing();&#125;public class First&#123;public static void main(String[] args) &#123;Outside o &#x3D; new Outside();Food i &#x3D; o.create(); &#x2F;&#x2F;用接口引用类型来接内部类实现接口的实例i.doing();&#125;&#125;class Outside&#123;private class Inside implements Food&#123; &#x2F;&#x2F;private只能在外部类访问public void doing() &#123;System.out.println(&quot;eat egg&quot;);&#125;&#125;public Inside create() &#123;return new Inside();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-局部内部类–内部类在外部类的方法中，内部类无修饰符"><a href="#2-局部内部类–内部类在外部类的方法中，内部类无修饰符" class="headerlink" title="2. 局部内部类–内部类在外部类的方法中，内部类无修饰符"></a>2. 局部内部类–内部类在外部类的方法中，内部类无修饰符</h4><pre class="line-numbers language-none"><code class="language-none">package hello;interface Food&#123;public void doing();&#125;public class First&#123;public static void main(String[] args) &#123;Outside b &#x3D; new Outside();Food c &#x3D; b.a();c.doing();&#125;&#125;class Outside&#123;public Food a() &#123; &#x2F;&#x2F;方法返回值类型为接口类型class Inside implements Food&#123;public void doing() &#123;System.out.println(&quot;hello&quot;);&#125;&#125;return new Inside();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java08</title>
      <link href="/2021/06/05/Java08/"/>
      <url>/2021/06/05/Java08/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h4 id="1-抽象类的引入"><a href="#1-抽象类的引入" class="headerlink" title="1. 抽象类的引入"></a>1. 抽象类的引入</h4><p>​    一般将父类定义为抽象类，然后对这个父类进行继承与多态处理，在继承树中越上方的类越抽象<br>​    在多态机制中，一般不需要将父类初始化对象，只需要子类对象，<strong>在Java中设置的抽象类不能实例化为对象</strong></p><h4 id="2-abstract关键字"><a href="#2-abstract关键字" class="headerlink" title="2. abstract关键字"></a>2. abstract关键字</h4><p>​    abstract关键字定义的类为抽象类，定义的方法为抽象方法，抽象方法没有方法体，方法本身没有意义，但通过重写来获得意义，承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义</p><pre class="line-numbers language-none"><code class="language-none">public abstract class Test&#123;  &#x2F;&#x2F;定义抽象类abstract void textAbstract();  &#x2F;&#x2F;定义抽象方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    声明一个抽象的方法，则必须将承载这个抽象方法的类定义为抽象类，不可能在非抽象类获取抽象方法，只要类中有一个抽象方法，这个类就被标记为抽象类<br>​    抽象类被继承后子类若不是抽象类需要实现其中所有的抽象方法，要保证相同的方法名称、参数列表和相同的返回类型<br>​    abstract无法和final共存修饰类，但是抽象类里面可以用final与static修饰变量和方法，若你创建的类不想被创建对象，变量方法不想被继承，但又要可以直接调用，可以实现抽象类</p><h4 id="3-接口的引入"><a href="#3-接口的引入" class="headerlink" title="3. 接口的引入"></a>3. 接口的引入</h4><p>​    当你需要的一系列子类既需要继承重写父类的抽象方法，同时还需要一个共同的方法但实现过程各子类不相同，有些甚至不需要，就可以把这个方法封装在接口中，需要的子类再去实现这个接口，不需要的就不用了<br>​    接口是抽象类的延伸，可以把它看作为一个纯粹的抽象类，接口中的所有方法都没有方法体<br>​    接口用来弥补类无法实现多继承的局限<br>​    由于接口为抽象类，为父类，所以你也可以像之前多态一样去使用接口，具体见<strong>7</strong><br>​    <strong>注意：接口内的方法省略abstract关键字</strong><br>​    如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类</p><h4 id="4-interface关键字"><a href="#4-interface关键字" class="headerlink" title="4. interface关键字"></a>4. interface关键字</h4><p>​    接口使用interface关键字进行定义</p><pre class="line-numbers language-none"><code class="language-none">public interface drawTest&#123;&#x2F;&#x2F;public可以不要，有public类时就不需要了void draw(); &#x2F;&#x2F;接口内的方法省略abstract关键字&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-implements关键字"><a href="#5-implements关键字" class="headerlink" title="5. implements关键字"></a>5. implements关键字</h4><p>​    一个类实现一个接口，可以使用implements关键字</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;public可以不要，有public类时就不需要了public class child extends father implements drawTest&#123;&#x2F;&#x2F;可以不继承直接实现接口的，要实现多个接口每个接口用,隔开&#x2F;&#x2F;something&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-接口的注意事项"><a href="#6-接口的注意事项" class="headerlink" title="6. 接口的注意事项"></a>6. 接口的注意事项</h4><ul><li>在接口中方法必须定义为public或者abstract形式，其他权限修饰符不被Java编译器认可，如果未注明默认就是public and abstract的</li><li>在接口中定义的任何字段都自动是static和final和public的</li><li>继承一个接口时需要实现接口中所有的方法</li><li>一个类可以实现不止一个接口，语法见<strong>5</strong></li></ul><h4 id="7-接口的进阶"><a href="#7-接口的进阶" class="headerlink" title="7. 接口的进阶"></a>7. 接口的进阶</h4><p>​    <strong>我们不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的，这样怎么可能产生具体的实例呢？但是，我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法</strong></p><p>​    应该优先使用接口而不是类来引用对象。如果有适合的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。<br>​    如果你养成了用接口作为类型的习惯，你的程序将会更加灵活</p><h4 id="8-接口的静态方法"><a href="#8-接口的静态方法" class="headerlink" title="8. 接口的静态方法"></a>8. 接口的静态方法</h4><p>​    Java 8允许静态接口方法<br>​    不能覆盖静态接口方法，只能通过使用接口名+静态接口方法名使用该静态接口方法，实例化后是无法调用的<br><a href="https://imgtu.com/i/4zrWGD"><img src="https://z3.ax1x.com/2021/10/06/4zrWGD.png" alt="4zrWGD.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java07</title>
      <link href="/2021/06/04/Java07/"/>
      <url>/2021/06/04/Java07/</url>
      
        <content type="html"><![CDATA[<h2 id="类的继承，多态"><a href="#类的继承，多态" class="headerlink" title="类的继承，多态"></a>类的继承，多态</h2><h4 id="1-继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写-覆盖-父类中的某些方法"><a href="#1-继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写-覆盖-父类中的某些方法" class="headerlink" title="1. 继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写(覆盖)父类中的某些方法"></a>1. 继承的基本思想是基于某个父类进行拓展，得到一个新子类，该子类可以继承父类原有的属性和方法，可以增加父类不具备的属性和方法，可以重写(覆盖)父类中的某些方法</h4><h4 id="2-extends关键字"><a href="#2-extends关键字" class="headerlink" title="2. extends关键字"></a>2. extends关键字</h4><p>​    用来标识两个类的继承关系</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;父类class bookStore&#123;&#125;&#x2F;&#x2F;子类class book extends bookStore&#123;&#x2F;&#x2F;当子类再次声明与父类一样的成员变量时，就有两个名字一样的成员变量，要使用父类的话需用super()关键字来引用父类(无关键字时，子类中和父类中的属性或方法同名，则父类中的方法或属性将被覆盖或隐藏)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-super关键字"><a href="#3-super关键字" class="headerlink" title="3. super关键字"></a>3. super关键字</h4><p>​    (1).在Java类中使用super关键字来引用父类的成分，它是一个指代变量，用于在子类中指代父类对象<br>​    (2).只能用于子类的构造函数和实例方法中，不能用于子类的类（静态）方法中。原因是super指代的是一个父类的对象，它需要在运行时被创建，而静态方法是类方法，它是类的一部分。当类被加载时，方法已经存在，但是这时候父类对象还没有被初始化</p><h4 id="4-子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类"><a href="#4-子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类" class="headerlink" title="4. 子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类"></a>4. 子类是父类的派生类，它的实例化依赖于父类的实例化。所以它的任何一个构造函数都必须要初始化父类</h4><pre class="line-numbers language-none"><code class="language-none">class bookStore&#123;&#125;&#x2F;&#x2F;子类class book extends bookStore&#123;public book()&#123;super();  &#x2F;&#x2F;初始化父类&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：</strong></p><ul><li>在我们子类的构造函数中，如果我们没有显式调用super来初始化父类的话，那么Java会隐式的调用super();来调用父类无参构造函数并把它放在构造函数的第一行</li><li>Java只会隐式的调用无参构造函数，如果父类没有无参构造函数，那么子类中就必须显式的调用super关键字来调用已有的有参构造函数来初始化父类</li><li> 子类中的super为什么必须要放在第一行？因为子类的实例化依赖于父类的实例化，在构建子类时，必须要有父类实例，只能有了父类的实例，子类才能够初始化自己</li></ul><h4 id="5-当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，-一个-多个父类时是从顶级向下调用"><a href="#5-当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，-一个-多个父类时是从顶级向下调用" class="headerlink" title="5. 当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，(一个)多个父类时是从顶级向下调用"></a>5. 当实例化子类对象时，父类的对象也相应的被实例化，且Java编译器会在子类的构造方法中自动调用父类的无参构造方法，(一个)多个父类时是从顶级向下调用</h4><h4 id="6-方法的重写"><a href="#6-方法的重写" class="headerlink" title="6. 方法的重写"></a>6. 方法的重写</h4><p>​    重写只有方法的重写与属性无关    </p><p>​    重写也可以称为覆盖，是保留父类成员方法的名字，重写可以重写成员方法实现的内容、成员方法的修饰符权限、成员方法的返回值类型<br>​    <strong>注意：1.方法名必须相同</strong></p><p>​                <strong>2.参数列表必须相同</strong></p><p>​                <strong>3.修改成员方法修饰符权限只能从小范围向大范围改变</strong></p><p>​                <strong>4.抛出的异常的范围可以缩小，但不能扩大</strong></p><p>​    重构：特殊的重写方法，子类与父类的返回值、方法名称、参数类型以及个数完全相同，唯一不同的是方法的实现内容</p><h4 id="7-Object类"><a href="#7-Object类" class="headerlink" title="7. Object类"></a>7. Object类</h4><p>​    在Java中所有的类都继承了Java.lang.Object类，由于所有类都是继承这个类所以定义类时可以省略extends Object</p><p>​    Object类中的getClass()，notify()，notifyAll()，wait()等方法不能被重写，这些方法被定义为final类型</p><p>​    Object类的重要方法</p><ul><li><p>getClass()方法<br>​    返回对象执行时的Class实例，该实例通过getName()方法获得类的名称</p></li><li><p>toString()方法<br>​    将一个对象返回为字符串形式，它会返回一个String实例，在实际运用中经常重写该方法</p></li><li><p>equals()方法<br>​    按理说是比较两个对象的实际内容是否相等,但类对象的equals方法实现了对象上最有区别的等价关系；也就是说，对于任何非空的引用值x和y，当且仅当x和y引用同一对象（x == y的值为true）时，此方法才返回true，像之前的String比较里面内容是因为重写了这个方法<br>​    <strong>注意：在自定义类中使用equals()方法进行比较时，相同的对象比较会返回false，因为equals()方法的默认实现使用”==”运算符来比较两个对象的引用地址，而不上比较对象的内容，所以要比较内容需要重写equals()方法</strong></p></li></ul><h4 id="8-对象类型的转换"><a href="#8-对象类型的转换" class="headerlink" title="8. 对象类型的转换"></a>8. 对象类型的转换</h4><ul><li><p>向上转型(多态)<br>​    把子类对象赋值给父类类型的引用变量<br>​    <strong>父类的引用可以调用子类中重写的父类的方法，但不能调用子类中独有的方法</strong></p><pre class="line-numbers language-none"><code class="language-none">父类型 a &#x3D; new 子类型();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>向下转型(显式类型转换)<br>​    把父类对象强制转化为子类型，赋值给子类引用变量<br>​    进行向下转型时，如果父类对象不是子类的实例，会产生ClassCastException异常，所以经常使用instanceof操作符来完成判断</p><pre class="line-numbers language-none"><code class="language-none">子类型 b &#x3D; (子类型)父类对象的引用变量;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    父类中没有的方法和类型必须要向下转型后才能调用</p></li></ul><h4 id="9-instanceof操作符"><a href="#9-instanceof操作符" class="headerlink" title="9. instanceof操作符"></a>9. instanceof操作符</h4><p>​    用来判断是否一个类实现了某个接口，还可以判断一个实例的对象是否属于一个类(子类一定时属于父类的，不能说父类属于子类，即平行四边形属于四边形，但四边形不属于平行四边形)</p><pre class="line-numbers language-none"><code class="language-none">子对象 instanceof 父类型; &#x2F;&#x2F;返回true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    该方式经常与向下转型连用，当不属于时把父类强制转化为子类<br>​    当两个类完全没有关系时使用这个操作符来操作会报错</p><p><strong>详细使用请看笔记《Java实例-多态》</strong></p><h4 id="10-方法的重载"><a href="#10-方法的重载" class="headerlink" title="10. 方法的重载"></a>10. 方法的重载</h4><p>​    在同一个类中允许存在一个以上的同名方法，只要这些方法的参数个数或类型不同即可<br>​    <strong>注意：方法重载中可以使两个方法的返回值类型不同，但只有返回值类型不同不足以区分两个方法的重载</strong><br>​    编译器是利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一</p><h4 id="11-不定长参数"><a href="#11-不定长参数" class="headerlink" title="11. 不定长参数"></a>11. 不定长参数</h4><pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F;定义不定长参数方法 &#x2F;&#x2F;返回值 方法名(参数数据类型...参数名称)public static int add(int...a)&#123;不定长参数a为一个数组，a的长度取决于调用时传的参数&#x2F;&#x2F;方法体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    不定长参数方法可以作为一个单独的重载方法</p><h4 id="12-多态"><a href="#12-多态" class="headerlink" title="12. 多态"></a>12. 多态</h4><p>​    多态存在的三个前提</p><ul><li>要有继承关系</li><li>子类要重写父类方法</li><li>父类引用指向子类对象</li></ul><p>​    通过定义一个父类，让它的所有子类通过向上转型的原则作为一个方法的参数，再在这个方法中做出一些限定，后可以做出每个子类自己独有的事情。<br>​    这样的处理可以很好解决代码的冗余问题，同时使得程序易于维护，可以随意增加子类，只需要改变传参就可以了</p><p><strong>多态的样例代码见请看笔记《Java实例-多态》</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实例-多态</title>
      <link href="/2021/06/04/Java%E5%AE%9E%E4%BE%8B-%E5%A4%9A%E6%80%81/"/>
      <url>/2021/06/04/Java%E5%AE%9E%E4%BE%8B-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="多态实例"><a href="#多态实例" class="headerlink" title="多态实例"></a>多态实例</h2><pre class="line-numbers language-none"><code class="language-none">package hello;import java.text.DecimalFormat;import java.util.Random;import java.lang.Math;public class First&#123;public static void main(String[] args) &#123;choose(new child1());choose(new child2());&#125;public static void choose(father a) &#123;a.Todo();if(a instanceof child1) &#123;((child1) a).eat();&#x2F;&#x2F;父类中没有的方法和类型必须要向下转型后才能调用&#125;else if(a instanceof child2) &#123;((child2) a).eat();&#125;&#125;&#125;class father&#123;public father() &#123;&#125;public void Todo() &#123;System.out.println(&quot;work&quot;);&#125;&#125;class child1 extends father&#123;public child1() &#123;super();&#125;public void Todo() &#123;System.out.println(&quot;study&quot;);&#125;public void eat() &#123;System.out.println(&quot;fish&quot;);&#125;&#125;class child2 extends father&#123;public child2() &#123;super();&#125;public void Todo() &#123;System.out.println(&quot;sing&quot;);&#125;public void eat() &#123;System.out.println(&quot;fish&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java06</title>
      <link href="/2021/06/02/Java06/"/>
      <url>/2021/06/02/Java06/</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h4 id="1-为什么要有包装类"><a href="#1-为什么要有包装类" class="headerlink" title="1. 为什么要有包装类"></a>1. 为什么要有包装类</h4><ul><li>在面向对象中，“一切皆对象”，但基本数据类型的数据不太符合这一理念，基本数据类型不是对象</li><li>涉及到类型之间的转化，数据类型之间的基本操作；如果都有我们自己去实现，那么工作量过大</li><li>java针对每一个基本数据类型都设计了一个包装类</li></ul><h4 id="2-java-lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例"><a href="#2-java-lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例" class="headerlink" title="2. java.lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例"></a>2. java.lang包中的Integer类、Long类、Short类，可以将int、long和short封装成一个类，这些都是Number的子类，他们包含的方法基本相同，之后只以Integer类为例</h4><h4 id="3-Integer类"><a href="#3-Integer类" class="headerlink" title="3. Integer类"></a>3. Integer类</h4><p>Integer类将原语类型int的值包装在对象中。integer类型的对象包含一个类型为int的字段</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;Integer d &#x3D; Integer.valueOf(400); &#x2F;&#x2F;等同于将基本类型装箱，另一种装箱方法已经不允许Integer d &#x3D; new Integer(400);int a &#x3D; d.intValue(); &#x2F;&#x2F;将Integer类型拆箱&#x2F;**在Java 5之前的版本中，基本数据类型和包装类之间的转换是需要手动进行的,但Sun公司从Java5开始提供了的自动装箱(Autoboxing)和自动拆箱(AutoUnboxing)操作*&#x2F;Integer i &#x3D; 13; &#x2F;&#x2F;自动装箱int c &#x3D; i;      &#x2F;&#x2F;自动拆箱System.out.print(a);&#125;&#x2F;&#x2F;输出400<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般都是使用该类的提供的一些方法，让数据可以在int类型与String类型之间相互转换<br>如，以下为部分静态方法(详细全部方法见API文档)</p><pre class="line-numbers language-none"><code class="language-none">toString() &#x2F;&#x2F;返回一个表示该Integer值的String对象，返回值StringparseInt(String str) &#x2F;&#x2F;返回包含在由str指定的字符串中的数字的等价整数值，返回值intvalueOf(String str或者int i) &#x2F;&#x2F;返回保存指定的String值或int值的Integer对象intValue() &#x2F;&#x2F;以int型返回此Integer对象，返回值int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可"><a href="#4-Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可" class="headerlink" title="4. Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可"></a>4. Boolean类，Byte类，Character类，Double类都与上面Integer类类似，需要时自己查阅即可</h4><h2 id="数字处理类"><a href="#数字处理类" class="headerlink" title="数字处理类"></a>数字处理类</h2><h4 id="1-Java中未进行格式化的数字遵循以下原则："><a href="#1-Java中未进行格式化的数字遵循以下原则：" class="headerlink" title="1. Java中未进行格式化的数字遵循以下原则："></a>1. Java中未进行格式化的数字遵循以下原则：</h4><ul><li>如果数据绝对值大于0.001并且小于10000000，使以常规小数形式表示</li><li>如果数据绝对值小于0.001并且大于10000000，使用科学计数法表示</li></ul><h4 id="2-数字格式化-使用DecimalFormat"><a href="#2-数字格式化-使用DecimalFormat" class="headerlink" title="2. 数字格式化(使用DecimalFormat)"></a>2. 数字格式化(使用DecimalFormat)</h4><p>​    使用这个类时需要用import关键字将java.text.DecimalFormat引入<br>​    DecimalFormat是NumberFormat的一个子类，用于格式化十进制数字，可以在实例化DecimalFormat对象时传递数字格式(以字符串格式表示)，如果未传入的话则可以通过applyPattern方法来传入设置模板(模板是有特殊字符组成的)，该方法参数为空时抛出异常NullPointerException，<strong>注意：小数时若模板小于数字则会四舍五入</strong></p><p><a href="https://imgtu.com/i/2V5aR0"><img src="https://z3.ax1x.com/2021/05/30/2V5aR0.png" alt="2V5aR0.png"></a></p><hr><p><strong>DecimalFormat类中特殊字符的说明</strong></p><table><thead><tr><th align="center">字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">代表阿拉伯数字，一个0表示一个阿拉伯数字，如果该位不存在数字，则显示0</td></tr><tr><td align="center">#</td><td align="center">代表阿拉伯数字，一个#表示一个阿拉伯数字，如果该位不存在数字，则不显示</td></tr><tr><td align="center">.</td><td align="center">小数分割符或货币小数分割符</td></tr></tbody></table><p>​    setGroupingSize(int newValue)方法设置格式化数字的分组大小,分组大小是数字整数部分中分组分隔符之间的位数，像分组为2的话，123456.789为12,34,56.789<br>​    setGroupingUsed(boolean newValue)方法设置是否在此格式中使用分组，newValue的值为如果使用分组，则为true；否则为假</p><h4 id="3-数学运算"><a href="#3-数学运算" class="headerlink" title="3. 数学运算"></a>3. 数学运算</h4><p>​    Java中提供了一个执行数学基本运算的Math类，在java.lang.Math，里面提供的大多数方法都被定义为static形式</p><pre class="line-numbers language-none"><code class="language-none">Math.数字方式<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    Math类也提供一些常用数学常量</p><pre class="line-numbers language-none"><code class="language-none">Math.PI   &#x2F;&#x2F;Π<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>常用的数学运算方法分为四类，三角函数方法、指数函数方法、取整函数方法、取最大值最小值绝对值函数方法，具体的需要使用时，自行翻阅API文档</strong></p><h4 id="4-随机数"><a href="#4-随机数" class="headerlink" title="4. 随机数"></a>4. 随机数</h4><p>​    通过Math类中的random()方法产生伪随机数字，该方法返回一个double型的随机数，小数点后面可以保留15位小数，返回值是从该范围内以（近似）均匀分布伪随机选择的，范围在0&lt;=Math.random()&lt;1.0，通过对于该方法的处理可以产生任意范围内的随机数，这个方法是调用java.util.Random()</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;产生其他范围的伪随机数(int)(Math.random()*n) &#x2F;&#x2F;返回大于等于0且小于n的随机数m+(int)(Math.random()*n) &#x2F;&#x2F;返回大于等于m且小于m+n的随机数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    什么是伪随机数？</p><ul><li>伪随机数是看似随机实质是固定的周期性序列,也就是有规则的随机。</li><li>只要这个随机数是由确定算法生成的,那就是伪随机,只能通过不断算法优化,使你的随机数更接近随机。(随机这个属性和算法本身就是矛盾的)</li><li>通过真实随机事件取得的随机数才是真随机数</li></ul><p>​    Random类<br>​    Random类在java.util下，通过实例化Random对象可以创建一个随机数字生成器</p><pre class="line-numbers language-none"><code class="language-none">Random r &#x3D; new Random(); &#x2F;&#x2F;未在初始化器里设置种子<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    当用这个方式实例化对象时(未在初始化器里设置种子)，Java编译器将以系统当前时间作为随机数生成器的种子(每时每刻时间不同)，但如果运行速度太快，也会产生两次运行结果相同的随机数</p><p>​    也可以在实例化对象时，设置随机数生成器种子</p><pre class="line-numbers language-none"><code class="language-none">Random r &#x3D; new Random(long seed); &#x2F;&#x2F;设置种子,当种子一样时，产生的随机数是一样的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    Random类提供的常用方法(部分)</p><pre class="line-numbers language-none"><code class="language-none">public int nextInt():返回一个随机整数public int nextInt(int n):返回大于等于0且小于n的随机整数public boolean nextBoolean():返回一个随机布尔值public double nextDouble():返回一个随机双精度值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java05</title>
      <link href="/2021/05/25/Java05/"/>
      <url>/2021/05/25/Java05/</url>
      
        <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="1-在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法"><a href="#1-在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法" class="headerlink" title="1. 在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法"></a>1. 在Java中对象的属性也被称为成员变量，类对象的行为叫做成员方法</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;成员方法的语法格式权限修饰符 返回值类型 方法名(参数类型 参数名)&#123;&#x2F;&#x2F;方法体return 返回值;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2. 权限修饰符"></a>2. 权限修饰符</h4><p><strong>类权限(注意：类权限会约束类成员的权限设定，大于类的权限的类成员都会默认为类的权限进行约束)</strong></p><table><thead><tr><th align="center">访问包位置</th><th align="center">private</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td align="center">本类</td><td align="center">可见</td><td align="center">可见</td><td align="center">可见</td></tr><tr><td align="center">同包其他类或者子类</td><td align="center">不可见</td><td align="center">可见</td><td align="center">可见</td></tr><tr><td align="center">其他包的类或子类</td><td align="center">不可见</td><td align="center">不可见</td><td align="center">可见</td></tr></tbody></table><p><strong>注意：声明类时不使用上述三个修饰符设置权限，则这个类预设为friendly，可以本类，同包其他类但不能子类，其他包即子类也不行</strong></p><h4 id="3-局部变量"><a href="#3-局部变量" class="headerlink" title="3. 局部变量"></a>3. 局部变量</h4><p>​    在成员方法内定义的变量叫做局部变量，方法是形参也是局部变量<br>​    <strong>局部变量在方法内使用时必须进行赋值和初始化不然会报错</strong></p><h4 id="4-局部变量的作用域-有效范围"><a href="#4-局部变量的作用域-有效范围" class="headerlink" title="4. 局部变量的作用域(有效范围)"></a>4. 局部变量的作用域(有效范围)</h4><p>​    在相互不嵌套使用的作用域中可以同时声明两个名称和类型相同的局部变量<br>​    一个花括号括起来的表示一个作用域</p><h4 id="5-this关键字"><a href="#5-this关键字" class="headerlink" title="5. this关键字"></a>5. this关键字</h4><p>​    在Java语言中规定使用this关键字来代表本类对象的引用，即引用对象的成员变量和方法<br>​    <strong>(1).在局部变量与类的成员变量重名时，就需要添加this关键字来明确引用的是类</strong></p><p>​    (2).this关键字还可以作为方法的返回值</p><pre class="line-numbers language-none"><code class="language-none">public Book getBook()&#123;return this;      &#x2F;&#x2F;返回Book类的对象等同于return Book&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    (3).this关键字还可以调用构造方法</p><pre class="line-numbers language-none"><code class="language-none">public class Student &#123; &#x2F;&#x2F;定义一个类，类的名字为student。  public Student() &#123; &#x2F;&#x2F;定义一个方法，名字与类相同故为构造方法this(“Hello!”);   &#x2F;&#x2F;this来引用下面的带形参的构造方法，因为this关键字里面带有一个参数&#125;public Student(String name) &#123;&#x2F;&#x2F;定义一个带形式参数的构造方法 &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：this()只能出现在构造方法非注释语句的第一行</strong></p><p>​    (4). this关键字不能使用在静态方法当中</p><h4 id="6-类的构造方法"><a href="#6-类的构造方法" class="headerlink" title="6. 类的构造方法"></a>6. 类的构造方法</h4><p>类中除了成员方法外，还存在着构造方法<br>​    ==构造方法是一个与类同名的方法==，对象的创建就是构造方法完成的，每当实例化对象(new 对象)时，类会自动调用构造方法<br>​    <strong>注意：构造方法没有返回值，但方法前不需要void关键字修饰，类中没有明确定义构造方法时编译器会自动创建一个不带参数的默认构造方法</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;构造方法的定义格式public book()&#123; &#x2F;&#x2F;里面可以放参数&#x2F;&#x2F;构造方法体; &#x2F;&#x2F;可以初始化成员变量&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-static关键字"><a href="#7-static关键字" class="headerlink" title="7. static关键字"></a>7. static关键字</h4><p>​    由static修饰的变量、常量和方法被称为静态变量、常量和方法，即静态成员，静态成员属于类所有，使用类名+’.’运算符调用静态成员<br>​    当需要两个或以上的类要在同一个内存区域共享一个数据，可以使用静态变量来存储该数据<br>​    实例化后的对象依然可以调用静态XX，但不建议使用这样的形式，这样容易混淆静态成员和非静态成员<br>​    <strong>注意：静态方法中不可以直接调用非静态方法</strong><br>​    Java中规定不能将方法体内的局部变量声明为static</p><p>​    <strong>类加载</strong><br>​    jvm在程序执行的时候，需要用到类中的信息，但jvm只能读取内存的数据，所以需要进一步操作，把类中的信息，从硬盘上.class文件读取出来放在合适的位置<br>​    当一个类首次被使用，对该类加载，加载的同时，执行类的初始化过程<strong>（注意初始化和实例化的区别）</strong><br>​    被<strong>static关键字修饰</strong>的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问</p><pre class="line-numbers language-none"><code class="language-none">class Test&#123;private Test(String s) &#123;System.out.println(s);&#125;&#x2F;&#x2F;通过static关键字在类加载时初始化aprivate static Test a &#x3D; new Test(&quot;这是一个static程序&quot;);public static Test instance() &#123;return a;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>类的初始化操作</strong><br>​    通过static定义静态区域(静态块)</p><pre class="line-numbers language-none"><code class="language-none">public class example&#123;static&#123;&#x2F;&#x2F;some;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    当这个类被引用时，首先自动执行static块中的程序，而且只会执行一次</p><h4 id="8-类的主方法"><a href="#8-类的主方法" class="headerlink" title="8. 类的主方法"></a>8. 类的主方法</h4><p>​    主方法是类的入口点，Java编译器通过主方法来执行程序<br>​    主方法语法</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args)&#123;&#x2F;&#x2F;方法体;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    主方法的特性<br>​    (1).主方法是静态的,在主方法中要直接调用其他方法,该方法也必须是静态的<br>​    (2).主方法没有返回值<br>​    (3).主方法的形参为数组,args[0]~args[n],表示第一到第n个参数,参数个数用args.length来获取</p><h4 id="9-对象"><a href="#9-对象" class="headerlink" title="9. 对象"></a>9. 对象</h4><p>​    (1).对象的创建<br>​    对象是由类抽象出来的某一个特例,每一个对象是相互独立的<br>​    Java语言中使用new操作符调用构造方法来创建对象,对象被创建出来时就是对一个对象的引用</p><pre class="line-numbers language-none"><code class="language-none">Book a &#x3D; new Book(); &#x2F;&#x2F;对象的创建可以直接new Book()不需要前面的,但操作不了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    (2).访问对象的属性和方法<br>​    在使用new操作符创建了一个对象后,可以使用”对象.类成员”来获取对象的属性和方法</p><p>​    (3).对象的引用<br>​    基本语法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;类名 对象引用名称Book book; &#x2F;&#x2F;引用不需要有一个对象相关联<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <strong>注意:引用只是存放一个对象的内存地址,并非存放一个对象</strong></p><p>​    (4).对象的比较<br>​    Java语言有两种比较对象的方式,”==”运算符和equals()方法(String类中的方法)</p><ul><li><p>“==”运算符<br>​    比较的是两个对象的引用地址是否相等</p></li><li><p>equals()方法<br>​    比较两个对象引用所指向的内容是否相等</p></li></ul><p>​    (5).对象的销毁<br>​    在Java中处于两种情况下对象被Java虚拟机视为垃圾</p><ul><li>对象引用超过其作用范围(作用域)</li><li>将对象的赋值为null</li></ul><p>​    <strong>注意:Java的垃圾回收器只能销毁new操作符创建的对象</strong><br>​    为了回收不通过new操作符来在内存中获取存储空间的对象,Java还提供object类中的finalize()方法被声明为protected,用户可以自己的类中定义这个方法来回收垃圾(不保证一定发生,当Java虚拟机内存耗尽时,则不会执行垃圾回收处理)<br>​    Java还提供了System.gc()方法强制启动垃圾回收器</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java04</title>
      <link href="/2021/05/23/Java04/"/>
      <url>/2021/05/23/Java04/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="1-数组的声明-两种方式"><a href="#1-数组的声明-两种方式" class="headerlink" title="1. 数组的声明(两种方式)"></a>1. 数组的声明(两种方式)</h4><p>​    注意：数组在声明时并没有分配内存空间<br>​    注意：数组声明数组名后的[]里什么都不能写</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;符号[]表面变量为一个数组变量，单个[]表示要创建的数组为一维数组数组元素类型 数组名字[]数组元素类型[] 数组名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-数组内存空间的分配"><a href="#2-数组内存空间的分配" class="headerlink" title="2. 数组内存空间的分配"></a>2. 数组内存空间的分配</h4><pre class="line-numbers language-none"><code class="language-none">数组名字 &#x3D; new 数组元素的类型[数组元素的个数]  &#x2F;&#x2F;创建数组后未进行赋值则数组元素都为该类型的初始值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-一维数组声明并分配内存空间"><a href="#3-一维数组声明并分配内存空间" class="headerlink" title="3. 一维数组声明并分配内存空间"></a>3. 一维数组声明并分配内存空间</h4><pre class="line-numbers language-none"><code class="language-none">int a[] &#x3D; new int[10];  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-注意：数组一旦进行初始化不可以对数组手动分配内存空间"><a href="#4-注意：数组一旦进行初始化不可以对数组手动分配内存空间" class="headerlink" title="4. 注意：数组一旦进行初始化不可以对数组手动分配内存空间"></a><strong>4. 注意：数组一旦进行初始化不可以对数组手动分配内存空间</strong></h4><h4 id="5-一维数组的初始化"><a href="#5-一维数组的初始化" class="headerlink" title="5. 一维数组的初始化"></a>5. 一维数组的初始化</h4><pre class="line-numbers language-none"><code class="language-none">int a[] &#x3D; new int[]&#123;1,2,3,4&#125;;  &#x2F;&#x2F;第一种初始化方式，注意括号内不能写数字int a[] &#x3D; &#123;1,2,3,4&#125;;           &#x2F;&#x2F;第二种初始化方式int a[];                       &#x2F;&#x2F;第三种初始化方式a &#x3D; new int[]&#123;1,2,3,4&#125;;        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-二维-高维-数组声明后的内存空间分配-2种"><a href="#6-二维-高维-数组声明后的内存空间分配-2种" class="headerlink" title="6. 二维(高维)数组声明后的内存空间分配(2种)"></a>6. 二维(高维)数组声明后的内存空间分配(2种)</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;(1)为每一维分配内存空间a &#x3D; new int[2][4];&#x2F;&#x2F;(2)分别为每一维分配内存空间a &#x3D; new int[2][];a[0] &#x3D; new int[2];a[1] &#x3D; new int[3];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-二维数组的初始化-与一维类似"><a href="#7-二维数组的初始化-与一维类似" class="headerlink" title="7. 二维数组的初始化(与一维类似)"></a>7. 二维数组的初始化(与一维类似)</h4><pre class="line-numbers language-none"><code class="language-none">数组数据类型 数组名[][] &#x3D; &#123;&#123;值1,值2&#125;,&#123;..&#125;,&#123;..&#125;&#125;; &#x2F;&#x2F;注意：每一个大的项要用花括号&#123;&#125;起来,不需要每一项元素个数相等<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-数组的基本操作"><a href="#8-数组的基本操作" class="headerlink" title="8. 数组的基本操作"></a>8. 数组的基本操作</h4><p>​    (1).遍历数组<br>​    通过数组的length属性来获得数组的长度<br>​    **注意：数组的元素只取到length-1</p><p>​    (2).剩下的都是一些对数组的函数可以自己用算法来完成，到时要用再看看就行，我觉得可能是方法重写的时候用的上</p><h4 id="9-数组排序算法"><a href="#9-数组排序算法" class="headerlink" title="9. 数组排序算法"></a>9. 数组排序算法</h4><p>​    (1).冒泡排序法<br>​    <strong>主要思想：把相邻两个元素进行比较，不满足则交换，每次循环将最大或是最小的元素排在最后，下一次循环进行类似操作</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;外层循环控制排序轮数，一般比数组长度减一因为最后一次只剩一个数组元素了for(int i &#x3D; 1;i &lt; arr.length;i++) &#123;&#x2F;&#x2F;内层循环用于对比临近元素的大小，对比交换次数随着排序轮数减少for(int j &#x3D; 0;j &lt; arr.length-i;j++) &#123;if(arr[j]&gt;arr[j+1]) &#123;int tmp &#x3D; arr[j];arr[j] &#x3D; arr[j+1];arr[j+1] &#x3D; tmp;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    (2).直接选择排序法(选择排序的一种)<br>​    <strong>主要思想：将指定排序位置与其他数组元素分别对比，如果满足条件就交换元素的值</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;index是用来寻找当前数组中最大或最小的值的索引位置int index &#x3D; 0;&#x2F;&#x2F;外层循环控制排序轮数，一般比数组长度减一因为最后一次只剩一个数组元素了for(int i &#x3D; 1;i&lt;arr.length;i++) &#123;&#x2F;&#x2F;index在每次循环时都应该清零index &#x3D; 0;&#x2F;&#x2F;内循环用来获取当前数组中最大的值，在下一次循环时不计入该数值for(int j &#x3D; 1;j&lt;&#x3D;arr.length - i;j++) &#123;if(arr[j]&gt;arr[index]) &#123;index&#x3D;j;&#125;&#125;&#x2F;&#x2F;将数组最左或者最右的值与数组最大值交换int tmp &#x3D; arr[arr.length - i];arr[arr.length - i] &#x3D; arr[index];arr[index] &#x3D; tmp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java03</title>
      <link href="/2021/05/17/Java03/"/>
      <url>/2021/05/17/Java03/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="1-前面的char类型只可以表示单个字符"><a href="#1-前面的char类型只可以表示单个字符" class="headerlink" title="1. 前面的char类型只可以表示单个字符"></a>1. 前面的char类型只可以表示单个字符</h4><h4 id="2-java语言将字符串作为对象来处理，可以通过java-lang包中的String类来创建字符串对象"><a href="#2-java语言将字符串作为对象来处理，可以通过java-lang包中的String类来创建字符串对象" class="headerlink" title="2. java语言将字符串作为对象来处理，可以通过java.lang包中的String类来创建字符串对象"></a><strong>2. java语言将字符串作为对象来处理，可以通过java.lang包中的String类来创建字符串对象</strong></h4><h4 id="3-java中由双引号-“”-包围的都是字符串，不能作为其他数据类型来使用"><a href="#3-java中由双引号-“”-包围的都是字符串，不能作为其他数据类型来使用" class="headerlink" title="3. java中由双引号(“”)包围的都是字符串，不能作为其他数据类型来使用"></a>3. java中由双引号(“”)包围的都是字符串，不能作为其他数据类型来使用</h4><h4 id="4-声明字符串"><a href="#4-声明字符串" class="headerlink" title="4. 声明字符串"></a>4. 声明字符串</h4><pre class="line-numbers language-none"><code class="language-none">String s;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：声明的字符串变量必须经过初始化才可以使用，否则编译器报错</strong></p><h4 id="5-创建字符串对象"><a href="#5-创建字符串对象" class="headerlink" title="5. 创建字符串对象"></a><strong>5. 创建字符串对象</strong></h4><p>由于java是按照对象来处理字符串，所以创建方式和对象一样</p><p>==String类常用的构造方法==<br>​    (1).String(char a[])<br>​    用一个字符数组a创建String对象</p><pre class="line-numbers language-none"><code class="language-none">char a[] &#x3D; &#123;&#39;g&#39;,&#39;o&#39;,&#39;o&#39;,&#39;d&#39;&#125;; 等价于    String s &#x3D; new String(a);  &#x3D;&#x3D;&#x3D;&#x3D;&gt;   String s &#x3D; new String(&quot;good&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    (2).String(char a[],int offset,int length)  <strong>//从第offse个元素向后取length个元素</strong></p><p>​    提取字符数组a中的一部分创建一个字符串对象</p><pre class="line-numbers language-none"><code class="language-none">char a[] &#x3D; &#123;&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;d&#39;,&#39;e&#39;,&#39;n&#39;,&#39;t&#39;&#125;; 等价String s&#x3D;new String(a,2,4)               &#x3D;&#x3D;&#x3D;&gt;String s&#x3D;new String(&quot;uden&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    (3).引用字符串常量来创建字符串变量</p><pre class="line-numbers language-none"><code class="language-none">String str1,str2;str1 &#x3D; &quot;We are students&quot;;str2 &#x3D; &quot;We are students&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：str1和str2引用相同的字符串常量，所以指向同一个实体所在的内存</strong></p><h4 id="6-连接字符串"><a href="#6-连接字符串" class="headerlink" title="6. 连接字符串"></a>6. 连接字符串</h4><p>使用”+”运算符可以实现连接多个字符串，”+”连接多个字符串后产生一个String对象<br><strong>注意：字符串也可以与其他基本数据类型连接，连接后这些数据将转化为字符串，当基本数据类型与字符串连接时会自动调用toString()方法将其转为字符串形式</strong></p><h4 id="7-获取字符串的长度"><a href="#7-获取字符串的长度" class="headerlink" title="7. 获取字符串的长度"></a>7. 获取字符串的长度</h4><p>​    使用String类型下的length()方法可以获取声明的字符串对象的长度</p><pre class="line-numbers language-none"><code class="language-none">str.length()      &#x2F;&#x2F;str为字符串对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    字符串的下标是0~length()-1</p><h4 id="8-字符串查找的方法"><a href="#8-字符串查找的方法" class="headerlink" title="8. 字符串查找的方法"></a>8. 字符串查找的方法</h4><p>(1).indexOf(String s)<br>返回值为int型，在里面填想要查找的字符串，返回整个字符串中第一次出现的这个字符串的第一个元素的数组下标对应的位置(索引位置)，如果没有检索到字符串s，则返回-1</p><pre class="line-numbers language-none"><code class="language-none">s.indexOf(the_str1)  &#x2F;&#x2F;字符用单(双)引号，字符串用双引号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    (2).lastIndexOf(String str)<br>​    返回值为int型，在里面填想要查找的字符串，返回整个字符串中最后一次出现的这个字符串的第一个元素的数组下标对应的位置(索引位置)，如果没有检索到字符串s，则返回-1</p><pre class="line-numbers language-none"><code class="language-none">str.lastIndexOf(the_str1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>注意：如果lastIndexOf方法中的参数是空字符串””，则返回结果和调用该字符串的length()方法返回结果相同，indexOf方法中的参数是空字符串””，则返回结果为0</strong></p><h4 id="9-获取指定索引位置的字符"><a href="#9-获取指定索引位置的字符" class="headerlink" title="9. 获取指定索引位置的字符"></a>9. 获取指定索引位置的字符</h4><p>​    使用charAt()方法，可以将指定索引处的字符返回</p><pre class="line-numbers language-none"><code class="language-none">str.charAt(int index)  &#x2F;&#x2F;返回值为char<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    注意：若索引值超出本身字符串的长度则报错</p><h4 id="10-字符串操作"><a href="#10-字符串操作" class="headerlink" title="10. 字符串操作"></a>10. 字符串操作</h4><p>​    (1).获取子字符串<br>​    通过String类下的substring()方法（两种方法重载），返回值String类型</p><ul><li>substring(int beginIndex)<br>​    从指定的索引位置开始截取直到该字符串结尾的子串，beginIndex指指定的索引位置<br>​    </li><li>substring(int beginIndex , int endIndex)<br>​      从字符串某一索引位置开始截取至某一索引位置结束的子串<br>​      <strong>注意：取得到第beginIndex这里的字符，取不到第endIndex这里的字符，即在这里结束</strong><pre class="line-numbers language-none"><code class="language-none">String s &#x3D; &quot;hello&quot;;String s1 &#x3D; s.substring(3);System.out.print(s1);&#x2F;&#x2F;输出：lo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​    (2).去除空格<br>​    通过trim()方法返回字符串的副本,作用是忽略前导空格和尾部空格,注意:字符串中间的空格不忽略,返回值为String</p><pre class="line-numbers language-none"><code class="language-none">str.trim()  &#x2F;&#x2F;str为字符串对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<br>​    (3).字符串替换<br>​    通过replace()方法来实现将指定的字符或者字符串替换成新的字符或字符串,返回值为String</p><pre class="line-numbers language-none"><code class="language-none">str.replace(char oldChar , char newChar)&#x2F;*oldChar:要替换的字符或字符串newChar:用于替换原来字符串的内容*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意:<br>​    [1].如果字符串oldChar没有出现在原字符串中,则将原字符串返回<br>​    [2].如果要替换的oldChar在原字符串中出现多次,则会被全部替换成newChar<br>​    [3].切记大小写是区分的</strong></p><p>​    (4).判断字符串以什么开头与结尾<br>​    [1].startsWith()方法<br>​    该方法用于判断当前字符串是否以指定的前缀开头，返回值为Boolean类型</p><pre class="line-numbers language-none"><code class="language-none">str.startsWith(String prefix)  &#x2F;&#x2F;prefix指作为前缀的字符或字符串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    [2].endsWith()方法<br>​    该方法用于判断当前字符串是否以指定的后缀结束，返回值为Boolean类型</p><pre class="line-numbers language-none"><code class="language-none">str.endsWith(String suffix)  &#x2F;&#x2F;suffix指作为后缀的字符或字符串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    (5).判断字符串是否相等<br>​    对于字符串的比较不可以使用’==’来进行判断，因为比较运算符是比较两个字符串的地址，即使字符串内容相同但地址也是不同的<br>​    通过equals()方法或者equalsIgnoreCase()方法<br>​    [1].equals()方法<br>​    如果两个字符串具有相同的字符和长度，返回值为ture，即返回值为Boolean类型<br>​    <strong>注意：equals()方法严格区分大小写</strong></p><pre class="line-numbers language-none"><code class="language-none">str.equals(String otherstr)  &#x2F;&#x2F;str和otherstr相比较<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    [2].equalsIgnoreCase()方法<br>​    在忽略字符串大小写的情况下比较字符串是否相等，返回值为Boolean类型</p><pre class="line-numbers language-none"><code class="language-none">str.equalsIgnoreCase(String otherstr)  &#x2F;&#x2F;str和otherstr相比较<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    (6).字符串分割<br>​    使用split()方法对给定原字符串指定的分割字符或分割字符串进行分割，将分割后的结果放在字符串数组中，返回值为字符串数组<br>​    [1].split(String sign)<br>​    对给定分隔符对字符串拆分</p><pre class="line-numbers language-none"><code class="language-none">str.split(String sign)  &#x2F;&#x2F;sign为分割符为String类型，即注意必须用&quot;&quot;,不能使用&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    [2].split(String sign,int limit)<br>​    对给定分隔符对字符串拆分，并限制拆分次数</p><pre class="line-numbers language-none"><code class="language-none">str.split(String sign,int limit)  &#x2F;&#x2F;sign为分割符为String类型，即注意必须用&quot;&quot;,不能使用&#39;&#39;,limit为分割次数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>注意：如果想定义多个分割符，可以使用’|’来隔开</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;如：str.split(&quot;+|&#x3D;&quot;)  &#x2F;&#x2F;以+和&#x3D;进行分割<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    (7).字符串开始前缀检测</p><p>​    使用startsWith()方法检测字符串是否以指定的前缀开始</p><pre class="line-numbers language-none"><code class="language-none">str.startsWith(String prefix)  &#x2F;&#x2F;返回值为布尔类型，输入前缀为String类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="11-格式化字符串"><a href="#11-格式化字符串" class="headerlink" title="11. 格式化字符串"></a>11. 格式化字符串</h4><pre><code>  String类的静态format()方法用于创建格式化字符串，返回值为String类型</code></pre><pre class="line-numbers language-none"><code class="language-none">String s &#x3D; String.format(&quot;转换符&quot;,变量); &#x2F;&#x2F;对变量进行格式化，变量参数只要是类类型就可以<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    与C语言中printf的转化类似</p><h4 id="12-了解"><a href="#12-了解" class="headerlink" title="12. 了解"></a>12. 了解</h4><p>​    (1).Date类来实现获取日期并通过格式化字符串来显示想要的数据<br>​    (2).正则表达式是用来检查某一字符串是否满足某一格式<br>​    (3).字符串生成器StringBuilder类，用来实现对字符串操作提高效率</p><h4 id="13-StringBuilder类与String类型的转换"><a href="#13-StringBuilder类与String类型的转换" class="headerlink" title="13. StringBuilder类与String类型的转换"></a>13. StringBuilder类与String类型的转换</h4><ul><li><p>将String类转为StringBuilder类(转为StringBuffer类同理)</p><pre class="line-numbers language-none"><code class="language-none">String s &#x3D; “xxxx”;StringBuilder sb &#x3D; new StringBuilder(s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>将StringBuilder类转为String类(StringBuffer类转String同理)</p><pre class="line-numbers language-none"><code class="language-none">StringBuilder s1 &#x3D; new StringBuilder(); &#x2F;&#x2F;初始化器里可以赋值String s &#x3D; s1.toString();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐小程序03</title>
      <link href="/2021/05/05/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F03/"/>
      <url>/2021/05/05/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F03/</url>
      
        <content type="html"><![CDATA[<h2 id="首页的编写"><a href="#首页的编写" class="headerlink" title="首页的编写"></a>首页的编写</h2><p><strong>1. 轮播图</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;block&gt;&lt;&#x2F;block&gt;组件作用：作为一个结点并不会渲染到界面上，一般把wx:for放在里面，循环中每个选项默认的值是item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>wxml代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;需要对swiper(大盒子)和image(小盒子)进行wxss大小的限定&lt;swiper autoplay&#x3D;&quot;true&quot; circular&#x3D;&quot;true&quot; indicator-dots&#x3D;&quot;true&quot; class&#x3D;&quot;head&quot;&gt;  &lt;block wx:for&#x3D;&quot;&#123;&#123;swiperpictures&#125;&#125;&quot;&gt;    &lt;swiper-item&gt;      &lt;image src&#x3D;&quot;&#123;&#123;item.url&#125;&#125;&quot; mode&#x3D;&quot;widthFix&quot; class&#x3D;&quot;swiperimg&quot;&gt;&lt;&#x2F;image&gt;  &#x2F;&#x2F;url是在js代码中自己定义的对象名    &lt;&#x2F;swiper-item&gt;  &lt;&#x2F;block&gt;&lt;&#x2F;swiper&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>wxss代码</p><pre class="line-numbers language-none"><code class="language-none">.head&#123;  width: 100%;  height: 544rpx;&#125;.swiperimg&#123;  width: 100%;  height: 100%;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在js中data里的数据就是需要展示在页面中的数据</strong><br>js代码</p><pre class="line-numbers language-none"><code class="language-none">data: &#123;&#x2F;&#x2F;建立一个数组swiperpictures    swiperpictures:[    &#x2F;&#x2F;每一个花括号里面是一个对象,对象名自己起      &#123;        &#x2F;&#x2F;对象里面放的是图片的网络地址        url:&quot;https:&#x2F;&#x2F;636c-cloud-7gxr9uz450402f24-1305716784.tcb.qcloud.la&#x2F;2020.jpg&quot;      &#125;,      &#123;        url:&quot;https:&#x2F;&#x2F;636c-cloud-7gxr9uz450402f24-1305716784.tcb.qcloud.la&#x2F;2020.jpg&quot;      &#125;,      &#123;        url:&quot;https:&#x2F;&#x2F;636c-cloud-7gxr9uz450402f24-1305716784.tcb.qcloud.la&#x2F;2020.jpg&quot;      &#125;    ]  &#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 组件化开发</strong><br>    (1)组件：在用户界面开发领域，组件是一种面向用户的、独立的、可复用的交互元素的封装<br>    (2)组件的构成<br>    结构-&gt;wxml<br>    逻辑-&gt;js<br>    样式-&gt;wxss<br>    还会有json文件（对当前组件的配置文件）<br>    (3)组件并不一定需要多次使用</p><p><strong>3. 自定义歌单组件</strong><br>​    <strong>(1)创建自定义组件</strong><br>​    在miniprogram中新建一个文件夹components(组件)，再在该文件夹下创建playlist(歌单)文件夹，再在该文件夹下创建component名字可以和文件夹相同<br>​    <strong>(2)自定义组件的引用</strong><br>​    首先要完成自定义组件的构成，如只在wxss中写一段话<br>​    在想要引用的页面的文件的json文件中”usingComponents”中写</p><pre class="line-numbers language-none"><code class="language-none">&quot;usingComponents&quot;: &#123;   &quot;l-playlist&quot;: &quot;..&#x2F;..&#x2F;components&#x2F;playlist&#x2F;playlist&quot;  &#x2F;&#x2F;前面是自己对组件起名，后面是写组件的路径，这个路径要精确到文件夹下的文件，不需要写后缀 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    之后就在引用组件的页面的wxml文件夹中引用标签名，标签名为你所起的名字<br>​    如，在home.wxml(首页)中引用</p><pre class="line-numbers language-none"><code class="language-none">&lt;l-playlist&gt;&lt;&#x2F;l-playlist&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​     <strong>(3).从页面向自定义组件传参</strong><br>​     在页面的js文件中的page下新建一个数组playlist_data，再在里面放一些对象(数据)</p><pre class="line-numbers language-none"><code class="language-none">playlist_data:[      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5c0174f1ca26f1d7b2&quot;,&quot;copywrier&quot;:&quot;热门推荐&quot;,&quot;playCount&quot;:1.4641238e+06,&quot;highQuality&quot;:false,&quot;type&quot;:0.0,&quot;canDislike&quot;:true,&quot;name&quot;:&quot;天气转热了，适合听点凉爽的歌。&quot;,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:36.746Z&quot;&#125;,&quot;id&quot;:2.780381322e+09,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;Biky7TE4CtW6NjGuqoUKZg&#x3D;&#x3D;&#x2F;109951164041827987.jpg&quot;,&quot;trackCount&quot;:53.0&#125;,      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5c0174f1da7aa357aa&quot;,&quot;highQuality&quot;:false,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;canDislike&quot;:true,&quot;playCount&quot;:622822.6,&quot;id&quot;:2.740107647e+09,&quot;name&quot;:&quot;「时空潜行」囿于昼夜的空想主义者&quot;,&quot;type&quot;:0.0,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:36.955Z&quot;&#125;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;Q0eS0avwGK04LufWM7qJug&#x3D;&#x3D;&#x2F;109951164116217181.jpg&quot;,&quot;trackCount&quot;:20.0&#125;,      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5c0174f1de21c7e79e&quot;,&quot;id&quot;:2.828842343e+09,&quot;type&quot;:0.0,&quot;name&quot;:&quot;粤语情诗：与你听风声，观赏过夜星&quot;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;K9IcG8cU6v4_SwuQ_x2xMA&#x3D;&#x3D;&#x2F;109951164124604652.jpg&quot;,&quot;highQuality&quot;:false,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;playCount&quot;:1.785097e+06,&quot;trackCount&quot;:52.0,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;canDislike&quot;:true,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:36.982Z&quot;&#125;&#125;,      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5d0174f1e67d1bb16f&quot;,&quot;playCount&quot;:7.719329e+06,&quot;highQuality&quot;:false,&quot;trackCount&quot;:950.0,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;id&quot;:9.17794768e+08,&quot;type&quot;:0.0,&quot;name&quot;:&quot;翻唱简史：日本四百首&quot;,&quot;canDislike&quot;:true,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:37.037Z&quot;&#125;,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;NczCuurE5eVvObUjssoGjQ&#x3D;&#x3D;&#x2F;109951163788653124.jpg&quot;&#125;,      &#123;&quot;_id&quot;:&quot;08560c9e5d042a5d0174f1ea32c4c288&quot;,&quot;type&quot;:0.0,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;highQuality&quot;:false,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-14T23:14:37.097Z&quot;&#125;,&quot;id&quot;:2.201879658e+09,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;playCount&quot;:1.06749088e+08,&quot;name&quot;:&quot;你的青春里有没有属于你的一首歌？&quot;,&quot;picUrl&quot;:&quot;https:&#x2F;&#x2F;p2.music.126.net&#x2F;wpahk9cQCDtdzJPE52EzJQ&#x3D;&#x3D;&#x2F;109951163271025942.jpg&quot;,&quot;canDislike&quot;:true,&quot;trackCount&quot;:169.0&#125;,      &#123;&quot;_id&quot;:&quot;08560c9e5d0829820362a79f4b049d2d&quot;,&quot;alg&quot;:&quot;cityLevel_unknow&quot;,&quot;name&quot;:&quot;「乐队的夏天」参赛歌曲合集丨EP04更新&quot;,&quot;highQuality&quot;:false,&quot;picUrl&quot;:&quot;http:&#x2F;&#x2F;p2.music.126.net&#x2F;2WE5C2EypEwLJd2qXFd4cw&#x3D;&#x3D;&#x2F;109951164086686815.jpg&quot;,&quot;trackCount&quot;:158.0,&quot;createTime&quot;:&#123;&quot;$date&quot;:&quot;2019-06-18T00:00:02.553Z&quot;&#125;,&quot;copywriter&quot;:&quot;热门推荐&quot;,&quot;playCount&quot;:1.5742008e+06,&quot;canDislike&quot;:true,&quot;id&quot;:2.79477263e+09,&quot;type&quot;:0.0&#125;    ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​      之后在该页面的wxml文件中，循环遍历这个控件的标签</p><pre class="line-numbers language-none"><code class="language-none">&lt;view&gt;   &#x2F;&#x2F;view标签是之后可以设计一些样式  &lt;block wx:for&#x3D;&quot;&#123;&#123;playlist_data&#125;&#125;&quot;&gt;    &lt;l-playlist send_data&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;l-playlist&gt;  &#x2F;&#x2F;send_data:将数据传出去,名字随便起的  &lt;&#x2F;block&gt;&lt;&#x2F;view&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>(4).在自定义组件中接收参数</strong><br>​    在自定义组件的js文件中<br>​    properties:{}是用来接收传过来的参数的</p><pre class="line-numbers language-none"><code class="language-none">properties: &#123;  &#x2F;&#x2F;冒号前的名字与之前页面自定义控件起的属性名一致  send_data:&#123;        type:Object  &#x2F;&#x2F;指定传入参数的类型，类型给与的是对象用object，其他值后面再定义      &#125;  &#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    data:{}里面放的是组件内部的数据<br>​    methods:{}里面放组件里对应的一些方法(如点击跳转)</p><p>​    <strong>(5).在组件中显示这些传过来的参数</strong><br>​    在组件的wxml文件中引用这些传过来的参数，通过在组件js的属性名来引用对象中具体的值</p><pre class="line-numbers language-none"><code class="language-none">&lt;view class&#x3D;&quot;playlist-content&quot;&gt;  &lt;image src&#x3D;&quot;&#123;&#123;send_data.picUrl&#125;&#125;&quot; class&#x3D;&quot;playlist-img&quot;&gt;&lt;&#x2F;image&gt;  &lt;text class&#x3D;&quot;playlist-playCount&quot;&gt;&#123;&#123;send_data.playCount&#125;&#125;&lt;&#x2F;text&gt;  &lt;view class&#x3D;&quot;playlist-name&quot;&gt;&#123;&#123;send_data.name&#125;&#125;&lt;&#x2F;view&gt;&lt;&#x2F;view&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    之后再通过组件的wxss文件来写一些css样式</p><pre class="line-numbers language-none"><code class="language-none">.playlist-content&#123;  width: 220rpx;  position: relative;  padding-bottom: 20rpx;&#125;.playlist-img&#123;  width: 100%;  height: 220rpx;  border-radius: 6rpx;&#125;.playlist-playCount&#123;  font-size: 24rpx;  color: white;  text-shadow: 1px 0px 0px black;  position: absolute;  right: 10rpx;  top: 4rpx;  padding-left: 26rpx;   background: ;   &#x2F;&#x2F;自行引入base64的图片&#125;.playlist-name&#123;  font-size: 26rpx;  line-height: 1.2;  padding: 2px 0px 0px;  display: -webkit-box;  -webkit-box-orient: vertical;  -webkit-line-clamp: 2;  overflow: hidden;  text-overflow: ellipsis;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：小程序中的背景图片是不允许使用网页图片的，只能使用小程序的本地图片，或者base64的图片(百度一下很多网站都可以在线把图片转base64)</strong><br>​    之后对控件在页面的位置再在页面的wxss中写一些布局(css)</p><pre class="line-numbers language-none"><code class="language-none">.home-playlist&#123;  display: flex;  flex-wrap: wrap;  justify-content: space-around;  margin-top: 10rpx;  flex-direction: row;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>(6).组件化开发的数据监听器</strong><br>​    当数据变化时可以监听到数据的变化<br>​    在组件的js文件中的properties的同级写一个数据监听器observers:{}</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;**   * 数据监听器   *&#x2F;  observers:&#123;  &#x2F;&#x2F;里面写对谁进行数据监听，对应的是一个方法    send_data(count)&#123;      console.log(count) &#x2F;&#x2F;此时打印出整个对象    &#125;        如果要监听对象里的某个具体属性，需要改为    [&#39;send_data.playCount&#39;](count)&#123;      console.log(count)    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>(7).对组件化开发监听器监听的数据的格式化处理</strong><br>​    在组件的js文件中的methods:{}中自己定义一个方法<br>​    注意：私有方法的命名格式以_开头</p><pre class="line-numbers language-none"><code class="language-none">methods: &#123;    _tranNumber(num,point)&#123;      let numStr &#x3D; num.toString().split(&#39;.&#39;)[0]   &#x2F;&#x2F;把数字转为字符串类型，并忽略小数点，split表分隔作用，[0]取第一部分      &#x2F;&#x2F;对数字转化      if(numStr.length &lt; 6)&#123;        return numStr      &#125;      &#x2F;&#x2F;substring(start,end)(得到的子字符串不包含end位置的字符)      else if(numStr.length &gt;&#x3D; 6 &amp;&amp; numStr.length &lt;&#x3D; 8)&#123;        let decimal &#x3D; numStr.substring(numStr.length - 4 ,numStr.length - 4 + point)         return parseFloat(parseInt(num &#x2F; 10000) + &quot;.&quot; + decimal) + &quot;万&quot;      &#125;      else if(numStr.length &gt; 8)&#123;        let decimal &#x3D; numStr.substring(numStr.length - 8 , numStr.length - 8 + point)        return parseFloat(parseInt(num &#x2F; 100000000) + &quot;.&quot; + decimal) + &quot;亿&quot;      &#125;    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>(7).通过this.setData的方式将处理的数据显示在页面上</strong><br>​    <strong>需要引用第二个值来接收处理完的数据，，因为如果继续给[‘send_data.playCount’]，那又会被数据监听器监听到会进入一个死循环,==即不能对当前监听的值进行赋值==</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 数据监听器 *&#x2F;observers:&#123;  [&#39;send_data.playCount&#39;](count)&#123;    console.log(count)    this.setData(&#123;      _count:this._tranNumber(count,2)  &#x2F;&#x2F;将处理后的数据赋值给刚刚声明的变量    &#125;)  &#125;&#125;,&#x2F;** * 组件的初始数据 *&#x2F;data: &#123;  _count:0   &#x2F;&#x2F;重新声明一个值来接收处理后的值&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    页面上应该显示_count的值，所以需要修改控件的wxml</p><pre class="line-numbers language-none"><code class="language-none">&lt;text class&#x3D;&quot;playlist-playCount&quot;&gt;&#123;&#123;_count&#125;&#125;&lt;&#x2F;text&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4. wx:key的使用</strong><br>​    在使用wx:for时，应该写入一个wx:key来提高程序的性能<br>​    <strong>(1).对于遍历时对于每个对象的重命名，通过wx:for-item来改名</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;将每一个对象重命名为data&lt;block wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; wx:for-item&#x3D;&quot;data&quot;&gt; &lt;view&gt;&#123;&#123;data&#125;&#125;&lt;&#x2F;view&gt;&lt;&#x2F;block&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>(2).索引的使用</strong><br>​    通过index来引用</p><pre class="line-numbers language-none"><code class="language-none">&lt;block wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; wx:for-item&#x3D;&quot;data&quot;&gt; &lt;view&gt;&#123;&#123;index&#125;&#125;:&#123;&#123;data&#125;&#125;&lt;&#x2F;view&gt;   &#x2F;&#x2F;使用索引，从0开始&lt;&#x2F;block&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    如果要更改索引的名字，通过wx:for-index来改名</p><pre class="line-numbers language-none"><code class="language-none">&lt;block wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; wx:for-item&#x3D;&quot;data&quot; wx:for-index&#x3D;&quot;idx&quot;&gt; &lt;view&gt;&#123;&#123;idx&#125;&#125;:&#123;&#123;data&#125;&#125;&lt;&#x2F;view&gt;   &#x2F;&#x2F;使用索引，从0开始&lt;&#x2F;block&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    <strong>(3).wx:key的作用</strong><br>​    <strong>当遍历的对象会随着一些变化而变化时，当前这些对象要保持自己的一些状态就需要使用wx:key</strong><br>​    小程序中提供*this来指向元素本身</p><pre class="line-numbers language-none"><code class="language-none">wx:key&#x3D;&quot;&#123;&#123;*this&#125;&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    如果指定的是对象的话，只需要指定对象的一个唯一的属性作为wx:key中两个花括号里的参数就行</p><p>​    因此，现在把项目中的一些警告修改一下</p><pre class="line-numbers language-none"><code class="language-none">遍历向组件传参时，此时_id为对象的主键，把他作为wx:key的参数&lt;block wx:for&#x3D;&quot;&#123;&#123;playlist_data&#125;&#125;&quot; wx:key&#x3D;&quot;_id&quot;&gt;遍历轮播图时，把轮播图图片的对象url作为wx:key的参数&lt;block wx:for&#x3D;&quot;&#123;&#123;swiperpictures&#125;&#125;&quot; wx:key&#x3D;&quot;url&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，警告都会消除</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java02</title>
      <link href="/2021/05/04/Java02/"/>
      <url>/2021/05/04/Java02/</url>
      
        <content type="html"><![CDATA[<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h4 id="1-if条件语句"><a href="#1-if条件语句" class="headerlink" title="1. if条件语句"></a>1. if条件语句</h4><pre class="line-numbers language-none"><code class="language-none">if()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>   if后面”()”内的值必须是boolean型的,若语句中仅有一条语句，则可以省略条件语句中的”{}”，书上说为增强程序可读性最好不要省略<br>   <strong>注意：if语句是从上到下执行，上面有满足条件就算下面满足条件也不执行</strong></p><h4 id="2-if-else与三元运算符的转化"><a href="#2-if-else与三元运算符的转化" class="headerlink" title="2. if~else与三元运算符的转化"></a>2. if~else与三元运算符的转化</h4><p>例：求绝对值</p><pre class="line-numbers language-none"><code class="language-none">if(a&gt;0)b &#x3D; a;elseb &#x3D; -a;可以转化为b &#x3D; a &gt; 0?a:-a; &#x2F;&#x2F;问号前面的表达式为真则返回问号与冒号之间的表达式，否则把冒号后面的表达式给b，注意：三元运算符是有一个返回值的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-switch多分支语句"><a href="#3-switch多分支语句" class="headerlink" title="3. switch多分支语句"></a>3. switch多分支语句</h4><pre class="line-numbers language-none"><code class="language-none">switch(表达式) &#x2F;*在JDK1.6以前常量值必须是整型或字符型，在JDK1.7中，常量值除了整型或字符型还可以是字符串类型，注意常量值绝对不能是实数，如1.1就不行*&#x2F;&#123;注意：同一个switch语句，case的常量值必须不互相同case 常量值1:语句块1;break;...case 常量值n:语句块n;break;default:语句块n+1; &#x2F;&#x2F;default不需要break&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-while循环语句-先判断再执行"><a href="#4-while循环语句-先判断再执行" class="headerlink" title="4. while循环语句(先判断再执行)"></a>4. while循环语句(先判断再执行)</h4><pre class="line-numbers language-none"><code class="language-none">while(条件表达式)&#123;  &#x2F;&#x2F;条件表达式返回值为真继续循环，为假退出循环执行语句&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-do…while循环语句-先执行再判断"><a href="#5-do…while循环语句-先执行再判断" class="headerlink" title="5. do…while循环语句(先执行再判断)"></a>5. do…while循环语句(先执行再判断)</h4><pre class="line-numbers language-none"><code class="language-none">do&#123;执行语句&#125;while(条件表达式);  &#x2F;&#x2F;注意这里是比while循环多一个分号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-for循环语句"><a href="#6-for循环语句" class="headerlink" title="6. for循环语句"></a>6. for循环语句</h4><p>与c一样<br><strong>注意：for循环里第一个表达式里是填初始化表达式，可以为空，但不可以直接填一个变量(不管什么类型)，哪怕这个变量前面已经定义赋值</strong></p><pre class="line-numbers language-none"><code class="language-none">for(i;i&lt;12;i++) &#x2F;&#x2F;错误的，i因改为i&#x3D;0，若i是已经定义赋值的这个第一个表达式也可以直接为空不写东西<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-foreach语句"><a href="#7-foreach语句" class="headerlink" title="7. foreach语句"></a>7. foreach语句</h4><p>foreach是for语句的特殊简化版本，不能完全取代for语句，任何foreach语句都可以改写为for语句版本，foreach语句一般用于遍历数组等方面,在这种方面给与程序员很大的方便</p><pre class="line-numbers language-none"><code class="language-none">for(元素变量x:遍历对象obj)&#123;引用了x的java语句;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例：输出一维数组中全部元素</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String args[]) &#123;int[] arr &#x3D; &#123;3,5,7,4&#125;;for(int x:arr) &#123;System.out.println(x);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-循环控制"><a href="#8-循环控制" class="headerlink" title="8. 循环控制"></a>8. 循环控制</h4><p>(1).break<br>中断循环<br><strong>注意：break只能跳出一层循环，如果想直接跳到外层的循环，可以使用“标签”(java提供的功能)</strong></p><pre class="line-numbers language-none"><code class="language-none">标签名:循环体&#123;break 标签名;  &#x2F;&#x2F;直接跳出有标签名的循环&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(2).continue<br>跳过本次循环执行下一次循环<br>**注意：continue也支持标签功能</p><pre class="line-numbers language-none"><code class="language-none">标签名:循环体&#123;continue 标签名;  &#x2F;&#x2F;直接跳出有标签名的循环&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图灵工作室05</title>
      <link href="/2021/05/03/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A405/"/>
      <url>/2021/05/03/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A405/</url>
      
        <content type="html"><![CDATA[<p>在app.json中配置全局的属性，pages为你要的页面的种类，window为标题栏的样式。<br>配置下标栏关键字为tabBar，在这里面有list属性用来进行编写（最少是两个，最多不能超过五个）</p><pre class="line-numbers language-none"><code class="language-none">&quot;tabBar&quot;: &#123;&quot;color&quot;:&quot;#474747&quot;,           &#x2F;&#x2F;文字未选中时的颜色&quot;selectedColor&quot;:&quot;#d43c43&quot;    &#x2F;&#x2F;文字选中时的颜色    &quot;list&quot;: [&#123;      &quot;pagePath&quot;: &quot;pages&#x2F;home-page&#x2F;home-page&quot;,    &#x2F;&#x2F;页面路径      &quot;text&quot;: &quot;首页&quot;,                             &#x2F;&#x2F;页面下面名字      &quot;iconPath&quot;: &quot;.&#x2F;pages&#x2F;image&#x2F;icon-home-normal.png&quot;,  &#x2F;&#x2F;未点击时图标样式      &quot;selectedIconPath&quot;: &quot;.&#x2F;pages&#x2F;image&#x2F;icon-home-primary.png&quot; &#x2F;&#x2F;&#x2F;点击时图标样式    &#125;,    ...    ]&#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>js里不要随意加，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图灵工作室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐小程序02</title>
      <link href="/2021/05/03/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F02/"/>
      <url>/2021/05/03/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F02/</url>
      
        <content type="html"><![CDATA[<h2 id="云开发的基本环境的配置"><a href="#云开发的基本环境的配置" class="headerlink" title="云开发的基本环境的配置"></a>云开发的基本环境的配置</h2><p><strong>1. 在miniprogram文件下的app.js中有一个onLaunch生命周期函数(当小程序运行时自动调用 这个生命周期函数)</strong></p><pre class="line-numbers language-none"><code class="language-none">onLaunch: function () &#123;&#x2F;&#x2F;首先检查是否支持云开发，之后再看基础库的版本(在详情中的本地设置里可以选择调试基础库的版本，最低2.2.3)    if (!wx.cloud) &#123;      console.error(&#39;请使用 2.2.3 或以上的基础库以使用云能力&#39;)    &#125; else &#123;      wx.cloud.init(&#123;        &#x2F;&#x2F; env 参数说明：        &#x2F;&#x2F;   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源        &#x2F;&#x2F;   此处请填入环境 ID, 环境 ID 可打开云控制台查看        &#x2F;&#x2F;   如不填则使用默认环境（第一个创建的环境）        &#x2F;&#x2F;env是环境的意思，这里填环境的id(id在云开发控制台里找)        env: &#39;cloud-7gxr9uz450402f24&#39;, &#x2F;&#x2F;已将环境改为第一环境cloud的环境id        &#x2F;&#x2F;在云开发的控制台中可以观察到访问过小程序的用户(为true时)，以倒叙方式显示        traceUser: true,      &#125;)    &#125;&#x2F;&#x2F;当前小程序全局的属性和方法    this.globalData &#x3D; &#123;&#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 在miniprogram文件下的app.json文件</strong><br>在当前项目下的全局的配置文件<br><strong>注意在.json文件下是不能写注释的，写的话会报错</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;&#x2F;&#x2F;pages即当前项目的文件的路径，这些是默认的一会删掉  &quot;pages&quot;: [    &quot;pages&#x2F;index&#x2F;index&quot;,    &quot;pages&#x2F;getOpenId&#x2F;index&quot;,    &quot;pages&#x2F;getMiniProgramCode&#x2F;index&quot;,    &quot;pages&#x2F;deployService&#x2F;index&quot;,    &quot;pages&#x2F;createCollection&#x2F;index&quot;,    &quot;pages&#x2F;uploadFile&#x2F;index&quot;,    &quot;pages&#x2F;selectRecord&#x2F;index&quot;,    &quot;pages&#x2F;updateRecord&#x2F;index&quot;,    &quot;pages&#x2F;updateRecordResult&#x2F;index&quot;,    &quot;pages&#x2F;updateRecordSuccess&#x2F;index&quot;,    &quot;pages&#x2F;sumRecord&#x2F;index&quot;,    &quot;pages&#x2F;sumRecordResult&#x2F;index&quot;  ],  &#x2F;&#x2F;window对于窗口的配置  &quot;window&quot;: &#123;    &quot;backgroundColor&quot;: &quot;#F6F6F6&quot;,    &quot;backgroundTextStyle&quot;: &quot;light&quot;,    &quot;navigationBarBackgroundColor&quot;: &quot;#F6F6F6&quot;,  &#x2F;&#x2F;导航栏的颜色    &quot;navigationBarTitleText&quot;: &quot;云开发 QuickStart&quot;, &#x2F;&#x2F;导航栏的标题字体    &quot;navigationBarTextStyle&quot;: &quot;black&quot; &#x2F;&#x2F;导航栏标题字体的颜色  &#125;,  &#x2F;&#x2F;小程序的一些内部搜索，它还有自己的配置文件  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,  &quot;style&quot;: &quot;v2&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.  在miniprogram文件下的app.wxss文件</strong><br>自带的一些全局的样式，在视频中全部删掉了</p><p><strong>4.  在miniprogram文件下的README.md文件</strong><br>可以写一些对于自己微信小程序的说明</p><p><strong>5.  在miniprogram文件下的project.config.json文件</strong><br>当前小程序的项目的配置文件</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &#x2F;&#x2F;小程序前端部分的代码，与前面那个miniprogram文件夹是相对应的  &quot;miniprogramRoot&quot;: &quot;miniprogram&#x2F;&quot;,   &#x2F;&#x2F;小程序开发云函数的文件路径，名字也是与云函数的文件夹相对应  &quot;cloudfunctionRoot&quot;: &quot;cloudfunctions&#x2F;&quot;,  &quot;setting&quot;: &#123;    &quot;urlCheck&quot;: true,    &quot;es6&quot;: true,    &quot;enhance&quot;: true,    &quot;postcss&quot;: true,    &quot;preloadBackgroundData&quot;: false,    &quot;minified&quot;: true,    &quot;newFeature&quot;: true,    &quot;coverView&quot;: true,    &quot;nodeModules&quot;: false,    &quot;autoAudits&quot;: false,    &quot;showShadowRootInWxmlPanel&quot;: true,    &quot;scopeDataCheck&quot;: false,    &quot;uglifyFileName&quot;: false,    &quot;checkInvalidKey&quot;: true,    &quot;checkSiteMap&quot;: true,    &quot;uploadWithSourceMap&quot;: true,    &quot;compileHotReLoad&quot;: false,    &quot;useMultiFrameRuntime&quot;: true,    &quot;useApiHook&quot;: true,    &quot;useApiHostProcess&quot;: false,    &quot;babelSetting&quot;: &#123;      &quot;ignore&quot;: [],      &quot;disablePlugins&quot;: [],      &quot;outputPath&quot;: &quot;&quot;    &#125;,    &quot;enableEngineNative&quot;: false,    &quot;useIsolateContext&quot;: true,    &quot;useCompilerModule&quot;: true,    &quot;userConfirmedUseCompilerModuleSwitch&quot;: false,    &quot;userConfirmedBundleSwitch&quot;: false,    &quot;packNpmManually&quot;: false,    &quot;packNpmRelationList&quot;: [],    &quot;minifyWXSS&quot;: true  &#125;,  &quot;appid&quot;: &quot;wx466a6c8b6726bf3d&quot;,  &quot;projectname&quot;: &quot;%E4%B8%80%E8%B5%B7%E5%90%AC%E4%B8%80%E5%90%AC&quot;,  &quot;libVersion&quot;: &quot;2.14.1&quot;,  &quot;cloudfunctionTemplateRoot&quot;: &quot;cloudfunctionTemplate&quot;,  &quot;condition&quot;: &#123;    &quot;search&quot;: &#123;      &quot;list&quot;: []    &#125;,    &quot;conversation&quot;: &#123;      &quot;list&quot;: []    &#125;,    &quot;plugin&quot;: &#123;      &quot;list&quot;: []    &#125;,    &quot;game&quot;: &#123;      &quot;list&quot;: []    &#125;,    &quot;miniprogram&quot;: &#123;      &quot;list&quot;: [        &#123;          &quot;id&quot;: -1,          &quot;name&quot;: &quot;db guide&quot;,          &quot;pathName&quot;: &quot;pages&#x2F;databaseGuide&#x2F;databaseGuide&quot;        &#125;      ]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>6. 后记(代码规范)</strong><br>    一般每一个公司都会有自己的代码规范，为了沟通也需要去遵守代码规范<br>    (1).一般使用let和const来定义变量和常量，而不用var<br>    因为var的作用域太大，所以可能会造成不安全<br>    (2).当我们在定义变量时一般之间用大括号来定义,可以像面向对象那样使用new，但还是用大括号，数组也是一样的用中括号来直接定义<br>    如</p><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123;&#125;  &#x2F;&#x2F;定义对象,每一个对象的属性后面最好都加,哪怕最后一个const arr &#x3D; []  &#x2F;&#x2F;定义数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>(3).对于生命周期函数系统的默认的定义方式是</code></pre><pre class="line-numbers language-none"><code class="language-none">onLoad:function(options)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>还可以写成这样(建议这样去写)</code></pre><pre class="line-numbers language-none"><code class="language-none">onLoad()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐小程序01</title>
      <link href="/2021/05/03/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F01/"/>
      <url>/2021/05/03/%E9%9F%B3%E4%B9%90%E5%B0%8F%E7%A8%8B%E5%BA%8F01/</url>
      
        <content type="html"><![CDATA[<ol><li>使用Severless(无服务开发)进行小程序的云开发（核心思想函数即服务）<br>后端和服务器之间的物理隔离可以通过云端化来解除隔离<br>前端和服务器之间的物理隔离通过http的协议来解除</li></ol><p><strong>什么是severless</strong><br>severless完全解决前端&lt;—&gt;服务器&lt;—&gt;后端之间的隔离<br>severless的服务器是在云上的<br>2. 小程序的云开发<br>传统模式：小程序端发送请求给后端，前端和后端工程师沟通使用接口<br><a href="https://imgtu.com/i/gmheLq"><img src="https://z3.ax1x.com/2021/05/03/gmheLq.png" alt="gmheLq.png"></a></p><ol start="3"><li>云开发的优势</li></ol><ul><li>快速上线</li><li>专注核心业务（无需考虑前后端沟通问题和运维的问题）</li><li>可以独立开发一个完整的微信小程序</li><li>不需要新的语言，只需要掌握js</li></ul><ol start="4"><li><p>云开发的能力<br>云函数：在云端运行的代码<br>云数据库：可以在小程序端操作，也可以在云函数中操作的JSON数据库（与关系数据库（sql server）不一样）<br>云存储：云端存储文件<br>云调用：基于云函数免鉴权使用小程序开放接口的能力<br>HTTP API：使用HTTP API开发者可以在已有服务器上访问云资源实现与云开发的互通</p></li><li><p>实践注册云开发微信小程序<br>在微信中每个小程序给与用户两个免费云开发环境，实际中可以给一个为正式环境（上线），一个是测试环境，进入一个另一个需要再次注册</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java01</title>
      <link href="/2021/05/02/Java01/"/>
      <url>/2021/05/02/Java01/</url>
      
        <content type="html"><![CDATA[<h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h2><h4 id="1-java中文件名和类名必须同名，注意：java是严格区分大小写"><a href="#1-java中文件名和类名必须同名，注意：java是严格区分大小写" class="headerlink" title="1. java中文件名和类名必须同名，注意：java是严格区分大小写"></a>1. java中文件名和类名必须同名，注意：java是严格区分大小写</h4><h4 id="2-类属性称为类的全局变量，方法中的属性称为局部变量"><a href="#2-类属性称为类的全局变量，方法中的属性称为局部变量" class="headerlink" title="2. 类属性称为类的全局变量，方法中的属性称为局部变量"></a>2. 类属性称为类的全局变量，方法中的属性称为局部变量</h4><h4 id="3-Java中通过import关键字导入相关的类"><a href="#3-Java中通过import关键字导入相关的类" class="headerlink" title="3. Java中通过import关键字导入相关的类"></a>3. Java中通过import关键字导入相关的类</h4><h4 id="4-long型的值，若赋给的值大于int型的最大值或者小于int型的最小值，则需要在数字后面加L或l表示该数值为长整数"><a href="#4-long型的值，若赋给的值大于int型的最大值或者小于int型的最小值，则需要在数字后面加L或l表示该数值为长整数" class="headerlink" title="4. long型的值，若赋给的值大于int型的最大值或者小于int型的最小值，则需要在数字后面加L或l表示该数值为长整数"></a>4. long型的值，若赋给的值大于int型的最大值或者小于int型的最小值，则需要在数字后面加L或l表示该数值为长整数</h4><h4 id="5-默认情况下小数被看作double型，若使用float型需要在小数后面加F或f，声明为float型变量时若不加f默认为double型"><a href="#5-默认情况下小数被看作double型，若使用float型需要在小数后面加F或f，声明为float型变量时若不加f默认为double型" class="headerlink" title="5. 默认情况下小数被看作double型，若使用float型需要在小数后面加F或f，声明为float型变量时若不加f默认为double型"></a>5. 默认情况下小数被看作double型，若使用float型需要在小数后面加F或f，声明为float型变量时若不加f默认为double型</h4><h4 id="6-char（字符类型）：用于存储单个字符，占两个字节的存储空间"><a href="#6-char（字符类型）：用于存储单个字符，占两个字节的存储空间" class="headerlink" title="6. char（字符类型）：用于存储单个字符，占两个字节的存储空间"></a>6. char（字符类型）：用于存储单个字符，占两个字节的存储空间</h4><h4 id="7-常量声明：用final关键字"><a href="#7-常量声明：用final关键字" class="headerlink" title="7. 常量声明：用final关键字"></a>7. 常量声明：用final关键字</h4><p>​    语法：final 数据类型 常量名称[=值]<br>​    常量名通常使用大写字母<br>​    final变量属于“成员变量”时，必须在定义时就设定它的初值<br>​    常量一经赋值不给改变</p><h4 id="8-成员变量与局部变量-根据变量的有效范围划定"><a href="#8-成员变量与局部变量-根据变量的有效范围划定" class="headerlink" title="8. 成员变量与局部变量(根据变量的有效范围划定)"></a>8. 成员变量与局部变量(根据变量的有效范围划定)</h4><p>​    (1).成员变量<br>​    在类体中定义的变量，成员变量又可以分为静态变量和实例变量<br>​    静态变量是在类型前面加关键字static，<strong>静态变量的有效范围可以跨类，达到整个应用程序内，通过类名.静态变量的方式在其他类中使用</strong><br>​    实例变量是实例化后可以使用<br>​<br>​    (2).局部变量<br>​    在类的方法体中定义的变量，局部变量只在当前代码块中有效<br>​    当方法被调用时，Java虚拟机为方法中的局部变量分配内存空间<br>​    局部变量可以与成员变量的名字相同，此时成员变量将被隐藏</p><h4 id="9-进行除法运算时，0不能做除数，系统会抛出ArithmeticException异常"><a href="#9-进行除法运算时，0不能做除数，系统会抛出ArithmeticException异常" class="headerlink" title="9. 进行除法运算时，0不能做除数，系统会抛出ArithmeticException异常"></a>9. 进行除法运算时，0不能做除数，系统会抛出ArithmeticException异常</h4><h4 id="10-逻辑运算符的操作元必须是Boolean型的变量"><a href="#10-逻辑运算符的操作元必须是Boolean型的变量" class="headerlink" title="10. 逻辑运算符的操作元必须是Boolean型的变量"></a>10. 逻辑运算符的操作元必须是Boolean型的变量</h4><h4 id="11-位运算符"><a href="#11-位运算符" class="headerlink" title="11. 位运算符"></a>11. 位运算符</h4><p>​    位运算符除”按位与’’和”按位或”运算符外，其他只能用于处理整数的操作符<br>​    (1).“按位与”运算(&amp;):双目<br>​    运算法则：如果两个整型数据a,b的对应位都是1，则结果为1，否则为0；如果两个操作数精度不同，则结果的精度与精度高的操作数相同<br>​    (2).”按位或”运算(|):双目<br>​    运算法则：如果两个操作数的对应位都是0，则结果为0，否则为1；如果两个操作数精度不同，则结果的精度与精度高的操作数相同<br>​    (3).”按位取反”运算(~):单目<br>​    运算法则：将操作数二进制中的1改为0，0改为1<br>​    (4).”按位异或”运算(^):双目<br>​    运算法则：当两个操作数的二进制表示对应位相同时，结果为0，反之结果为1；如果两个操作数精度不同，则结果的精度与精度高的操作数相同<br>​    (5).位移操作</p><pre class="line-numbers language-none"><code class="language-none">&lt;&lt;:左移 &#x2F;&#x2F;将运算符左边的二进制数据，按照运算符右边操作数指定的位数向左移动移空的部分补0&gt;&gt;:右移 &#x2F;&#x2F;将运算符左边的二进制数据，按照运算符右边操作数指定的位数向右移动，如果最高位是0，右移空的位就填入0；如果最高位是1，右移空的位就填入1；右移时右边最低位被抛弃&gt;&gt;&gt;:无符号右移 &#x2F;&#x2F;无论最高位是0还是1，左侧被移动的高位都填入0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：位移可以实现整数乘以或者除以2^n^的效果；如y&lt;&lt;2与y*4结果相同；y&gt;&gt;1的结果与y/2效果相同，即一个数左移n位，则将数乘以2^n^，一个数右移n位，就是将数除以2^n^</strong></p><p>​    <strong>(6).按位操作符在程序设计中具有以下几种用法</strong><br>​    <strong>按位与</strong>运算有两种典型用法，一是取一个位串信息的某几位，如以下代码截取x的最低7位：x &amp; 0177。二是让某变量保留某几位，其余位置0，如以下代码让x只保留最低6位：x = x &amp; 077。以上用法都先要设计好一个常数，该常数只有需要的位是1，不需要的位是0。用它与指定的位串信息按位与。<br>​    <strong>按位或</strong>运算的典型用法是将一个位串信息的某几位置成1。如将要获得最右4为1，其他位与变量j的其他位相同，可用逻辑或运算017|j。若要把这结果赋给变量j，可写成：<br>  j = 017|j<br>​    <strong>异或运算符</strong>可以交换连个变量，如</p><pre class="line-numbers language-none"><code class="language-none">想将ａ和ｂ的值互换，可以用以下赋值语句实现：    ａ＝a∧b;    ｂ＝b∧a;    ａ＝a∧b;ａ＝011(2)    （∧）ｂ＝100(2)ａ＝111(2)（a∧b的结果，a已变成７）    （∧）ｂ＝100(2)ｂ＝011(2)（b∧a的结果，b已变成３）    （∧）ａ＝111(2)ａ＝100（2）（a∧b的结果，a已变成４）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-在编写程序时尽量使用括号运算符来限定次序"><a href="#12-在编写程序时尽量使用括号运算符来限定次序" class="headerlink" title="12. 在编写程序时尽量使用括号运算符来限定次序"></a>12. 在编写程序时尽量使用括号运算符来限定次序</h4><h4 id="13-数据类型转换"><a href="#13-数据类型转换" class="headerlink" title="13. 数据类型转换"></a>13. 数据类型转换</h4><p>​    (1)隐式类型转换<br>​    低级类型向高级类型的转换，系统自动执行，无须程序员操作<br>​    基本数据类型按精度从低到高的排序<br>​    byte&lt;short&lt;int&lt;long&lt;float&lt;double<br>​    如：</p><pre class="line-numbers language-none"><code class="language-none">short a &#x3D; 5;int b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    (2)显式类型转换<br>​    高精度的变量的值赋给低精度的变量时，必须使用显式类型的转换运算(又称强制类型转换)<br>​    语法：(类型名)要转换的值<br>​    如：</p><pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 5;short b &#x3D; (short)a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <strong>注意：强制类型转换可能会导致精度丢失，除boolean类型以外的其他基本类型，都能以显式类型的方法实现转换</strong></p><h4 id="14-代码注释与编码规范"><a href="#14-代码注释与编码规范" class="headerlink" title="14. 代码注释与编码规范"></a>14. 代码注释与编码规范</h4><pre class="line-numbers language-none"><code class="language-none">(1).单行注释：&#x2F;&#x2F;(2).多行注释：&#x2F;*   *&#x2F;(3).文档注释：&#x2F;**  *&#x2F; 与多行注释格式相同，用在声明之前时会被Javadoc文档工具读取作为文档内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    <strong>注意：可读性第一，效率第二，注释要占程序代码总量的20%~50%</strong></p><h4 id="15-注意：Java语言的基本数据类型中并没有String类型"><a href="#15-注意：Java语言的基本数据类型中并没有String类型" class="headerlink" title="15. 注意：Java语言的基本数据类型中并没有String类型"></a><strong>15. 注意：Java语言的基本数据类型中并没有String类型</strong></h4><h4 id="16-main方法"><a href="#16-main方法" class="headerlink" title="16. main方法"></a>16. main方法</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;程序入口的main方法(必须有这个程序才能运行)public static void main(String[] args) &#123;&#x2F;&#x2F;方法体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    当运行程序的时候，通常都是以程序入口的main方法作为起点，以main方法中的第一条语句作为程序的第一条语句。由于main方法是一个静态的方法，所以该方法放在任何一个类中都是可以执行的<br>​    写好一个类后，可以直接在该类中添加一个main方法，对该类的功能进行测试(Java允许多个main方法在不同的类中，程序启动时，需要指定哪一个main作为入口，一般光标在哪哪就是)<br>​    main方法是可以重载的，每个main方法的参数都是不同的，程序是可以运行的，可以输出应有的结果。但是，如果没有程序入口的main方法，只含有其他main方法。虽然编译此程序是可以的通过的，但是运行时会产生错误。这是因为程序运行时，Java虚拟机找不到对应的main方法，就会产生运行错误，其他main方法需要在入口main方法中进行调用才会运行<br>​    main方法也是可以被继承的，可以被重写</p><h4 id="17-一个文件只能一个public-类，而且类名必须和文件名一样"><a href="#17-一个文件只能一个public-类，而且类名必须和文件名一样" class="headerlink" title="17. 一个文件只能一个public 类，而且类名必须和文件名一样"></a>17. 一个文件只能一个public 类，而且类名必须和文件名一样</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2021/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络编程的概念"><a href="#1-网络编程的概念" class="headerlink" title="1.网络编程的概念"></a>1.网络编程的概念</h2><p>像邮件需要对方的邮编，对方的地址，对方的姓名，自己的地址，自己的姓名<br>即对方的信息，对方的地址，自己的地址</p><p>打电话，连接-接了-通话   TCP连接<br>发短信，-发送就完事了-接收  UDP连接</p><h2 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2.计算机网络"></a>2.计算机网络</h2><p><strong>概念：计算机网络是指将==地理位置==不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</strong></p><p>你的计算机没有与外界沟通，实现资源共享和信息传递那就是单机</p><h2 id="3-网络编程的目的"><a href="#3-网络编程的目的" class="headerlink" title="3.网络编程的目的"></a>3.网络编程的目的</h2><p>无线电台：传播交流信息    ；进行了数据交换，通信</p><h2 id="4-想要打到达到这个效果需要什么"><a href="#4-想要打到达到这个效果需要什么" class="headerlink" title="4.想要打到达到这个效果需要什么"></a>4.想要打到达到这个效果需要什么</h2><ul><li>如何准确定位网络上的一台主机？</li></ul><p>192.168.16.124，即端口号，你的和他的；定位到计算机上的某个应用</p><ul><li>找到了主机，如何传输数据？<br>需要介质<h2 id="5-网络编程与javaweb的区别"><a href="#5-网络编程与javaweb的区别" class="headerlink" title="5.网络编程与javaweb的区别"></a>5.网络编程与javaweb的区别</h2>网络编程：TCP/IP   C/S架构   客户端<br>javaweb：网页编程   B/S架构   浏览器</li></ul><h2 id="6-如何实现网络通信-网络通信的要素"><a href="#6-如何实现网络通信-网络通信的要素" class="headerlink" title="6.如何实现网络通信(网络通信的要素)"></a>6.如何实现网络通信(网络通信的要素)</h2><ol><li><p>通信双方的地址<br> IP：稀缺<br> 端口号：局域网<br> IP加端口可以：网络定位到一个具体的计算机</p></li><li><p>规则：网络通信的协议<br>HTTP(超文本传输协议):HTTP是基于B/S架构进行通信的，<br>ftp(文件传输协议)<br>SMTP(电子邮件传输的协议)<br>tcp(基于字节流的传输层通信协议):是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议<br>udp(用户数据报协议):UDP协议与TCP协议一样用于处理数据包</p></li><li><p>tcp/IP模型一个七层一个四层</p></li><li><p>小结<br> (1).网络编程中有两个主要的问题</p><ul><li><p>如何准确的定位到网络上的一台或多台主机<br>例如<br>打开cmd，输入ping <a href="http://www.bajdu.com,www是域名ping命令/">www.bajdu.com，www是域名ping命令</a><br>会弹出百度的IP地址</p><p>(2).找到主机之后如何进行通信 </p></li><li><p>IP和端口号</p></li><li><p>网络通信协议</p><p>(3).对于Java的学习<br>在Java中万物皆对象<br>要学习IP的类，端口的类<br>学习udp，tcp的一些类</p></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图灵工作室04</title>
      <link href="/2021/04/18/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A404/"/>
      <url>/2021/04/18/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A404/</url>
      
        <content type="html"><![CDATA[<h2 id="底端固定的方式-css"><a href="#底端固定的方式-css" class="headerlink" title="底端固定的方式(css)"></a>底端固定的方式(css)</h2><p>position: fixed; //固定定位<br>bottom: 0;  //0表示底部</p><p><strong>注意：line-height为行高，当行高等于行的高度时，里面的东西居中,用于文字</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图灵工作室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-商品页面</title>
      <link href="/2021/04/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%95%86%E5%93%81%E9%A1%B5%E9%9D%A2/"/>
      <url>/2021/04/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%95%86%E5%93%81%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h3><pre class="line-numbers language-none"><code class="language-none">&lt;swiper class&#x3D;&quot;myswiper&quot; bindchange&#x3D;&quot;changeImg&quot; indicator-dots&#x3D;&quot;ture&quot; autoplay&#x3D;&quot;ture&quot; circular&#x3D;&quot;ture&quot;&gt;  &lt;swiper-item&gt;    &lt;image class&#x3D;&quot;picture&quot; mode&#x3D;&quot;widthFix&quot; src&#x3D;&quot;https:&#x2F;&#x2F;6e61-navicat-3g86zpey3c832d18-1304777099.tcb.qcloud.la&#x2F;租借图片&#x2F;毕业季.jpg&quot;&gt;&lt;&#x2F;image&gt;  &lt;&#x2F;swiper-item&gt;  &lt;swiper-item&gt;    &lt;image class&#x3D;&quot;picture&quot; mode&#x3D;&quot;widthFix&quot; src&#x3D;&quot;https:&#x2F;&#x2F;6e61-navicat-3g86zpey3c832d18-1304777099.tcb.qcloud.la&#x2F;%E5%95%86%E5%93%81%E5%9B%BE%E7%89%87&#x2F;%E7%94%B5%E8%84%91&#x2F;apple.jpg&quot;&gt;&lt;&#x2F;image&gt;  &lt;&#x2F;swiper-item&gt;  &lt;swiper-item&gt;    &lt;image class&#x3D;&quot;picture&quot; mode&#x3D;&quot;widthFix&quot; src&#x3D;&quot;https:&#x2F;&#x2F;6e61-navicat-3g86zpey3c832d18-1304777099.tcb.qcloud.la&#x2F;%E5%95%86%E5%93%81%E5%9B%BE%E7%89%87&#x2F;%E7%94%B5%E8%84%91&#x2F;hw1.jpg?sign&#x3D;fee0f936bbe930fb6d94b51747d7a213&amp;t&#x3D;1618020235&quot;&gt;&lt;&#x2F;image&gt;  &lt;&#x2F;swiper-item&gt;&lt;&#x2F;swiper&gt;&lt;view class&#x3D;&quot;parent&quot;&gt;  &lt;view class&#x3D;&quot;color1&quot;&gt;    &lt;view class&#x3D;&quot;text1&quot;&gt;      &lt;view class&#x3D;&quot;money&quot;&gt;￥&#123;&#123;price&#125;&#125;&lt;&#x2F;view&gt;    &lt;&#x2F;view&gt;    &lt;view class&#x3D;&quot;text2&quot;&gt;      &lt;view class&#x3D;&quot;people&quot;&gt;0人买过&lt;&#x2F;view&gt;    &lt;&#x2F;view&gt;  &lt;&#x2F;view&gt;  &lt;view class&#x3D;&quot;color2&quot;&gt;    &lt;view class&#x3D;&quot;text3&quot;&gt;      &lt;view class&#x3D;&quot;apple&quot;&gt;&#123;&#123;shopname&#125;&#125;&lt;&#x2F;view&gt;    &lt;&#x2F;view&gt;    &lt;view class&#x3D;&quot;text4&quot;&gt;      &lt;view class&#x3D;&quot;apple_computer&quot;&gt;这是&#123;&#123;shopname&#125;&#125;&lt;&#x2F;view&gt;    &lt;&#x2F;view&gt;  &lt;&#x2F;view&gt;&lt;&#x2F;view&gt;&lt;view class&#x3D;&quot;bottom&quot;&gt;  &lt;view class&#x3D;&quot;bottom_picture1&quot;&gt;    &lt;view&gt;      &lt;image class&#x3D;&quot;server&quot; src&#x3D;&quot;..&#x2F;image&#x2F;icon-question.png&quot; mode&#x3D;&quot;widthFix&quot;&gt;&lt;&#x2F;image&gt;    &lt;&#x2F;view&gt;    &lt;view class&#x3D;&quot;bottom_text&quot;&gt;客服&lt;&#x2F;view&gt;  &lt;&#x2F;view&gt;  &lt;view class&#x3D;&quot;bottom_picture2&quot;&gt;    &lt;view&gt;      &lt;image class&#x3D;&quot;shop&quot; src&#x3D;&quot;..&#x2F;image&#x2F;icon-shop.png&quot; mode&#x3D;&quot;widthFix&quot;&gt;&lt;&#x2F;image&gt;      &lt;view class&#x3D;&quot;bottom_text&quot;&gt;商店&lt;&#x2F;view&gt;    &lt;&#x2F;view&gt;  &lt;&#x2F;view&gt;  &lt;view class&#x3D;&quot;last&quot;&gt;    &lt;button class&#x3D;&quot;button&quot;&gt;立即购买&lt;&#x2F;button&gt;  &lt;&#x2F;view&gt;&lt;&#x2F;view&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wxss"><a href="#wxss" class="headerlink" title="wxss"></a>wxss</h3><p>.picture{<br>  width: 100%;<br>}</p><p>.myswiper{<br>  width: 100%;<br>  height: 750rpx;<br>}</p><p>.parent{<br>  width: 100%;<br>  height: 250rpx;<br>  display: flex;<br>  flex-direction: column;<br>  /* background-color:blue; */<br>}</p><p>.color1{<br>  width: 100%;<br>  display: flex;<br>  flex-direction: row;<br>  /* background-color: yellow; */<br>  flex-grow: 1;<br>}</p><p>.color2{<br>  width: 100%;<br>  display: flex;<br>  flex-direction:column;<br>  /* background-color:green; */<br>  flex-grow: 2;<br>}</p><p>.text1{<br>  /* background-color: red; */<br>  padding-left: 25rpx;<br>  display: flex;<br>  flex-direction: column;<br>  align-items: flex-start;<br>  justify-content: center;<br>  flex-grow: 1;<br>}</p><p>.text2{<br>  /* background-color: blue; */<br>  display: flex;<br>  flex-direction: column;<br>  padding-right: 25rpx;<br>  align-items: flex-end;<br>  justify-content: center;<br>  flex-grow: 1;<br>}</p><p>.text3{<br>  /* background-color: blue; */<br>  display: flex;<br>  padding-left: 20rpx;<br>  flex-direction: column;<br>  justify-content: center;<br>  flex-grow: 1;<br>}</p><p>.text4{<br>  /* background-color: brown; */<br>  display: flex;<br>  padding-left: 20rpx;<br>  flex-direction: column;<br>  justify-content: center;<br>  flex-grow: 1;<br>}</p><p>.money{<br>  color: red;<br>  font-size: 40rpx;<br>  font-weight: bold;<br>}</p><p>.people{<br>  color:#DCDCDC;<br>  font-size: 25rpx;<br>}</p><p>.apple{<br>  font-size: 40rpx;<br>  font-weight: bold;<br>}</p><p>.apple_computer{<br>  color:#DCDCDC;<br>  font-size: 25rpx;<br>}</p><p>.bottom{<br>  position: fixed;<br>  bottom: 0;<br>  width: 100%;<br>  height: 100rpx;<br>  /* background:yellow; */<br>  display:flex;<br>  flex-direction: row;<br>}</p><p>.bottom_picture1{<br>  /* background-color: aqua; */<br>  padding-left: 14rpx;<br>  width: 13%;<br>  height: 100rpx;<br>  display: flex;<br>  flex-direction:column;<br>  align-items: center;<br>  justify-content: center;<br>}</p><p>.server{<br>  width: 55rpx;<br>}</p><p>.shop{<br>  width: 55rpx;<br>}</p><p>.bottom_picture2{<br>  /* background-color: rgb(71, 127, 190); */<br>  width: 13%;<br>  height: 100rpx;<br>  display: flex;<br>  flex-direction:column;<br>  align-items: center;<br>  justify-content: center;<br>}</p><p>.bottom_text{<br>  font-size: 28rpx;<br>}</p><p>.last{<br>  padding-left: 30rpx;<br>  display: flex;<br>  flex-direction: column;<br>  align-items: center;<br>  justify-content: center;<br>}</p><p>.button{<br>  width: 460rpx !important;<br>  background: #f12711;  /* fallback for old browsers <em>/<br>  background: -webkit-linear-gradient(to right, #f5af19, #f12711);  /</em> Chrome 10-25, Safari 5.1-6 <em>/<br>  background: linear-gradient(to right, #f5af19, #f12711); /</em> W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */</p><p>  border-radius: 140rpx;<br>  color: white !important;<br>  font-weight: normal;<br>  font-size: 14px;<br>}</p><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><p>Page({<br>  data:{<br>    price:200,<br>    shopname:’我们毕业了’<br>  },<br>  changeImg:function(e){<br>    console.log(e.detail.current)<br>    var currentIndex=e.detail.current<br>    if(currentIndex==0){<br>      this.setData({<br>        price:200,<br>        shopname:’我们毕业了’<br>      })<br>    }else if(currentIndex==1){<br>      this.setData({<br>        price:5700,<br>        shopname:’苹果电脑’<br>      })<br>    }else{<br>      this.setData({<br>        price:12000,<br>        shopname:’华为笔记本’<br>      })<br>    }<br>  }<br>})</p>]]></content>
      
      
      
        <tags>
            
            <tag> wx实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图灵工作室day03</title>
      <link href="/2021/04/11/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A4day03/"/>
      <url>/2021/04/11/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A4day03/</url>
      
        <content type="html"><![CDATA[<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>1.任何一个容器都可以启用flex布局<br>2.flex布局也叫弹性布局</p><pre class="line-numbers language-none"><code class="language-none">(1).display:flex  &#x2F;&#x2F;启用flex布局(2).flex-direction属性决定主轴方向    flex-direction：column &#x2F;&#x2F;设置垂直方向为主轴    flex-direction：raw &#x2F;&#x2F;设置横轴方向为主轴    交叉轴等于法向量，主轴于盒子方向相同(3).对盒子先设置大盒子，justity-content：center;对主轴居中对齐                     他的其他属性                     flex-start（默认值）：左对齐                     flex-end：右对齐                     center： 居中                     space-between：两端对齐，项目之间的间隔都相等。                     space-around：每个项目两侧的间隔相等。所以，项目之间                                    的间隔比项目与边框的间隔大一倍。                                          align-items：center；对交叉轴居中对齐                   他的其他属性                   flex-start：交叉轴的起点对齐。                     flex-end：交叉轴的终点对齐。                     center：交叉轴的中点对齐。                     baseline: 项目的第一行文字的基线对齐。                     stretch（默认值）：如果项目未设置高度或设为auto，将占                                       满整个容器的高度。        在此之后每制造一个小盒子都会按照设定方式排列(4).flex-wrap属性决定盒子排不下的时候是否换行    flex-wrap:nowrap(默认); &#x2F;&#x2F;不换行，如果放不下的情况下会让所有盒子等比例缩小来放    flex-wrap:wrap;        &#x2F;&#x2F;换行，第一行在上方    flex-wrap:wrap-reverse &#x2F;&#x2F;换行，第一行在下方(5).order属性    order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0    order &#x3D; 1;    (6).flex-grow属性    flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大当一个flex-grow为1，而其他为0时，该盒子会占去除那些为0盒子占的空间外的全部空间(7).flex布局自动计算高度不需要去手动分配，会适得其反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他的暂时没有用上就先不补了</strong></p><h2 id="js部分语法"><a href="#js部分语法" class="headerlink" title="js部分语法"></a>js部分语法</h2><p>1.js中不分’ ‘,” “,一般用’ ‘</p><p>2.let 块作用域，var 函数作用域（整个函数中在哪定义生命周期为整个函数）</p><p>3.控制台打印<br>console.log()函数 //普通文本<br>console.warn()函数 //警告文本<br>console.error()函数 //出错文本</p><p>4.input控件disable控制是否允许输入</p><p>5.转浮点和整型来做差来判断精度是否丢失</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图灵工作室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码的规则</title>
      <link href="/2021/04/09/%E7%BC%96%E7%A0%81%E7%9A%84%E8%A7%84%E5%88%99/"/>
      <url>/2021/04/09/%E7%BC%96%E7%A0%81%E7%9A%84%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="记事本的四种编码规则"><a href="#记事本的四种编码规则" class="headerlink" title="记事本的四种编码规则"></a>记事本的四种编码规则</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>在C语言程序中当调用记事本文件时，当里面含有汉字时可能会产生乱码，导致程序的运行失败，写这篇bolg的目的是为了记录一下记事本的四种编码区别</p><h3 id="2-getchar-函数来抓取字符"><a href="#2-getchar-函数来抓取字符" class="headerlink" title="2.getchar()函数来抓取字符"></a>2.getchar()函数来抓取字符</h3><p>当程序从文件中读字符时，如果遇到了文件末尾，就会得到 EOF，EOF 并不是一个字符。但是，从标准输入（就是你的终端）读字符的时候，不可能出现文件末尾的情况，所以终端提供了一个功能，就是当你按下 ctrl+z（Windows）/ ctrl+d（Linux）时，终端告诉程序“标准输入”到了文件末尾，此时你的程序 getchar 会得到 EOF(不一定是-1，目前在CB上是-1)<br><strong>注意：getchar是从缓存中读数据（getchar是以行为单位进行存取的），也就是说，你输入a，程序并不反映，只是把a存到缓存中，直到你输入结束，输了回车，程序才反映</strong></p><h2 id="ANSI编码"><a href="#ANSI编码" class="headerlink" title="ANSI编码"></a>ANSI编码</h2><ol><li>若为英文操作系统则为ASCII码<br> 每个字符用一个字节（8位）表示，最高位恒为0，剩下7位（2^7次方=128）。因为128个值就足够表示所有英文字符，数字字符，英文标点字符，和控制字符了。</li></ol><p><strong>2. 若为中文操作系统则为GBK码<br>    兼容ASCII码表示的字符以外，延伸0x80-0xff。用2个字节表示一个中文字符。解析的时候，如果第一个字节大于127，直接再往后读取一个字节，显示为对应的中文字符。（GBK码的字符集包含了简体和繁体）。</strong><br>3. 若为日文操作系统则为JIS码<br>    里面为日文字符</p><p><strong>所以在不同语种的操作系统下，打开同一个通过ANSI编码的txt，除了ASCII所表示的字符正常显示外，其他字符会有出现乱码的情况，因为解码和编码方式就是不一样的，如修改windows的默认语言为日语，即ANSI编码即为JIS编码</strong></p><h2 id="Unicode编码（把地球上所有的语言的符号，都用统一的字符集来表示）"><a href="#Unicode编码（把地球上所有的语言的符号，都用统一的字符集来表示）" class="headerlink" title="Unicode编码（把地球上所有的语言的符号，都用统一的字符集来表示）"></a>Unicode编码（把地球上所有的语言的符号，都用统一的字符集来表示）</h2><h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><ol><li><p>UTF8是一种变长编码，根据不同的Unicode码值采用不同的存储长度。</p></li><li><p>0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.<br> 110xxxxx 10xxxxxx.如果是这样的格式，以110开头则把两个字节当一个单元</p><p> 1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式，以1110开头则是三个字节当一个单元.（正好x的个数是16个）</p></li><li><p>UTF-8的好处是在网络环境下，比较节约流量，毕竟网络里英文的数据还是最多的</p></li></ol><h3 id="UTF-16编码"><a href="#UTF-16编码" class="headerlink" title="UTF-16编码"></a>UTF-16编码</h3><ol><li><p>UTF-16就是Windows模式的编码模式(Windows里说的Unicode一般都是指这种编码），用2个字节表示任意字符</p></li><li><p>UTF-16分为大端序和小端序（就是字节序，主要是与硬件相关（处理器的架构），与编程语言无关）</p></li></ol><ul><li>Big-endian（大端序）：       数据的高位字节存放在地址的低端 低位字节存放在地址高端(按原来顺序存储)</li><li>Little-endian（小端序）：    数据的高位字节存放在地址的高端 低位字节存放在地址低端(颠倒顺序存储)</li></ul><p>##记事本中的BOM标签</p><ol><li><p>记事本要支持Unicode，就需要使用BOM标签</p></li><li><p>一段二进制编码，如何确定它是GBK还是BIG5还是UTF-16/UTF-8？记事本的做法是在TXT文件的最前面保存一个标签，如果记事本打开一个TXT，发现这个标签，就说明是unicode。标签叫BOM，如果是0xFF 0xFE，是UTF16LE，如果是0xFE 0xFF则UTF16BE，如果是0xEF 0xBB 0xBF，则是UTF-8。如果没有这三个东西，那么就是ANSI，使用操作系统的默认语言编码来解释。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-轮播图</title>
      <link href="/2021/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
      <url>/2021/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="微信小程序-轮播图"><a href="#微信小程序-轮播图" class="headerlink" title="微信小程序-轮播图"></a>微信小程序-轮播图</h2><h3 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h3><pre class="line-numbers language-none"><code class="language-none">&lt;view class&#x3D;&quot;test&quot;&gt;  &lt;image class&#x3D;&quot;picture&quot; src&#x3D;&quot;..&#x2F;image&#x2F;unity.jpeg&quot; mode&#x3D;&quot;widthFix&quot;&gt;  &lt;&#x2F;image&gt;  &lt;view&gt;    unity的游戏开发view  &lt;&#x2F;view&gt;&lt;&#x2F;view&gt;&lt;swiper class&#x3D;&quot;myswiper&quot; indicator-dots&#x3D;&quot;true&quot; autoplay&#x3D;&quot;true&quot; circular&#x3D;&quot;true&quot;&gt;  &lt;swiper-item&gt;    &lt;image src&#x3D;&quot;..&#x2F;image&#x2F;2020.jpg&quot; mode&#x3D;&quot;widthFix&quot;&gt;&lt;&#x2F;image&gt;  &lt;&#x2F;swiper-item&gt;  &lt;swiper-item&gt;    &lt;image src&#x3D;&quot;..&#x2F;image&#x2F;2020.jpg&quot; mode&#x3D;&quot;widthFix&quot;&gt;&lt;&#x2F;image&gt;  &lt;&#x2F;swiper-item&gt;  &lt;swiper-item&gt;    &lt;image src&#x3D;&quot;..&#x2F;image&#x2F;2020.jpg&quot; mode&#x3D;&quot;widthFix&quot;&gt;&lt;&#x2F;image&gt;  &lt;&#x2F;swiper-item&gt;&lt;&#x2F;swiper&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wxss"><a href="#wxss" class="headerlink" title="wxss"></a>wxss</h3><p>.test{<br>  text-align:center;<br>  font-size: 30rpx;<br>  text-decoration: underline;<br>  text-decoration-color: blue;</p><p>}</p><p>.picture{<br>   width: 90%;</p><p>}</p><p>.myswiper{<br>  height: 540rpx;<br>  text-align: center;<br>}<br>.myswiper swiper-item &gt;image{<br>  width: 98%;<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> wx实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-加法计算器</title>
      <link href="/2021/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2021/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="微信小程序-加法计算器"><a href="#微信小程序-加法计算器" class="headerlink" title="微信小程序:加法计算器"></a>微信小程序:加法计算器</h2><h3 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h3><pre class="line-numbers language-none"><code class="language-none">&lt;view class&#x3D;&quot;head&quot;&gt;加法计算器&lt;&#x2F;view&gt;&lt;view class&#x3D;&quot;body&quot;&gt;  &lt;input class&#x3D;&quot;text1&quot; value&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入数据&quot; bindinput&#x3D;&quot;count1&quot;&#x2F;&gt;  &lt;view class&#x3D;&quot;text2&quot;&gt;+&lt;&#x2F;view&gt;  &lt;input class&#x3D;&quot;text1&quot; value&#x3D;&quot;&quot; placeholder&#x3D;&quot;请输入数据&quot; bindinput&#x3D;&quot;count2&quot;&#x2F;&gt;  &lt;view class&#x3D;&quot;text2&quot;&gt;&#x3D;&lt;&#x2F;view&gt;  &lt;view class&#x3D;&quot;text1&quot;&gt;&#123;&#123;a&#125;&#125;&lt;&#x2F;view&gt;&lt;&#x2F;view&gt;&lt;view&gt;  &lt;button class&#x3D;&quot;button&quot; bindtap&#x3D;&quot;button1&quot;&gt;等于&lt;&#x2F;button&gt;&lt;&#x2F;view&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wsss"><a href="#wsss" class="headerlink" title="wsss"></a>wsss</h3><pre class="line-numbers language-none"><code class="language-none">.head&#123;  text-align: center;  letter-spacing: 10rpx;  font-size: 80rpx;  color: deepskyblue;&#125;.body&#123;  margin-top: 80rpx;  width: 100%;  display: flex;  flex-direction:&quot;row&quot;;  align-items: center;&#125;.text1&#123;  width: 200rpx;  height: 53rpx;  border: 4rpx solid green;  margin-left: 15rpx; &#x2F;*外边距*&#x2F;  font-size: 36rpx;  padding-left: 14rpx; &#x2F;*内边距*&#x2F;  border-radius: 10rpx; &#x2F;*设置圆角*&#x2F;  color: aqua;&#125;.text2&#123;  font-size: 36rpx;  margin-left: 10rpx;  font-weight: bolder;&#125;.button&#123;  margin-top: 50rpx;  width: 200rpx !important;  color: black !important;  background-color: yellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><pre class="line-numbers language-none"><code class="language-none">var b;var c;Page(&#123;  data:(&#123;    a:Number.parseFloat(0)  &#125;),  count1(e)&#123; &#x2F;*带参是把控件的值传进来 *&#x2F;    console.log(e)    b &#x3D; e.detail.value    b &#x3D; Number.parseFloat(b)  &#125;,  count2(e)&#123; &#x2F;*带参是把控件的值传进来 *&#x2F;    console.log(e)    c&#x3D;e.detail.value    c &#x3D; Number.parseFloat(c)  &#125;,  button1(e)&#123;    let d&#x3D;Number.parseFloat(this.data.a)    d&#x3D;b+c    this.setData(&#123;      a:d    &#125;)    console.warn(d)  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> wx实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图灵工作室day02</title>
      <link href="/2021/03/25/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A4day02/"/>
      <url>/2021/03/25/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A4day02/</url>
      
        <content type="html"><![CDATA[<p>1.选择器的优先级<br>id&gt;class&gt;标签选择器<br>可以提供样式的多元化</p><p>2.class可以多次使用，id只能使用一次</p><p>3.最外层为id选择器可以逐步进入层次修改样式,当用父子的时候只可以高的向低的层次调用</p><pre class="line-numbers language-none"><code class="language-none">&#39;&gt;&#39;为父子级的所有的调用&#39; &#39;为跨级的调用，底下所有的都会跨级调用&#39;&gt;&#39;优先级大于&#39; &#39;4.只有文字可以进行样式渗透5.!important强制优先显示，但同时有还是看优先级<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.js基础格式</p><pre class="line-numbers language-none"><code class="language-none">Page(&#123;data:(&#123;&#125;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>7.各种标签的使用<br>(1)view标签</p><pre class="line-numbers language-none"><code class="language-none">&lt;view&gt;&lt;&#x2F;view&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最常使用的标签（方便简洁）</p><p>(2)input标签（显示文本框）</p><pre class="line-numbers language-none"><code class="language-none">&lt;input &#x2F;&gt;内置一般属性type&#x3D;&quot;text&quot; 点击文本框时弹出键盘  &#x2F;&#x2F;还有其他三种弹出方式，详情见开发者文档value&#x3D;&quot;&quot; 里面放置的文字直接显示在文本框上placeholder&#x3D;&quot;&quot; 里面放置的文字为文本框前的提示bindinput&#x3D;&quot;&quot; 里面自己起名字是连接js用的类似前面的选择器，在js调用时，直接写名字加一个参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3)button标签</p><pre class="line-numbers language-none"><code class="language-none">&lt;button&gt;&lt;&#x2F;button&gt;内置一般属性type&#x3D;&quot;&quot; 设置按钮的样式，自定义的话要加最高级bindtap&#x3D;&quot;&quot; bindinput&#x3D;&quot;&quot; 里面自己起名字是连接js用的类似前面的选择器，在js调用时，直接写名字加一个参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图灵工作室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图灵工作室day01</title>
      <link href="/2021/03/13/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A4day01/"/>
      <url>/2021/03/13/%E5%9B%BE%E7%81%B5%E5%B7%A5%E4%BD%9C%E5%AE%A4day01/</url>
      
        <content type="html"><![CDATA[<h3 id="微信小程序简介"><a href="#微信小程序简介" class="headerlink" title="微信小程序简介"></a>微信小程序简介</h3><p>1.微信小程序是以微信为载体，使用微信内置的浏览器</p><p>2.微信开创了二维码时代</p><p>3.微信公众平台是微信开发的一个综合性平台</p><p>4.微信小商店(新)可以去玩下</p><h3 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h3><p>1.初学者一般使用pages文件下的文件组进行开发,常用的是index.wxml,index.wxss<br>2.image的属性中除了src还有代码mode=”widthFix”等比例缩放<br>3.swiper滚动特效(轮播器),swiper标签下面必须要跟多组swiper-item标签,在swiper-item中可以继续使用    其他标签<br>4.html与css关系<br>属性(html)=&gt;样式(css)<br>class=&gt;.<br>id=&gt;#<br>5.插入图片(html部分)</p><pre class="line-numbers language-none"><code class="language-none">&lt;image src&#x3D;&quot;..&#x2F;xxxx&#x2F;xxxx&#x2F;xxx.png&quot;&gt;     &#x2F;&#x2F;图片格式随意<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6.css的一些样式</p><pre class="line-numbers language-none"><code class="language-none">1.text-align:center;居中 &#x2F;&#x2F;注意这个需要在外部盒子中写,影响内部盒子2.font-size:30rpx; 设置字体大小 &#x2F;&#x2F;rpx结尾则字体可随设备变化而比例变化,px就不行3.text-decoration:underline; 设置下划线 &#x2F;&#x2F;引用则产生下划线4.text-decoration-color:blue; 设置下划线颜色 &#x2F;&#x2F;这里为蓝色,可以用#加数字来弄颜色5.width:90%; 宽度为屏幕的90% <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.用QQ截取颜色<br>打开QQ的截图功能,放在电脑屏幕中要的颜色上,按ctrl+c复制色号在剪贴板</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图灵工作室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轰炸代码</title>
      <link href="/2021/03/08/%E8%BD%B0%E7%82%B8%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/03/08/%E8%BD%B0%E7%82%B8%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言实现QQ的代码轰炸"><a href="#C语言实现QQ的代码轰炸" class="headerlink" title="C语言实现QQ的代码轰炸"></a>C语言实现QQ的代码轰炸</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><p>通过使用Windows的句柄来实现对桌面窗口的控制，获取QQ界面发送的句柄，然后通过虚拟键盘来控制，来实现键盘控制QQ消息的发送</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main()&#123;    int a&#x3D;0,i,j;    char name[100];    char sentence[100];    printf(&quot;Window of name:&quot;);    scanf(&quot;%s&quot;,name);    HWND h &#x3D; FindWindow(0,name);    printf(&quot;The once:&quot;);    scanf(&quot;%d&quot;,&amp;a);    printf(&quot;The Sentence is:&quot;);    scanf(&quot;%s&quot;,sentence);    for(i&#x3D;0;i&lt;a;i++)    &#123;        for(j&#x3D;0;j&lt;strlen(sentence);j++)        &#123;            SendMessage(h,WM_CHAR,sentence[j]&amp;0xff,0);        &#125;        SendMessage(h,WM_KEYDOWN,VK_RETURN,0);        SendMessage(h,WM_KEYUP,VK_RETURN,0);    &#125;    printf(&quot;\n\nfinish&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h3><ul><li>首先打开QQ打开想要轰炸的代码窗口<br><a href="https://imgtu.com/i/6lbHZ4"><img src="https://s3.ax1x.com/2021/03/08/6lbHZ4.jpg" alt="6lbHZ4.jpg"></a></li><li>输入窗体名称（将窗口最小化后把鼠标放在最小化窗口上）</li><li>输入轰炸次数</li><li>输入轰炸内容<br><a href="https://imgtu.com/i/6lqkFA"><img src="https://s3.ax1x.com/2021/03/08/6lqkFA.jpg" alt="6lqkFA.jpg"></a></li><li>确保要轰炸的窗口保持在黑窗口下</li><li>按Enter键开始轰炸</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言寒假复习(1)</title>
      <link href="/2020/12/16/C%E8%AF%AD%E8%A8%80%E5%AF%92%E5%81%87%E5%A4%8D%E4%B9%A0-1/"/>
      <url>/2020/12/16/C%E8%AF%AD%E8%A8%80%E5%AF%92%E5%81%87%E5%A4%8D%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言寒假复习-1"><a href="#C语言寒假复习-1" class="headerlink" title="C语言寒假复习(1)"></a>C语言寒假复习(1)</h2><h3 id="C语言基础代码（Hello-world）"><a href="#C语言基础代码（Hello-world）" class="headerlink" title="C语言基础代码（Hello world）"></a>C语言基础代码（Hello world）</h3><p><strong>使用记事本来完成，在Linux环境下编译</strong><br>#include &lt;stdio.h&gt;<br>int main(void){<br>    printf(“Hello world”);<br>    return 0;<br>}</p><p><strong>错误的将头文件stdio.h写成了studio.h，要多练，不练必废</strong><br>成功生成<br><img src="https://s3.ax1x.com/2020/12/17/rGrlVK.jpg" alt="Hello world" title="Hello world"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月下独酌四首_其一</title>
      <link href="/2020/12/08/%E6%9C%88%E4%B8%8B%E7%8B%AC%E9%85%8C%E5%9B%9B%E9%A6%96-%E5%85%B6%E4%B8%80/"/>
      <url>/2020/12/08/%E6%9C%88%E4%B8%8B%E7%8B%AC%E9%85%8C%E5%9B%9B%E9%A6%96-%E5%85%B6%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="致20岁生日的诗"><a href="#致20岁生日的诗" class="headerlink" title="致20岁生日的诗"></a>致20岁生日的诗</h2><p><strong>月下独酌四首.其一</strong><br>花间一壶酒，独酌无相亲。<br>举杯邀明月，对影成三人。<br>月既不解饮，影徒随我身。<br>暂伴月将影，行乐须及春。<br>我歌月徘徊，我舞影零乱。<br>醒时相交欢，醉后各分散。<br>永结无情游，相期邈云汉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> my-think </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBirthday do</title>
      <link href="/2020/12/08/MyBirthday-do/"/>
      <url>/2020/12/08/MyBirthday-do/</url>
      
        <content type="html"><![CDATA[<h2 id="送给生日的代码"><a href="#送给生日的代码" class="headerlink" title="送给生日的代码"></a>送给生日的代码</h2><h3 id="希望之后努力一点，不要再写这种偏落水的代码"><a href="#希望之后努力一点，不要再写这种偏落水的代码" class="headerlink" title="希望之后努力一点，不要再写这种偏落水的代码"></a>希望之后努力一点，不要再写这种偏落水的代码</h3><p>在未来的一年，希望把握住时间，改掉拖延的习惯</p><hr><h3 id="程序（送给2020的自己的代码）"><a href="#程序（送给2020的自己的代码）" class="headerlink" title="程序（送给2020的自己的代码）"></a>程序（送给2020的自己的代码）</h3><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace _2021&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            int a;            Console.WriteLine(&quot;how time is do this ? , It is my birthday&quot;);            string year1,month1,day1;            int year,month,day;            Console.Write(&quot;The year is:&quot;);            year1&#x3D;Console.ReadLine();            year &#x3D; int.Parse(year1);            Console.Write(&quot;The month is:&quot;);            month1&#x3D;Console.ReadLine();            month &#x3D; int.Parse(month1);            Console.Write(&quot;The day is:&quot;);            day1 &#x3D; Console.ReadLine();            day &#x3D; int.Parse(day1);            birth liu &#x3D; new birth();            a&#x3D;liu.Liu(year, month, day);            if (a &#x3D;&#x3D; 0)            &#123;                MessageBox.Show(&quot;no is not&quot;);            &#125;            Console.ReadKey();                    &#125;    &#125;        class birth    &#123;        public int Liu(int a, int b, int c)        &#123;            if (a &#x3D;&#x3D; 2020)            &#123;                if (b &#x3D;&#x3D; 12)                &#123;                    if (c &#x3D;&#x3D; 8)                    &#123;                        Console.WriteLine(&quot;Happy Birthday LXS&quot;);                        MessageBox.Show(&quot;The timely Wind and Rain have to happen in 2021, Let&#39;s to see&quot;);                        return 1;                    &#125;                    else                    &#123;                        return 0;                    &#125;                &#125;                else                &#123;                    return 0;                &#125;            &#125;            else            &#123;                return 0;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题-icalm的更换</title>
      <link href="/2020/11/24/%E4%B8%BB%E9%A2%98-icalm%E7%9A%84%E6%9B%B4%E6%8D%A2/"/>
      <url>/2020/11/24/%E4%B8%BB%E9%A2%98-icalm%E7%9A%84%E6%9B%B4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-更换主题的代码储存"><a href="#1-更换主题的代码储存" class="headerlink" title="1.更换主题的代码储存"></a>1.更换主题的代码储存</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;D:\blog中的themes中存放blog的主题，在themes的文件夹中有一个本身hexo默认自带的丑主题，现在自己下载了一个叫做hexo-theme-icalm的主题的文件夹也是放在这里，现在对这个主题进行修改。</p><h3 id="2-主题的个性化设置"><a href="#2-主题的个性化设置" class="headerlink" title="2.主题的个性化设置"></a>2.主题的个性化设置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;打开hexo-theme-icalm文件夹中有 _ config.yml的代码，最后使用win+r，在cmd中打开，如果有下载node.js可以直接用记事本打开，进入后</p><pre class="line-numbers language-none"><code class="language-none">#Links on sidebarmenu:  Home: &#x2F;  Archive: &#x2F;archives&#x2F;  #Tags: &#x2F;tags&#x2F;  #Categories: &#x2F;categories&#x2F;  #About: &#x2F;about&#x2F;#Pictures shown on the sidebar#Use the absolute URL after generating#avatar: &#x2F;assets&#x2F;tree_small.png#sidebar_background: &#x2F;assets&#x2F;header.pngrss: &#x2F;atom.xml#Contentexcerpt_link: Read On »#Will be shown on the bottom.##To add new icon, just copy .svg to source&#x2F;assets&#x2F; and add entries below.media:  #github: https:&#x2F;&#x2F;github.com&#x2F;nameoverflow  #facebook: https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100004252391322source_han_font: true#Disqus settingsdisqus:  #&#39;disabled&#39; | &#39;all&#39; | &#39;post&#39;  enable: disabled  #Shortname of your disqus website.  #See disqus admin  shortname:#Miscellaneousfavicon:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里#后面都是有一个空格，为了md的可读性我就删了</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;第一行中的menu是文件格式的菜单一共有5个功能，一般现在我能使用的就是前面三个和一个about，但是about还是不太懂弄所以只是显示按钮，如果要把这句话启用，则去除前面的# 就可以了<strong>注意是#和之后的一个空格都需要去掉</strong></p><p>如果需要设置头像可以看到**#avatar: /assets/tree_small.png**这一行，在同路径下可以看到一个叫source的文件夹，在这个文件夹中可以看见有一个assets的文件夹，如HTML一样，把需要的头像改名放在里面，再把这句话启用，把后面照片文件名改成你的，即可以发现照片引用完毕</p><p>还有一个**#sidebar_background: /assets/header.png**大胆的猜测这个是照片后面的背景，但是我觉得没有的话也是很好看就没有启用这个了</p><p><strong>引用样式tags</strong><br>    在每一个blog中都有一个tags标记，这个主题也是一样可以使用tags标记进行使用，在初期没有弄明白tags的使用方式所以这个功能一直没有什么用。<br>启用方式<br>    用win+r，cmd打开控制台窗口，进入到blog这个文件夹中运行</p><pre class="line-numbers language-none"><code class="language-none">hexo n page &quot;tags&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开这个生成的文件夹，在里面加入type: “tags”<br>加入后是这样的</p><pre class="line-numbers language-none"><code class="language-none">title: tagsdate: 2021-04-14 18:55:02type: &quot;tags&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>至此文件的tags标签即可以正常引用了</p><p>后面的内容待发掘</p><h4 id="待更"><a href="#待更" class="headerlink" title="待更"></a>待更</h4><h3 id="3-需要设置博客的名字与引用主题"><a href="#3-需要设置博客的名字与引用主题" class="headerlink" title="3.需要设置博客的名字与引用主题"></a>3.需要设置博客的名字与引用主题</h3><p>回到blog文件夹中，里面有一个名叫 _ config.yml的文件，一样的方式打开后</p><ul><li>在title中更改你的blog名字</li><li>在subtitle添加你的副标题</li><li>把language改为zh-‘CN’</li><li>找到后面的theme改为你刚刚弄得主题的文件夹名</li></ul><p>至此blog的初始化完成<br><strong>后续功能待更</strong></p><p><strong>更新日期2020/12/26：完成对代码块的样式更改</strong><br><strong>更新日期2021/4/14：完成对tags样式的引用的补充</strong></p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown笔记</title>
      <link href="/2020/11/23/markdown%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/11/23/markdown%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown使用规范"><a href="#markdown使用规范" class="headerlink" title="markdown使用规范"></a>markdown使用规范</h1><p><strong>makedown的标记都为英文状态</strong></p><h2 id="1-对标题的放大缩小"><a href="#1-对标题的放大缩小" class="headerlink" title="1.对标题的放大缩小"></a>1.对标题的放大缩小</h2><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>中间注意是有空格的</p><h2 id="2-加粗与斜体"><a href="#2-加粗与斜体" class="headerlink" title="2.加粗与斜体"></a>2.加粗与斜体</h2><p><strong>加粗</strong><br><em>斜体</em><br><strong><em>加粗且斜体</em></strong><br>注意这里中间不能有空格</p><h2 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3.删除线"></a>3.删除线</h2><p><del>删除线</del><br>注意这里中间不能有空格</p><h2 id="4-引用内容"><a href="#4-引用内容" class="headerlink" title="4. 引用内容"></a>4. 引用内容</h2><blockquote><p>很好</p><blockquote><blockquote><p>这个引用需要多个&gt;来弄只有一级没什么效果</p></blockquote></blockquote></blockquote><h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><hr><p>三个或三个以上的</p><h2 id="6-插入图片"><a href="#6-插入图片" class="headerlink" title="6.插入图片"></a>6.插入图片</h2><p><img src="%E5%9B%BE%E7%89%87" alt="图片下面的文字" title="鼠标放在图片上显示的文字"></p><p><img src="https://s3.ax1x.com/2020/11/23/DG42sx.jpg" alt="hello" title="企鹅"></p><p>[]里是显示文字的这里不知道为什么显示不出来</p><h2 id="7-插入超链接"><a href="#7-插入超链接" class="headerlink" title="7.插入超链接"></a>7.插入超链接</h2><p><strong>不能跳转页面打开</strong><br>[超链接名字] (超链接地址) 中间空格去掉<br><a href="https://www.jianshu.com/p/191d1e21f7ed/">简书-markdown</a></p><p><strong>可以跳转页面打开</strong><br><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank">简书</a></p><h2 id="8-无序列表"><a href="#8-无序列表" class="headerlink" title="8.无序列表"></a>8.无序列表</h2><ul><li><ul><li><ul><li>三种样式</li></ul></li></ul></li></ul><p>分别是- + * 后接空格来处理的</p><h2 id="9-有序列表"><a href="#9-有序列表" class="headerlink" title="9.有序列表"></a>9.有序列表</h2><p>语法：数字加.  按回车自动生成后面的部分，也可以在.后加一个空格字体会后置，不需要继续有序列表的的话在后面不加内容直接回车即可<br>1.A<br>2.B</p><ol><li>A</li><li>B</li></ol><h2 id="10-列表嵌套"><a href="#10-列表嵌套" class="headerlink" title="10.列表嵌套"></a>10.列表嵌套</h2><p>上一级和下一级之间敲三个空格即可</p><ol><li>A<ul><li>1<ul><li>a</li></ul></li></ul></li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>姓名</th><th align="center">学号</th><th align="right">年级</th></tr></thead><tbody><tr><td>张三</td><td align="center">0001</td><td align="right">2019</td></tr><tr><td>李四</td><td align="center">0002</td><td align="right">2020</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">三个~~~上下框选住代码即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>源代码</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;flowst&#x3D;&gt;start: startop&#x3D;&gt;operation: My Operationcond&#x3D;&gt;condition: Yes or No?e&#x3D;&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&#96;&#96;&#96;注意cond()里面只能是小写,大写就弄不成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-flow" data-language="flow"><code class="language-flow">st<span class="token operator">=></span>start<span class="token operator">:</span> startop<span class="token operator">=></span>operation<span class="token operator">:</span> My Operationcond<span class="token operator">=></span>condition<span class="token operator">:</span> Yes or No<span class="token operator">?</span>e<span class="token operator">=></span>endst<span class="token operator">-</span><span class="token operator">></span>op<span class="token operator">-</span><span class="token operator">></span>cond<span class="token function">cond</span><span class="token punctuation">(</span>yes<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>e<span class="token function">cond</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>op<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><pre><code>&amp;nbsp；表示空格，注意分号为英文状态下</code></pre><p><strong>最后一次更新日期2020/12/26：更新内容完成对后面内容的补充</strong><br><strong>完结</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
